<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HIBERNATE - Persistenza Relazionale Idiomatica per Java</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="it"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>HIBERNATE - Persistenza Relazionale Idiomatica per Java</h1></div><div><h2 class="subtitle">Documentazione di Riferimento</h2></div><div><p class="releaseinfo">2.1.6</p></div></div><div></div><hr></div><div class="toc"><p><b>Sommario</b></p><dl><dt><span class="preface"><a href="#preface">Prefazione</a></span></dt><dt><span class="chapter"><a href="#quickstart">1. Primi passi con Tomcat</a></span></dt><dd><dl><dt><span class="sect1"><a href="#quickstart-intro">1.1. Iniziare a lavorare con Hibernate</a></span></dt><dt><span class="sect1"><a href="#quickstart-persistentclass">1.2. La prima classe persistente</a></span></dt><dt><span class="sect1"><a href="#quickstart-mapping">1.3. Mappare il gatto</a></span></dt><dt><span class="sect1"><a href="#quickstart-playingwithcats">1.4. Giochiamo con i gatti</a></span></dt><dt><span class="sect1"><a href="#quickstart-summary">1.5. Infine</a></span></dt></dl></dd><dt><span class="chapter"><a href="#architecture">2. Architettura</a></span></dt><dd><dl><dt><span class="sect1"><a href="#architecture-overview">2.1. Introduzione</a></span></dt><dt><span class="sect1"><a href="#architecture-jmx">2.2. Integrazione con JMX</a></span></dt><dt><span class="sect1"><a href="#architecture-jca">2.3. Supporto a JCA</a></span></dt></dl></dd><dt><span class="chapter"><a href="#session-configuration">3. Configurazione della SessionFactory</a></span></dt><dd><dl><dt><span class="sect1"><a href="#configuration-programmatic">3.1. Configurazione programmativa</a></span></dt><dt><span class="sect1"><a href="#configuration-sessionfactory">3.2. Ottenere una SessionFactory</a></span></dt><dt><span class="sect1"><a href="#configuration-userjdbc">3.3. Connessioni JDBC fornite dall'utente</a></span></dt><dt><span class="sect1"><a href="#configuration-hibernatejdbc">3.4. Connessioni JDBC fornite da Hibernate</a></span></dt><dt><span class="sect1"><a href="#configuration-optional">3.5. Configurazione di propriet&agrave; opzionali</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuration-optional-dialects">3.5.1. Dialetti SQL</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-outerjoin">3.5.2. Reperimento via join esterno</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-binarystreams">3.5.3. Flussi (stream) binari</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-cacheprovider">3.5.4. CacheProvider personalizzati</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-transactionstrategy">3.5.5. Configurazione della strategia transazionale</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-jndi">3.5.6. SessionFactory pubblicata sul JNDI</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-querysubstitution">3.5.7. Sostituzioni per il linguaggio di interrogazione</a></span></dt></dl></dd><dt><span class="sect1"><a href="#configuration-logging">3.6. Traccia di esecuzione (logging)</a></span></dt><dt><span class="sect1"><a href="#configuration-namingstrategy">3.7. Implementazione di una strategia di denominazione (NamingStrategy)</a></span></dt><dt><span class="sect1"><a href="#configuration-xmlconfig">3.8. File di configurazione XML</a></span></dt></dl></dd><dt><span class="chapter"><a href="#persistent-classes">4. Le classi persistenti</a></span></dt><dd><dl><dt><span class="sect1"><a href="#persistent-classes-pojo">4.1. Un semplice esempio POJO</a></span></dt><dd><dl><dt><span class="sect2"><a href="#persistent-classes-pojo-accessors">4.1.1. Dichiarate metodi di accesso e di impostazione (get e set) per i campi persistenti</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-constructor">4.1.2. Implementate un costruttore di default</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-identifier">4.1.3. Fornite una propriet&agrave; identificatore (opzionale)</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-final">4.1.4. Preferite classi non-final (opzionale)</a></span></dt></dl></dd><dt><span class="sect1"><a href="#persistent-classes-inheritance">4.2. Utilizzo dell'ereditariet&agrave;</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-equalshashcode">4.3. Implementate equals() e hashCode()</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-lifecycle">4.4. Punti di richiamo del ciclo di vita degli oggetti ("lifecycle callbacks")</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-validatable">4.5. Punto di aggancio (callback) Validatable</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-xdoclet">4.6. Utilizzo del contrassegno (markup) di XDoclet</a></span></dt></dl></dd><dt><span class="chapter"><a href="#mapping">5. Mappaggio O/R di base</a></span></dt><dd><dl><dt><span class="sect1"><a href="#mapping-declaration">5.1. Dichiarazione dei mappaggi</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-declaration-doctype">5.1.1. Doctype</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-mapping">5.1.2. hibernate-mapping</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-class">5.1.3. class</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id">5.1.4. id</a></span></dt><dd><dl><dt><span class="sect3"><a href="#mapping-declaration-id-generator">5.1.4.1. generator</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-hilo">5.1.4.2. Algoritmo Hi/Lo</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-uuid">5.1.4.3. Algoritmo UUID</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-sequences">5.1.4.4. Colonne "Identity" e "Sequence"</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-assigned">5.1.4.5. Identificatori assegnati</a></span></dt></dl></dd><dt><span class="sect2"><a href="#mapping-declaration-compositeid">5.1.5. composite-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-discriminator">5.1.6. discriminatori</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-version">5.1.7. versione (opzionale)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-timestamp">5.1.8. timestamp (opzionale)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-property">5.1.9. property</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-manytoone">5.1.10. many-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-onetoone">5.1.11. one-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-component">5.1.12. component, dynamic-component</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-subclass">5.1.13. subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-joinedsubclass">5.1.14. joined-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-collections">5.1.15. map, set, list, bag</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-import">5.1.16. import</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-types">5.2. Tipi di Hibernate</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-types-entitiesvalues">5.2.1. Entit&agrave; e valori</a></span></dt><dt><span class="sect2"><a href="#mapping-types-basictypes">5.2.2. Tipi di valore di base</a></span></dt><dt><span class="sect2"><a href="#mapping-types-enum">5.2.3. Tipi di enumerazione persistente</a></span></dt><dt><span class="sect2"><a href="#mapping-types-custom">5.2.4. Tipi di valore personalizzati</a></span></dt><dt><span class="sect2"><a href="#mapping-types-anymapping">5.2.5. Tipi di mappaggio "any"</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-quotedidentifiers">5.3. Identificatori SQL tra virgolette</a></span></dt><dt><span class="sect1"><a href="#mapping-modularfiles">5.4. File di mappaggio modulari</a></span></dt></dl></dd><dt><span class="chapter"><a href="#collections">6. Mappaggio delle collezioni</a></span></dt><dd><dl><dt><span class="sect1"><a href="#collections-persistent">6.1. Collezioni persistenti</a></span></dt><dt><span class="sect1"><a href="#collections-mapping">6.2. Come mappare una collezione</a></span></dt><dt><span class="sect1"><a href="#collections-ofvalues">6.3. Collezioni di valori e associazioni molti-a-molti</a></span></dt><dt><span class="sect1"><a href="#collections-onetomany">6.4. Associazioni uno-a-molti</a></span></dt><dt><span class="sect1"><a href="#collections-lazy">6.5. Inizializzazione differita (lazy)</a></span></dt><dt><span class="sect1"><a href="#collections-sorted">6.6. Collezioni ordinate</a></span></dt><dt><span class="sect1"><a href="#collections-idbag">6.7. L'uso degli &lt;idbag&gt;</a></span></dt><dt><span class="sect1"><a href="#collections-bidirectional">6.8. Associazioni bidirezionali</a></span></dt><dt><span class="sect1"><a href="#collections-ternary">6.9. Associazioni ternarie</a></span></dt><dt><span class="sect1"><a href="#collections-heterogeneous">6.10. Associazioni eterogenee</a></span></dt><dt><span class="sect1"><a href="#collections-example">6.11. Esempi di collezioni</a></span></dt></dl></dd><dt><span class="chapter"><a href="#components">7. Mappaggio dei componenti</a></span></dt><dd><dl><dt><span class="sect1"><a href="#components-dependentobjects">7.1. Oggetti dipendenti</a></span></dt><dt><span class="sect1"><a href="#components-incollections">7.2. Collezioni di oggetti dipendenti</a></span></dt><dt><span class="sect1"><a href="#components-asmapindex">7.3. Componenti come indici delle mappe</a></span></dt><dt><span class="sect1"><a href="#components-compositeid">7.4. Componenti come identificatori composti</a></span></dt><dt><span class="sect1"><a href="#components-dynamic">7.5. Componenti dinamici</a></span></dt></dl></dd><dt><span class="chapter"><a href="#inheritance">8. Mappaggio di gerarchie di ereditariet&agrave;</a></span></dt><dd><dl><dt><span class="sect1"><a href="#inheritance-strategies">8.1. Le tre strategie</a></span></dt><dt><span class="sect1"><a href="#inheritance-limitations">8.2. Limitazioni</a></span></dt></dl></dd><dt><span class="chapter"><a href="#manipulatingdata">9. Lavorare con i dati persistenti</a></span></dt><dd><dl><dt><span class="sect1"><a href="#manipulatingdata-creating">9.1. Creazione di un oggetto persistente</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-loading">9.2. Caricamento di un oggetto</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-querying">9.3. Interrogazioni</a></span></dt><dd><dl><dt><span class="sect2"><a href="#manipulatingdata-scalarqueries">9.3.1. Interrogazioni scalari</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-queryinterface">9.3.2. L'interfaccia Query</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-scrolling">9.3.3. Iterazioni scrollabili</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-filtering">9.3.4. Filtraggio delle collezioni</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-criteria">9.3.5. Interrogazioni per criteri</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-nativesql">9.3.6. Interrogazioni in SQL nativo</a></span></dt></dl></dd><dt><span class="sect1"><a href="#manipulatingdata-updating">9.4. Aggiornamento degli oggetti</a></span></dt><dd><dl><dt><span class="sect2"><a href="#manipulatingdata-updating-insession">9.4.1. Aggiornamento nella stessa Session</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-updating-detached">9.4.2. Aggiornamento di oggetti sganciati</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-update-lock">9.4.3. Riaggancio di oggetti sganciati</a></span></dt></dl></dd><dt><span class="sect1"><a href="#manipulatingdata-deleting">9.5. Cancellazione di oggetti persistenti</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-flushing">9.6. Scaricamento (flush)</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-endingsession">9.7. Fine di una sessione</a></span></dt><dd><dl><dt><span class="sect2"><a href="#manipulatingdata-endingsession-flushing">9.7.1. Scaricamento della sessione</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-endingsession-commit">9.7.2. Commit della transazione sul database</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-endingsession-close">9.7.3. Chiusura della sessione</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-endingsession-exceptions">9.7.4. Gestione delle eccezioni</a></span></dt></dl></dd><dt><span class="sect1"><a href="#manipulatingdata-graphs">9.8. Cicli di vita e grafi di oggetti</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-interceptors">9.9. Intercettatori (interceptors)</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-metadata">9.10. API dei metadati</a></span></dt></dl></dd><dt><span class="chapter"><a href="#transactions">10. Transazioni e concorrenza</a></span></dt><dd><dl><dt><span class="sect1"><a href="#transactions-basics">10.1. Configurazioni, sessioni e "factory"</a></span></dt><dt><span class="sect1"><a href="#transactions-threads">10.2. Thread e connessioni</a></span></dt><dt><span class="sect1"><a href="#transactions-identity">10.3. Considerazioni sull'identit&agrave; degli oggetti</a></span></dt><dt><span class="sect1"><a href="#transactions-optimistic">10.4. Controllo di concorrenza ottimistico</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-optimistic-longsession">10.4.1. Sessione lunga con versionamento automatico</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-detached">10.4.2. Sessioni multiple con versionamento automatico</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-manual">10.4.3. Controllo delle versioni da parte dell'applicazione</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-disconnection">10.5. Disconnessione della sessione</a></span></dt><dt><span class="sect1"><a href="#transactions-locking">10.6. Locking Pessimistico</a></span></dt></dl></dd><dt><span class="chapter"><a href="#queryhql">11. HQL: Il linguaggio di interrogazione di Hibernate (Hibernate Query Language)</a></span></dt><dd><dl><dt><span class="sect1"><a href="#queryhql-casesensitivity">11.1. Dipendenza da maiuscole e minuscole</a></span></dt><dt><span class="sect1"><a href="#queryhql-from">11.2. La clausola from</a></span></dt><dt><span class="sect1"><a href="#queryhql-joins">11.3. Associazioni e join</a></span></dt><dt><span class="sect1"><a href="#queryhql-select">11.4. La clausola select</a></span></dt><dt><span class="sect1"><a href="#queryhql-aggregation">11.5. Funzioni aggregate</a></span></dt><dt><span class="sect1"><a href="#queryhql-polymorphism">11.6. Interrogazioni polimorfiche</a></span></dt><dt><span class="sect1"><a href="#queryhql-where">11.7. La clausola where</a></span></dt><dt><span class="sect1"><a href="#queryhql-expressions">11.8. Espressioni</a></span></dt><dt><span class="sect1"><a href="#queryhql-ordering">11.9. La clausola order by</a></span></dt><dt><span class="sect1"><a href="#queryhql-grouping">11.10. La clausola group by</a></span></dt><dt><span class="sect1"><a href="#queryhql-subqueries">11.11. Sottointerrogazioni</a></span></dt><dt><span class="sect1"><a href="#queryhql-examples">11.12. Esempi HQL</a></span></dt><dt><span class="sect1"><a href="#queryhql-tipstricks">11.13. Suggerimenti</a></span></dt></dl></dd><dt><span class="chapter"><a href="#querycriteria">12. Interrogazioni per criteri</a></span></dt><dd><dl><dt><span class="sect1"><a href="#querycriteria-creating">12.1. Creazione di un'istanza di Criteria</a></span></dt><dt><span class="sect1"><a href="#querycriteria-narrowing">12.2. Riduzione dell'insieme dei risultati</a></span></dt><dt><span class="sect1"><a href="#querycriteria-ordering">12.3. Ordinamento dei risultati</a></span></dt><dt><span class="sect1"><a href="#querycriteria-associations">12.4. Associazioni</a></span></dt><dt><span class="sect1"><a href="#querycriteria-dynamicfetching">12.5. Caricamento dinamico delle associazioni</a></span></dt><dt><span class="sect1"><a href="#querycriteria-examples">12.6. Interrogazioni per esempi</a></span></dt></dl></dd><dt><span class="chapter"><a href="#querysql">13. Interrogazioni SQL native</a></span></dt><dd><dl><dt><span class="sect1"><a href="#querysql-creating">13.1. Creazione di una Query basaa su SQL</a></span></dt><dt><span class="sect1"><a href="#querysql-aliasreferences">13.2. Alias e riferimenti alle propriet&agrave;</a></span></dt><dt><span class="sect1"><a href="#querysql-namedqueries">13.3. Interrogazioni SQL con nome</a></span></dt></dl></dd><dt><span class="chapter"><a href="#performance">14. Ottimizzare le prestazioni di Hibernate</a></span></dt><dd><dl><dt><span class="sect1"><a href="#performance-collections">14.1. Capire gli aspetti legati alle prestazioni delle collezioni</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-collections-taxonomy">14.1.1. Tassonomia</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficientupdate">14.1.2. Liste, mappe e insiemi sono le collezioni pi&ugrave; efficienti da modificare</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficentinverse">14.1.3. I bag e le liste sono le collezioni inverse pi&ugrave; efficienti</a></span></dt><dt><span class="sect2"><a href="#performance-collections-oneshotdelete">14.1.4. Cancellazione in un colpo solo</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-proxies">14.2. Mediatori (proxy) per l'inizializzazione a richiesta (lazy)</a></span></dt><dt><span class="sect1"><a href="#performance-cache">14.3. La cache di secondo livello</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-cache-mapping">14.3.1. Mappaggi e cache</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readonly">14.3.2. Strategia: sola lettura</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readwrite">14.3.3. Strategia: lettura/scrittura</a></span></dt><dt><span class="sect2"><a href="#performance-cache-nonstrict">14.3.4. Strategia: lettura/scrittura non stretta</a></span></dt><dt><span class="sect2"><a href="#performance-cache-transactional">14.3.5. Strategia: transazionale</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-sessioncache">14.4. Gestione della cache di Session</a></span></dt><dt><span class="sect1"><a href="#performance-querycache">14.5. La cache delle query</a></span></dt></dl></dd><dt><span class="chapter"><a href="#toolsetguide">15. Guida degli strumenti</a></span></dt><dd><dl><dt><span class="sect1"><a href="#toolsetguide-s1">15.1. Generazione dello schema</a></span></dt><dd><dl><dt><span class="sect2"><a href="#toolsetguide-s1-2">15.1.1. Personalizzazione dello schema</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-3">15.1.2. Esecuzione del programma</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-4">15.1.3. Propriet&agrave;</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-5">15.1.4. Utilizzo di Ant</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-6">15.1.5. Aggiornamenti incrementali dello schema</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-7">15.1.6. Utilizzo di Ant per gli aggiornamenti incrementali dello schema</a></span></dt></dl></dd><dt><span class="sect1"><a href="#toolsetguide-s2">15.2. Generazione di codice</a></span></dt><dd><dl><dt><span class="sect2"><a href="#toolsetguide-s2-1">15.2.1. Il file di configurazione (opzionale)</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s2-2">15.2.2. L'attributo meta</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s2-3">15.2.3. Generatore elementare di metodi individuatori ("finder")</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s2-4">15.2.4. Generatore basato su Velocity</a></span></dt></dl></dd><dt><span class="sect1"><a href="#toolsetguide-s3">15.3. Generazione dei file di mappaggio</a></span></dt><dd><dl><dt><span class="sect2"><a href="#toolsetguide-s3-1">15.3.1. Esecuzione dello strumento</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#example-parentchild">16. Esempio: Genitore/Figlio (Parent/Child)</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-parentchild-collections">16.1. Una nota sulle collezioni</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-bidir">16.2. Uno-a-molti bidirezionale</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-cascades">16.3. Ciclo di vita con cascate</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-update">16.4. Come utilizzare update() in cascata</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-conclusion">16.5. Conclusione</a></span></dt></dl></dd><dt><span class="chapter"><a href="#example-weblog">17. Esempio: una applicazione che realizza un weblog</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-weblog-classes">17.1. Classi persistenti</a></span></dt><dt><span class="sect1"><a href="#example-weblog-mappings">17.2. Mappaggi di hibernate</a></span></dt><dt><span class="sect1"><a href="#example-weblog-code">17.3. Codice di Hibernate</a></span></dt></dl></dd><dt><span class="chapter"><a href="#example-mappings">18. Alcuni mappaggi di esempio</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-mappings-emp">18.1. Employer/Employee (Datore di lavoro / impiegato)</a></span></dt><dt><span class="sect1"><a href="#example-mappings-authorwork">18.2. Autore/Opera (Author/Work)</a></span></dt><dt><span class="sect1"><a href="#example-mappings-customerorderproduct">18.3. Cliente/Ordine/Prodotto (Customer/Order/Product)</a></span></dt></dl></dd><dt><span class="chapter"><a href="#best-practices">19. Buone abitudini (best practices)</a></span></dt></dl></div><div class="preface" lang="it"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>Prefazione</h2></div></div><div></div></div><p>
            WARNING! This is a translated version of the English Hibernate reference
            documentation. The translated version might not be up to date! However, the
            differences should only be very minor. Consult the English reference
            documentation if you are missing information or encounter a translation
            error. If you like to contribute to a particular translation, contact us
            on the Hibernate developer mailing list.
        </p><p>
            Translator(s): Davide Baroncelli &lt;baroncelli@yahoo.com&gt;
        </p><p>
	    Lavorare con linguaggi orientati agli oggetti e database relazionale negli odierni ambienti aziendali 
	    pu&ograve; essere difficoltoso e temporalmente impegnativo. Hibernate &egrave; uno strumento di mappaggio tra oggetti e relazioni (OR)
	    per gli ambienti basati su java. Il termine "mappaggio oggetto-relazionale" ("object relational mapping" o ORM in inglese)
	    si riferisce alla tecnica di creare una corrispondenza (mappare) tra una rappresentazione di dati secondo il modello a oggetti ed 
	    quella secondo il modello relazionale, con uno schema basato su SQL.
        </p><p>
	    Hibernate si occupa non solo del mappaggio dalle classi Java alle tabelle della base di dati 
	    (e dai tipi di dato Java a quelli SQL), ma fornisce anche funzionalit&agrave; di interrogazione e recupero dei dati
	    (query), e pu&ograve; ridurre significativamente i tempi di sviluppo altrimenti impiegati in attivit&agrave; manuali di
	    gestione dei dati in SQL e JDBC.
        </p><p>
	    Lo scopo di Hibernate &egrave; di alleviare lo sviluppatore dal 95% dei pi&ugrave; comuni compiti
	    di programmazione legati alla persistenza dei dati. Hibernate pu&ograve; non essere la soluzione
	    migliore per le applicazioni data-centriche che usano solo stored-procedures per implementare
	    la logica di business nel database; &egrave; principalmente utile con modelli di dominio orientati agli 
	    oggetti in cui la logica di business sia collocata nello strato intermedio di oggetti Java (middle-tier).
	    In ogni caso, Hibernate pu&ograve; aiutare senza dubbio a rimuovere o incapsulare codice SQL che sia dipendente
	    dal particolare fornitore, e aiutare con i compiti pi&ugrave; comuni di traduzione dei set di risultati (result set)
	    da una rappresentazione tabellare ad un grafo di oggetti.
        </p><p>
	    Se sei un principiante di Hibernate e del mappaggio OR o addirittura di Java, ti preghiamo di 
	    seguire questi passi:
        </p><div class="orderedlist"><ol type="1"><li><p>
		    Leggi <a href="#quickstart" title="Capitolo&nbsp;1.&nbsp;Primi passi con Tomcat">Capitolo&nbsp;1, <i>Primi passi con Tomcat</i></a>: &egrave; un'introduzione di mezz'ora che usa Tomcat.
                </p></li><li><p>
                    Leggi <a href="#architecture" title="Capitolo&nbsp;2.&nbsp;Architettura">Capitolo&nbsp;2, <i>Architettura</i></a> per capire in quali contesti Hibernate pu&ograve; essere usato.
                </p></li><li><p>
		    Dai un'occhiata alla cartella <tt class="literal">eg/</tt> nella distribuzione di Hibernate,
		    contiene una semplice applicazione "standalone". Copia il tuo driver JDBC nella cartella
		    <tt class="literal">lib/</tt> e modifica <tt class="literal">src/hibernate.properties</tt>,
		    specificando valori corretti per il tuo database. Da una finestra di terminale aperta
		    nella cartella di distribuzione digita <tt class="literal">ant eg</tt> (usando Ant) o, se in Windows, digita
                    <tt class="literal">build eg</tt>.
                </p></li><li><p>
		    Usa questa documentazione di riferimento come la tua fonte principale di informazioni.
                </p></li><li><p>
					Sul sito di Hibernate &egrave; possibile trovare le risposte alle domande pi&ugrave; frequenti (FAQ)
				</p></li><li><p>
				        Sempre sul sito, &egrave; possibile trovare esempi, demo di terze parti e tutorial.
				</p></li><li><p>
		    L'area di community sul sito di Hibernate &egrave; una buona fonte di pattern di design e varie soluzioni 
		    di utilizzo integrato di Hibernate (con Tomcat, Jboss, Spring, Struts, EJB, ecc.).
                </p></li></ol></div><p>
	     Se hai domande, usa il forum di cui trovi il link sul sito di Hibernate. &Egrave; anche disponibile
	     un sistema di "issue tracking" (tracciamento dei problemi) JIRA per segnalare bachi e richiedere
	     funzionalit&agrave;. Se sei interessato nello sviluppo di Hibernate, iscriviti alla mailing list degli 
	     sviluppatori.
         </p><p>
	     Sono disponibili contratti di sviluppo su base commerciale, supporto per sistemi in produzione e 
	     formazione su Hibernate tramite il JBoss Inc. (vedi http://www.hibernate.org/SupportTraining/). 
	     Hibernate &egrave; un progetto della suite di prodotti "JBoss Professional Open Source".
         </p></div><div class="chapter" lang="it"><div class="titlepage"><div><div><h2 class="title"><a name="quickstart"></a>Capitolo&nbsp;1.&nbsp;Primi passi con Tomcat</h2></div></div><div></div></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-intro"></a>1.1.&nbsp;Iniziare a lavorare con Hibernate</h2></div></div><div></div></div><p>
	    Questo corso introduttivo mostra come installare Hibernate 2.1 nel servlet container 
	    Apache Tomcat per realizzare una applicazione web. Hibernate funziona bene sia in ambienti 
	    gestiti dai principali server J2EE, sia in applicazioni java a s&eacute; stanti. Il 
	    sistema di gestione di basi di dati (DBMS) usato in questa introduzione &egrave; PostgreSQL 7.3, ma per farla
	    funzionare su altri database &egrave; solo necessario modificare la configurazione del dialetto SQL che 
	    viene usato da Hibernate.
        </p><p>
	    Prima di tutto, dobbiamo copiare tutte le librerie richieste nell'installazione di Tomcat.
	    Usiamo un contesto web separato (<tt class="literal">webapps/quickstart</tt>) per
	    questa introduzione, e quindi dobbiamo considerare sia il percorso di ricerca globale delle
	    librerie (<tt class="literal">TOMCAT/common/lib</tt>) sia il classloader al livello del contesto in
            <tt class="literal">webapps/quickstart/WEB-INF/lib</tt> (per i file JAR) e
            <tt class="literal">webapps/quickstart/WEB-INF/classes</tt>. Ci riferiremo ai due livelli di classloader 
	    con i termini di "classpath globale" e "classpath di contesto".
        </p><p>
	    Ora, copiate le librerie nei due classpath:
        </p><div class="orderedlist"><ol type="1"><li><p>
		    Copiate il driver JDBC per il database nel classpath globale. Questo &egrave; richiesto
		    per il software di gestione dei "lotti di connessioni" (connection pool) DBCP che 
		    &egrave; preinstallato con Tomcat. Hibernate usa le connessioni JDBC per eseguire l'SQL sul 
		    database, cos&igrave; gli si deve fornire connessioni JDBC provenienti da un pool o configurare
		    Hibernate in modo tale da usare uno dei pool supportati direttamente (C3P0, Proxool). 
		    Per questo particolare tutoriale, copiate la libreria <tt class="literal">pg73jdbc3.jar</tt> 
		    (per  ostgreSQL 7.3 e il JDK 1.4) nel percorso globale. Se voleste usare un database differente,
		    copiate semplicemente il driver JDBC appropriato.
                </p></li><li><p>
					Non copiate mai niente altro nel classpath globale di Tomcat, o avrete problemi
					con vari tool, compreso log4j, commons-logging e altri. Usate sempre il classpath
					di contesto per ogni applicazione web, cio&egrave; copiate le librerie in <tt class="literal">WEB-INF/lib</tt> 
					e le vostre classi e file di configurazione/propriet&agrave; in <tt class="literal">WEB-INF/classes</tt>. 
					Entrambe le cartelle sono situate per default nel classpath a livello di contesto.
				</p></li><li><p>
		    Hibernate &egrave; distribuito come una libreria JAR. Il file <tt class="literal">hibernate2.jar</tt>
		    dovrebbe venire copiato nel classpath di contesto insieme con le altre classi dell'applicazione.
		    Hibernate durante l'esecuzione richiede alcune librerie fornite da terze parti: queste sono fornite
		    con la distribuzione di Hibernate nella cartella <tt class="literal">lib/</tt>; vedete <a href="#3rdpartylibs" title="Tabella&nbsp;1.1.&nbsp;&#xA;                Librerie esterne richieste da Hibernate&#xA;            ">Tabella&nbsp;1.1, &#8220;
                Librerie esterne richieste da Hibernate
            &#8221;</a>.
		    Copiate ora le librerie richieste nel classpath di contesto.
                </p></li></ol></div><div class="table"><a name="3rdpartylibs"></a><p class="title"><b>Tabella&nbsp;1.1.&nbsp;
                Librerie esterne richieste da Hibernate
            </b></p><table summary="&#xA;                Librerie esterne richieste da Hibernate&#xA;            " border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">
                            Libreria
                        </th><th align="center">
                            Descrizione
                        </th></tr></thead><tbody><tr><td>
                            dom4j (obbligatoria)
                        </td><td>
			    Hibernate usa dom4j per fare il parsing dei file di configurazione XML, cos&igrave; come
			    i file di metadati (sempre in XML).
                        </td></tr><tr><td>
                            CGLIB (obbligatoria)
                        </td><td>
			    Hibernate usa questa libreria di generazione del codice per potenziare le 
			    classi all'avvio (in combinazione con la "reflection" di Java)
                        </td></tr><tr><td>
                            Commons Collections, Commons Logging (obbligatorie)
                        </td><td>
			    Hibernate usa varie librerie di utilit&agrave; provenienti dal progetto Apache Jakarta
                            Commons.
                        </td></tr><tr><td>
                            ODMG4 (obbligatoria)
                        </td><td>
			    Hibernate fornisce un gestore di persistenza opzionale compatibile
			    con la specifica ODMC. Se volete mappare delle 
			    collezioni, &egrave; obbligatorio anche se non intendete usare l'API ODMG. 
			    Non mapperemo collezioni, in questo articolo introduttivo, ma &egrave; comunque 
			    una buona idea copiare il JAR.
                        </td></tr><tr><td>
                            EHCache (obbligatoria)
                        </td><td>
                            Hibernate pu&ograve; usare diversi fornitori di cache per la cache di secondo livello. 
			    EHCache &egrave; la cache predefinita, se non viene cambiata nella configurazione.
                        </td></tr><tr><td>
                            Log4j (opzionale)
                        </td><td>
			    Hibernate usa l'API di Commons Logging, che a sua volta pu&ograve; usare Log4j 
			    come meccanismo sottostante di gestione delle tracce di esecuzione (logging).
			    Se la libreria di Log4j &egrave; disponibile nella cartella di contesto, Commons Logging
			    user&agrave; Log4j e il file di configurazione <tt class="literal">log4j.properties</tt> situato
			    nel classpath di contesto. Un file di esempio per la configurazione di Log4j &egrave; 
			    fornito con la distribuzione di Hibernate. Quindi, copiate log4j,jar ed il file di 
			    configurazione (da <tt class="literal">src/</tt>) nel vostro classpath di contesto se volete
			    vedere cosa succede dietro al sipario.
                        </td></tr><tr><td>
                            Richiesta o no?
                        </td><td>
			    Date un'occhiata al file <tt class="literal">lib/README.txt</tt> nella distribuzione di 
			    Hibernate. &Egrave; una lista aggiornata delle librerie di terze parti distribuite con 
			    Hibernate. Vi troverete elencate tutte le librerie opzionali ed obbligatorie.
                        </td></tr></tbody></table></div><p>
	    Ora configureremo il pooling delle connessioni e la condivisione sia in Tomcat
	    sia in Hibernate. Questo significa che tomcat fornir&agrave; connessioni JDBC estratte
	    da un pool (usando le funzionalit&agrave; offerte dalla libreria DBCP inclusa), e Hibernate
	    richieder&agrave; queste connessioni via JNDI. Tomcat collega il pool di connessioni al JNDI se 
	    aggiungiamo la dichiarazione della risorsa al file di configurazione principale di Tomcat, 
	    <tt class="literal">TOMCAT/conf/server.xml</tt>:
        </p><pre class="programlisting">&lt;Context path="/quickstart" docBase="quickstart"&gt;
    &lt;Resource name="jdbc/quickstart" scope="Shareable" type="javax.sql.DataSource"/&gt;
    &lt;ResourceParams name="jdbc/quickstart"&gt;
        &lt;parameter&gt;
            &lt;name&gt;factory&lt;/name&gt;
            &lt;value&gt;org.apache.commons.dbcp.BasicDataSourceFactory&lt;/value&gt;
        &lt;/parameter&gt;

        &lt;!-- DBCP database connection settings --&gt;
        &lt;parameter&gt;
            &lt;name&gt;url&lt;/name&gt;
            &lt;value&gt;jdbc:postgresql://localhost/quickstart&lt;/value&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
            &lt;name&gt;driverClassName&lt;/name&gt;&lt;value&gt;org.postgresql.Driver&lt;/value&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
            &lt;name&gt;username&lt;/name&gt;
            &lt;value&gt;quickstart&lt;/value&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
            &lt;name&gt;password&lt;/name&gt;
            &lt;value&gt;secret&lt;/value&gt;
        &lt;/parameter&gt;

        &lt;!-- DBCP connection pooling options --&gt;
        &lt;parameter&gt;
            &lt;name&gt;maxWait&lt;/name&gt;
            &lt;value&gt;3000&lt;/value&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
            &lt;name&gt;maxIdle&lt;/name&gt;
            &lt;value&gt;100&lt;/value&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
            &lt;name&gt;maxActive&lt;/name&gt;
            &lt;value&gt;10&lt;/value&gt;
        &lt;/parameter&gt;
    &lt;/ResourceParams&gt;
&lt;/Context&gt;</pre><p>
			Il contesto che configuriamo in questo esempio di chiama<tt class="literal">quickstart</tt>,
			ed ha base nella cartella <tt class="literal">TOMCAT/webapp/quickstart</tt>. Per accedere
			dei servlet, bisogna chiamare il percorso <tt class="literal">http://localhost:8080/quickstart</tt>
			nel browser (naturalmente, aggiungendo il nome del servlet cos&igrave; come &egrave; mappato nel file
			<tt class="literal">web.xml</tt>). Potete anche procedere e creare un semplice servlet, che abbia un 
			metodo <tt class="literal">process()</tt> vuoto
		</p><p>
	    Tomcat usa il pool di connessioni DBCP con questa configurazione e fornisce <tt class="literal">Connessioni</tt> 
            JDBC da un pool reperito tramite JNDI all'indirizzo <tt class="literal">java:comp/env/jdbc/quickstart</tt>. 
	    Se avete problemi a far funzionare il pool di connessioni, fate riferimento alla documentazione di Tomcat.
	    Se ricevete messaggi di eccezione dal driver JDBC, provate prima ad impostare il pool senza Hibernate. 
	    Sul web &egrave; possibile trovare degli articoli introduttivi sia su Tomcat sia su JDBC.
        </p><p>
	    Il prossimo passo &egrave; configurare Hibernate, usando le connessioni dal pool collegato al JNDI.
	    Usiamo la configurazione XML di Hibernate. L'approccio pi&ugrave; semplice, che usa file di propriet&agrave;,
	    &egrave; equivalente in funzionalit&agrave; ma non offre nessun vantaggio. Usiamo quindi la configurazione XML
	    perch&eacute; di solito &egrave; pi&ugrave; conveniente: il file di configurazione XML si trova nel classpath di contesto
	    (<tt class="literal">WEB-INF/classes</tt>), come <tt class="literal">hibernate.cfg.xml</tt>:
        </p><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!DOCTYPE hibernate-configuration
    PUBLIC "-//Hibernate/Hibernate Configuration DTD//EN"
    "http://hibernate.sourceforge.net/hibernate-configuration-2.0.dtd"&gt;

&lt;hibernate-configuration&gt;

    &lt;session-factory&gt;

        &lt;property name="connection.datasource"&gt;java:comp/env/jdbc/quickstart&lt;/property&gt;
        &lt;property name="show_sql"&gt;false&lt;/property&gt;
        &lt;property name="dialect"&gt;net.sf.hibernate.dialect.PostgreSQLDialect&lt;/property&gt;

        &lt;!-- Mapping files --&gt;
        &lt;mapping resource="Cat.hbm.xml"/&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre><p>
	    Disattiviamo il tracciamento dei comandi SQL e diciamo ad Hibernate quale
	    dialetto SQL deve venire usato, e dove prendere le connessioni JDBC (dichiarando
	    l'indirizzo del datasource che d&agrave; accesso al pool collegato in Tomcat). Il dialetto
	    &egrave; un'impostazione necessaria, poich&eacute; i database differiscono nella loro interpretazione
	    dello "standard" SQL. Hibernate gestisce le differenze e viene fornito con dialetti per 
	    tutti i principali database commerciali e open source.
        </p><p>
            La <tt class="literal">SessionFactory</tt> &egrave; il concetto che in Hibernate corrisponde 
	    ad un contenitore di dati (datastore) univoco. Database multipli possono essere
	    usati creando file di configurazione XML multipli e creando pi&ugrave; oggetti<tt class="literal">Configuration</tt>
            e <tt class="literal">SessionFactory</tt> nella vostra applicazione.
        </p><p>
	    L'ultimo elemento del file <tt class="literal">hibernate.cfg.xml</tt> dichiara
            <tt class="literal">Cat.hbm.xml</tt> come nome di un file di mappaggio XML di Hibernate per la
	    classe persistente <tt class="literal">Cat</tt>. Questo file contiene i metadati per il mappaggio
	    delle classi POJO (acronimo che sta per "plain old java object", ovvero pi&ugrave; o meno "oggetto java puro
	    e semplice", contrapposto ad oggetti che implementano interfacce particolari come gli Enterprise 
	    Javabeans) verso una tabella di database (o verso tabelle multiple).
	    Torneremo presto su questo file, prima per&ograve; scriviamo la classe POJO e poi dichiariamo i suoi metadati 
	    di mappaggio.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-persistentclass"></a>1.2.&nbsp;La prima classe persistente</h2></div></div><div></div></div><p>
	    Hibernate funziona meglio con il modello degli oggetti POJO per le classi persistenti.
	    Un POJO &egrave; pi&ugrave; o meno come un JavaBean, con propriet&agrave; accessibili tramite metodi "getter"
	    e "setter" (rispettivametne per recuperare e impostare le propriet&agrave;), mascherando la 
	    rappresentazione interna tramite l'interfaccia pubblicamente visibile:
        </p><pre class="programlisting">package net.sf.hibernate.examples.quickstart;

public class Cat {

    private String id;
    private String name;
    private char sex;
    private float weight;

    public Cat() {
    }

    public String getId() {
        return id;
    }

    private void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public char getSex() {
        return sex;
    }

    public void setSex(char sex) {
        this.sex = sex;
    }

    public float getWeight() {
        return weight;
    }

    public void setWeight(float weight) {
        this.weight = weight;
    }

}</pre><p>
	    Hibernate non &egrave; limitato nel suo uso dei tipi di propriet&agrave; Java, tutti i tipi
	    ed i tipi primitivi del JDK (come<tt class="literal">String</tt>, <tt class="literal">char</tt>
            e <tt class="literal">Date</tt>) possono essere mappati, comprese le classi dal framework
	    delle collezioni. Potete mapparle come valori, collezioni di valori o associazioni 
	    verso altre entit&agrave;. La propriet&agrave; <tt class="literal">id</tt> &egrave; una propriet&agrave; speciale che 
	    rappresenta l'identificatore principale nel database per quella classe (chiave primaria), ed 
	    &egrave; fortemente raccomandato per entit&agrave; come <tt class="literal">Cat</tt>. Hibernate pu&ograve; anche usare 
	    identificatori gestiti solo internamente, ma perderemmoe una parte della flessibilit&agrave; nella
	    nostra architettura applicativa.
        </p><p>
	    Per le classi persistenti non &egrave; richiesta l'implementazione di alcuna interfaccia particolare,
	    n&eacute; dobbiamo ereditare da una speciale classe persistente radice. Hibernate non usa neppure 
	    alcun tipo di computazione in fase di "build" (costruzione del software), come manipolazione
	    del codice binario (byte-code): si appoggia esclusivamente su reflection Java e su potenziamento
	    in fase di esecuzione delle classi (tramite CGLIB). Cos&igrave;, possiamo mappare le classi POJO sul database 
	    senza alcuna dipendenza da Hibernate.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-mapping"></a>1.3.&nbsp;Mappare il gatto</h2></div></div><div></div></div><p>
            Il file di mappaggio <tt class="literal">Cat.hbm.xml</tt> contiene i metadati richiesti per il 
	    mappaggio oggetto-relazione. I metadati includono la dichiarazione delle classi persistenti
	    e il mappaggio delle propriet&agrave; sulle tabelle del database (tramite le colonne e le relazioni 
	    con altre entit&agrave; gestite da chiavi esterne)
       </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping
    PUBLIC "-//Hibernate/Hibernate Mapping DTD//EN"
    "http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd"&gt;

&lt;hibernate-mapping&gt;

    &lt;class name="net.sf.hibernate.examples.quickstart.Cat" table="CAT"&gt;

        &lt;!-- A 32 hex character is our surrogate key. It's automatically
            generated by Hibernate with the UUID pattern. --&gt;
        &lt;id name="id" type="string" unsaved-value="null" &gt;
            &lt;column name="CAT_ID" sql-type="char(32)" not-null="true"/&gt;
            &lt;generator class="uuid.hex"/&gt;
        &lt;/id&gt;

        &lt;!-- A cat has to have a name, but it shouldn' be too long. --&gt;
        &lt;property name="name"&gt;
            &lt;column name="NAME" length="16" not-null="true"/&gt;
        &lt;/property&gt;

        &lt;property name="sex"/&gt;

        &lt;property name="weight"/&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
	    Ogni classe persistente dovrebbe avere un attributo di identificazione (in realt&agrave;,
	    solo classi che rappresentano entit&agrave;, e non gli oggetti dipendenti, che sono 
	    mappati come componenti di un'entit&agrave;). Questa proprit&agrave; viene usata per distinguere
	    oggetti persistenti: due gatti sono uguali se <tt class="literal">catA.getId().equals(catB.getId())</tt> 
	    &egrave; vera: questo concetto &egrave; chiamata <span class="emphasis"><em>identit&agrave; del database</em></span>. 
	    Hibernate &egrave; fornito con vari generatori di identificatori per scenari differenti (compresi
	    generatori nativi per "sequence" del database, tabelle hi/lo sul database, e identificatori
	    assegnati dall'applicazione. Usiamo il generator UUID generator (raccomandato solo per il testing, 
	    poich&eacute; chiavi surrogate intere generate dal database dovrebbero venire preferite) e specifichiamo 
	    anche la colonna <tt class="literal">CAT_ID</tt> della tabella <tt class="literal">CAT</tt> per il valore 
	    dell'identificatore generato da Hibernate (come chiave primaria della tabella).
        </p><p>
	    Tutte le altre propriet&agrave; di <tt class="literal">Cat</tt> sono mappate sulla stessa tabella.
	    Nel caseo della propriet&agrave; <tt class="literal">name</tt>, l'abbiamo mappata con una colonna del 
	    database dichiarata esplicitamente. Questo &egrave; particolarmente utile quando si voglia che lo schema del
	    database venga generato automaticamente (sotto forma di istruzioni SQL DDL) a partire dai file di 
	    mappaggio tramite lo strumento di Hibernate <span class="emphasis"><em>SchemaExport</em></span>. Tutte le altre 
	    propriet&agrave; vengono mappate usando le impostazioni predefinite di Hibernate, che &egrave; ci&ograve; di cui si 
	    ha bisogno la maggior parte delle volte. La tabella <tt class="literal">CAT</tt> nel database appare cos&igrave;:
        </p><pre class="programlisting"> Column |         Type          | Modifiers
--------+-----------------------+-----------
 cat_id | character(32)         | not null
 name   | character varying(16) | not null
 sex    | character(1)          |
 weight | real                  |
Indexes: cat_pkey primary key btree (cat_id)</pre><p>
	
			Dovreste ora creare manualmente la tabella nel database, e pi&ugrave; tardi leggere
			<a href="#toolsetguide" title="Capitolo&nbsp;15.&nbsp;Guida degli strumenti">Capitolo&nbsp;15, <i>Guida degli strumenti</i></a> se volete automatizzare questo passo con lo 
			strumento SchemaExport. Questo strumento pu&ograve; generare un DDL SQL completo, comprendente 
			definizioni delle tabelle, vincoli sui tipi delle colonne, vincoli di unicit&agrave; e indici.
    	</p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-playingwithcats"></a>1.4.&nbsp;Giochiamo con i gatti</h2></div></div><div></div></div><p>
	    Ora siamo pronti per lanciare la <tt class="literal">Session</tt> Hibernate. &Egrave; l'interfaccia di 
            <span class="emphasis"><em>gestione della persistenza</em></span>, la usiamo per memorizzare e recuperare istanze
	    della classe <tt class="literal">Cat</tt> sul e dal database.
            Prima per&ograve; dobbiamo recuperare una istanza di <tt class="literal">Session</tt> (che &egrave; l'unit&agrave; di lavoro di Hibernate)
            dalla <tt class="literal">SessionFactory</tt>:
        </p><pre class="programlisting">SessionFactory sessionFactory =
            new Configuration().configure().buildSessionFactory();</pre><p>
			La <tt class="literal">SessionFactory</tt> &egrave; responsabile per un singolo database, e pu&ograve; 
			usare un file di configurazione solo (<tt class="literal">hibernate.cfg.xml</tt>).
			Potete impostare altre propriet&agrave; (e anche cambiare i metadati di mappaggio) 
			accedendo all'oggetto <tt class="literal">Configuration</tt> <span class="emphasis"><em>prima</em></span>
			di costruire la <tt class="literal">SessionFactory</tt> (&egrave; immutabile). Ma dove creiamo
			la <tt class="literal">SessionFactory</tt> e come vi accediamo nella nostra applicazione?
        </p><p>
			Una <tt class="literal">SessionFactory</tt> viene solitamente costruita una volta sola, ad 
			esempio all'avvio con un servlet impostato con il parametro <span class="emphasis"><em>load-on-startup</em></span>.
			Questo significa anche che non dovreste tenerlo in una variabile di itanza nei vostri sevlet, ma
			in qualche altra posizione. Abbiamo bisogno di qualche tipo di  <span class="emphasis"><em>Singleton</em></span>, 
			in modo tale da poter accedere facilmente alla <tt class="literal">SessionFactory</tt>.
			L'approccio che viene mostrato nel seguito mostra entrambi i problemi: configurazione e accesso
			facile ad una <tt class="literal">SessionFactory</tt>.
		</p><p>
		    Implementiamo una classe di utilit&agrave; <tt class="literal">HibernateUtil</tt>:
		</p><pre class="programlisting">import net.sf.hibernate.*;
import net.sf.hibernate.cfg.*;

public class HibernateUtil {

    private static final SessionFactory sessionFactory;

    static {
        try {
            // Create the SessionFactory
            sessionFactory = new Configuration().configure().buildSessionFactory();
        } catch (HibernateException ex) {
            throw new RuntimeException("Configuration problem: " + ex.getMessage(), ex);
        }
    }

    public static final ThreadLocal session = new ThreadLocal();

    public static Session currentSession() throws HibernateException {
        Session s = (Session) session.get();
        // Open a new Session, if this Thread has none yet
        if (s == null) {
            s = sessionFactory.openSession();
            session.set(s);
        }
        return s;
    }

    public static void closeSession() throws HibernateException {
        Session s = (Session) session.get();
        session.set(null);
        if (s != null)
            s.close();
    }
}</pre><p>
			Questa classe non si occupa solo della <tt class="literal">SessionFactory</tt>
			con il suo attributo statico, ma ha anche un <tt class="literal">ThreadLocal</tt> 
			per mantenere la <tt class="literal">Session</tt> per il thread che &egrave; in esecuzione.
			Assicuratevi di capire il concetto di variabile thread-local in java prima di 
			provare ad usare questa classe.
		</p><p>
            Una <tt class="literal">SessionFactory</tt> &egrave; "threadsafe", ovvero vari thread possono
	    accedervi concorrentemente e richiedere oggetti <tt class="literal">Session</tt>. Una <tt class="literal">Session</tt>
	    &egrave; un oggetto non-threadsafe, che rappresenta una singola unit&agrave; di lavoro con il database. 
            Le <tt class="literal">Session</tt> vengono aperte da una <tt class="literal">SessionFactory</tt> e vengono chiuse
	    quando tutto il lavoro &egrave; completato.
        </p><pre class="programlisting">Session session = HibernateUtil.currentSession();

Transaction tx= session.beginTransaction();

Cat princess = new Cat();
princess.setName("Princess");
princess.setSex('F');
princess.setWeight(7.4f);

session.save(princess);
tx.commit();

HibernateUtil.closeSession();</pre><p>
	    In una <tt class="literal">Session</tt>, ogni operazione sul database avviene in una transazione
	    che isola le operazioni (anche quelle di sola lettura). Usiamo l'API <tt class="literal">Transaction</tt> 
	    di Hibernate per astrarre dalla strategia transazionale sottostante (nel nostro caso, transazioni JDBC).
	    Questo consente di mettere in esecuzione il nostro codice con transazioni gestite dal contenitore (usando
	    JTA) senza alcun cambiamento. Notate che l'esempio sopra non gestisce alcuna eccezione.
        </p><p>
			Notate anche che potete chiamare <tt class="literal">HibernateUtil.currentSession();</tt> tutte le 
			volte che volete, e otterrete sempre la <tt class="literal">Session</tt> corrente per il thread.
			Dovete assicurarvi che la <tt class="literal">Session</tt> venga chiusa dopo che l'unit&agrave; di lavoro
			si completi, o nel servlet o in un servlet filter prima che la risposta HTTP venga inviata.
			L'effetto collaterale piacevole dell'ultimo approccio &egrave; un facile accesso ad un meccanismo
			di inizializzazione "lazy" (pigro, ovvero che carica i dati solo quando servono): la 
			<tt class="literal">Session</tt> &egrave; ancora aperta quando la pagina viene generata, cos&igrave; Hibernate 
			pu&ograve; caricare oggetti non inizializzati quando navigate nel grafo.
        </p><p>
	    Hibernate ha vari metodi che possono essere usati per recuperare oggetti dal database.
	    Il pi&ugrave; flessibile &egrave; usare il linguaggio di query di HIbernate(HQL), che &egrave; 
	    facile da imparare ed una estensinoe potente ed orientata agli oggetti dell'SQL:
        </p><pre class="programlisting">Transaction tx = session.beginTransaction();

Query query = session.createQuery("select c from Cat as c where c.sex = :sex");
query.setCharacter("sex", 'F');
for (Iterator it = query.iterate(); it.hasNext();) {
    Cat cat = (Cat) it.next();
    out.println("Female Cat: " + cat.getName() );
}

tx.commit();</pre><p>
            Hibernate offre anche un'API ad oggetti di <span class="emphasis"><em>query per criteri</em></span> che pu&ograve;
	    essere usata per formulare query "type-safe" (ovvero il cui tipo viene verificato in fase
	    di compilazione). Hibernate usa naturalmente oggetti <tt class="literal">PreparedStatement</tt> 
	    e binding di parametri per tutte le comunicazioni SQL con il database. Potete anche usare
	    le funzionalit&agrave; di interrogazione diretta via SQL di Hibernate, o ricevere una connessione
	    JDBC da una <tt class="literal">Session</tt>.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-summary"></a>1.5.&nbsp;Infine</h2></div></div><div></div></div><p>
            Abbiamo solo sfiorato la superficie di Hibernate in questo breve articolo. Notate che non includiamo 
	    alcun codice specifico per i servlet nei nostri esempi: dovete creare un serlvet voi stessi ed inserire 
	    il codice di Hibernate come preferite.
        </p><p>
			Ricordate che Hibernate, come strato di accesso ai dati, &egrave; strettamente integrato nella vostra
			applicazione. Solitamente, tutti gli altri strati dipendono dal meccanismo di persistenza: siate
			certi di comprendere le implicazioni di questo design.
        </p></div></div><div class="chapter" lang="it"><div class="titlepage"><div><div><h2 class="title"><a name="architecture"></a>Capitolo&nbsp;2.&nbsp;Architettura</h2></div></div><div></div></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-overview"></a>2.1.&nbsp;Introduzione</h2></div></div><div></div></div><p>
            Una visione (molto) di alto livello sull'architettura di Hibernate:
        </p><div class="mediaobject" align="center"><img src="../shared/images/overview.gif" align="middle"></div><p>
            Questo diagramma mostra come Hibernate usa il database e i dati di configurazione
            per fornire servizi di persistenza (e oggetti persistenti) all'applicazione.
        </p><p>
            Vorremmo mostrare una vista pi&ugrave; dettagliata dell'architettura di runtime.
            Sfortunatamente Hibernate &egrave; flessibile, e rende possibili diversi approcci:
            mostreremo quindi i due estremi. L'architettura "leggera" &egrave; quella in cui l'applicazione
            fornisce le sue connessioni JDBC e gestisce le transazioni. Questo approccio usa un
            sottoinsieme minimale delle API di Hibernate.
        </p><div class="mediaobject" align="center"><img src="../shared/images/lite.gif" align="middle"></div><p>
            L'architettura "completa" di Hibernate, permette all'applicazione di 
            astrarre dai dettagli delle API JDBC/JTA e lascia che se ne occupi Hibernate.
        </p><div class="mediaobject" align="center"><img src="../shared/images/full_cream.gif" align="middle"></div><p>
            Ecco alcune definizioni degli oggetti nei diagrammi:    

            </p><div class="variablelist"><dl><dt><span class="term">SessionFactory (<tt class="literal">net.sf.hibernate.SessionFactory</tt>)</span></dt><dd><p>
                            &Egrave; una cache immutabile e "thread-safe" di mappaggi compilati per un database 
                            singolo. Allo stesso tempo &egrave; un factory per oggetti <tt class="literal">Session</tt> 
                            e un client di <tt class="literal">ConnectionProvider</tt>. Potrebbe contenere una cache 
                            di secondo livello opzionale riutilizzabile tra le transazioni, sia a livello di 
                            processo, sia a livello di cluster.
                        </p></dd><dt><span class="term">Session (<tt class="literal">net.sf.hibernate.Session</tt>)</span></dt><dd><p>
                            &Egrave; un oggetto mono-thread, di corta durata, che rappresenta una conversazione
                            tra l'applicazione e il contenitore persistente. Incapsula una connessione 
                            JDBC. &Egrave; un factory per oggetti <tt class="literal">Transaction</tt>. Mantiene una
                            cache obbligatoria (di primo livello) per gli oggetti persistenti, usata quando
                            si naviga il grafo degli oggetti o si ricercano oggetti per identificatore.
                        </p></dd><dt><span class="term">Oggetti persistenti e collezioni</span></dt><dd><p>
                            Sono oggetti di corta durata, a thread singolo, che contengono stato persistente e 
                            funzioni applicative. Potrebbero essere normali oggetti POJO/Javabeans, con l'unica
                            particolarit&agrave; che in un dato momento sono associati con (esattamente) una 
                            <tt class="literal">Session</tt>. Nel momento in cui la <tt class="literal">Session</tt> viene chiusa,
                            verranno staccati e saranno liberi di essere usati in qualsiasi strato applicativo (ad 
                            esempio direttamente come oggetti di trasferimento dei dati da e allo strato di 
                            presentazione).
                        </p></dd><dt><span class="term">Oggetti transienti e collezioni</span></dt><dd><p>
                            Sono le istanze delle classi persistenti che in un dato momento non sono associate con una
                            <tt class="literal">Session</tt>. Possono essere state istanziate dall'applicazione e non (ancora)
                            rese persistenti, o possono essere state istanziate da una <tt class="literal">Session</tt> poi 
                            chiusa.
                        </p></dd><dt><span class="term">Transaction (<tt class="literal">net.sf.hibernate.Transaction</tt>)</span></dt><dd><p>
                            (Opzionale) &Egrave; un oggetto a thread singolo, di corta durata, usato dall'applicazione per 
                            specificare unit&agrave; di lavoro atomiche. Separa le applicazioni dalla transazione JTA, CORBA o 
                            JDBC sottostante. Una <tt class="literal">Session</tt> potrebbe estendersi lungo varie 
                            <tt class="literal">Transaction</tt> in certi casi.
                        </p></dd><dt><span class="term">ConnectionProvider (<tt class="literal">net.sf.hibernate.connection.ConnectionProvider</tt>)</span></dt><dd><p>
                            (Opzionale) Un factory (e pool) di connessioni JDBC. Astrae le applicazioni dai dettagli 
                            dei sottostanti <tt class="literal">Datasource</tt> o <tt class="literal">DriverManager</tt>.
                            Non viene esposta all'applicazione, ma pu&ograve; essere estesa/implementata dagli sviluppatori.
                        </p></dd><dt><span class="term">TransactionFactory (<tt class="literal">net.sf.hibernate.TransactionFactory</tt>)</span></dt><dd><p>
                            (Opzionale) Un factory per istanze di <tt class="literal">Transaction</tt>. Non viene esposta 
                            all'applicazione, ma pu&ograve; essere estesa/implementata dagli sviluppatori.
                        </p></dd></dl></div><p>
        </p><p>
            In un'architettura "leggera", l'applicazione aggira le API
            <tt class="literal">Transaction</tt>/<tt class="literal">TransactionFactory</tt> e/o
            <tt class="literal">ConnectionProvider</tt> per parlare direttamente con JTA o JDBC.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-jmx"></a>2.2.&nbsp;Integrazione con JMX</h2></div></div><div></div></div><p>
            JMX &egrave; lo standard J2EE per lo standard o la gestione di componenti Java. Hibernate pu&ograve; essere gestito 
            tramite un MBean standard JMX, ma poich&eacute; molti application server non supportano ancora JMX, Hibernate 
            consente anche di usare alcuni sistemi di configurazione non-standard.
        </p><p>
            Per cortesia, leggete il sito web di Hibernate per informazioni aggiuntive su come configurare Hibernate
            in modo tale da funzionare come componente JMX in JBoss.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-jca"></a>2.3.&nbsp;Supporto a JCA</h2></div></div><div></div></div><p>
            Hibernate pu&ograve; anche essere configurato come un connettore JCA. Leggete il sito web per altri dettagli.
        </p></div></div><div class="chapter" lang="it"><div class="titlepage"><div><div><h2 class="title"><a name="session-configuration"></a>Capitolo&nbsp;3.&nbsp;Configurazione della SessionFactory</h2></div></div><div></div></div><p>
        Poich&eacute; Hibernate &egrave; progettato per funzionare in molti ambienti differenti,
        ci sono un gran numero di parametri di configurazione. Fortunatamente, la 
        maggior parte hanno dei valori predefiniti, e Hibernate viene distribuito
        con un file <tt class="literal">hibernate.properties</tt> di esempio che mostra
        le differenti opzioni possibili. Solitamente &egrave; sufficiente mettere quel
        file nel classpath e applicare le modifiche necessarie per il proprio ambiente.
    </p><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-programmatic"></a>3.1.&nbsp;Configurazione programmativa</h2></div></div><div></div></div><p>
            Una istanza di <tt class="literal">net.sf.hibernate.cfg.Configuration</tt>
            rappresenta un insieme completo di mappaggi dei tipi java di una applicazione
            verso un database SQL. La <tt class="literal">Configuration</tt> viene usata per 
            costruire un oggetto <tt class="literal">SessionFactory</tt> (immutabile). I 
            mappaggi vengono compilati dai vari file di configurazione XML.
        </p><p>
            Potete ottenere una istanza di <tt class="literal">Configuration</tt> 
            istanziandola direttamnete. Qui di seguito c'&egrave; un esempio di impostazione
            di un contenitore di dati a partire da dei mappaggi definiti in due file di
            configurazione XML (che si trovano sul classpath):
        </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addFile("Item.hbm.xml")
    .addFile("Bid.hbm.xml");</pre><p>
            Una maniera alternativa (e in certi casi migliore), &egrave; di fare in modo che Hibernate
            carichi un file di mappaggio usando <tt class="literal">getResourceAsStream()</tt>:
        </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class);</pre><p>
            In questo caso Hibernate cercher&agrave; file di mappaggio che si chiamano
            <tt class="literal">/org/hibernate/autcion/Item.hbm.xml</tt> e
            <tt class="literal">/org/hibernate/autcion/Bid.hbm.xml</tt> sul classpath. Questo 
            approccio elimina qualsiasi nome di file cablato nel codice.
        </p><p>
            Un oggetto <tt class="literal">Configuration</tt> specifica anche alcune propriet&agrave; opzionali:
        </p><pre class="programlisting">Properties props = new Properties();
...
Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class)
    .setProperties(props);</pre><p>
            Una <tt class="literal">Configuration</tt> viene considerata un oggetto "da fase di configurazione", che va 
            cio&egrave; scartato una volta che una <tt class="literal">SessionFactory</tt> sia stata costruita.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-sessionfactory"></a>3.2.&nbsp;Ottenere una SessionFactory</h2></div></div><div></div></div><p>
            Quando tutti i mappaggi sono stati interpretati dalla <tt class="literal">Configuration</tt>, l'applicazione
            deve costruire una factory per le istanze di <tt class="literal">Session</tt> instances. Questa factory
            &egrave; fatta in modo tale da essere condivisa da tutti i flussi esecutivi (thread) dell'applicazione:
        </p><pre class="programlisting">SessionFactory sessions = cfg.buildSessionFactory();</pre><p>
            Comunque, Hibernate consente alla vostra applicazione di istanziare pi&ugrave; di una
            <tt class="literal">SessionFactory</tt>. Questo &egrave; utile in particolare se state usando
            pi&ugrave; di un database.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-userjdbc"></a>3.3.&nbsp;Connessioni JDBC fornite dall'utente</h2></div></div><div></div></div><p>
            Una <tt class="literal">SessionFactory</tt> pu&ograve; aprire una <tt class="literal">Session</tt> su una
            connessione JDBC fornita dall'utente. Quesa scelta di design d&agrave; la libert&agrave; all'applicazione
            di ottenere le connessioni JDBC in qualunque modo preferisca:
        </p><pre class="programlisting">java.sql.Connection conn = datasource.getConnection();
Session session = sessions.openSession(conn);

// do some data access work</pre><p>
            L'applicazione deve essere molto attenta a non aprire due 
            <tt class="literal">Session</tt>i concorrenti sulla stessa connessione JDBC!
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-hibernatejdbc"></a>3.4.&nbsp;Connessioni JDBC fornite da Hibernate</h2></div></div><div></div></div><p>
            In alternativa potete fare in modo che la  <tt class="literal">SessionFactory</tt>
            apra le connessioni per voi. La <tt class="literal">SessionFactory</tt>
            deve ricevere le propriet&agrave; per le connessioni JDBC in una delle
            maniere seguenti:
        </p><div class="orderedlist"><ol type="1" compact><li><p>
                    Passate una istanza di <tt class="literal">java.util.Properties</tt> al metodo
                    <tt class="literal">Configuration.setProperties()</tt>.
                </p></li><li><p>
                    Mettete il file <tt class="literal">hibernate.properties</tt> in una directory che
                    si trovi alla radice del classpath.
                </p></li><li><p>
                    Impostate le propriet&agrave; <tt class="literal">System</tt> usando
                    <tt class="literal">java -Dproperty=value</tt> all'avvio.
                </p></li><li><p>
                    Includete elementi <tt class="literal">&lt;property&gt;</tt> nel file
                    <tt class="literal">hibernate.cfg.xml</tt>.
                </p></li></ol></div><p>
            Se seguite questo approccio, aprire una <tt class="literal">Session</tt> non &egrave; pi&ugrave; difficile di cos&igrave;:
        </p><pre class="programlisting">Session session = sessions.openSession(); // apre una nuova sessione
// fate del lavoro di accesso ai dati, una connessione JDBC sar&agrave; usata se ce ne sar&agrave; bisogno</pre><p>
            Tutti i nomi e le semantiche delle propriet&agrave; di Hibernate sono definiti nella classe 
            <tt class="literal">net.sf.hibernate.cfg.Environment</tt>. Ora descriveremo le impostazioni
            pi&ugrave; importanti per la configurazione delle connessioni JDBC.
        </p><p>
            Hibernate otterr&agrave; le connessioni usando <tt class="literal">java.sql.DriverManager</tt> (e le manterr&agrave; in un lotto) 
            se impostate le propriet&agrave; seguenti:
        </p><div class="table"><a name="d0e760"></a><p class="title"><b>Tabella&nbsp;3.1.&nbsp;Propriet&agrave; JDBC di Hibernate</b></p><table summary="Propriet&agrave; JDBC di Hibernate" border="1"><colgroup><col><col></colgroup><thead><tr><th>Nome della propriet&agrave;</th><th>Scopo</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.connection.driver_class</tt></td><td><span class="emphasis"><em>classe del driver jdbc</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.url</tt></td><td><span class="emphasis"><em>URL jdbc</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.username</tt></td><td><span class="emphasis"><em>nome utente database</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.password</tt></td><td><span class="emphasis"><em>chiave di accesso al database per l'utente</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.pool_size</tt></td><td><span class="emphasis"><em>numero massimo di connessioni nel lotto</em></span></td></tr></tbody></table></div><p>
            L'algoritmo di "pooling" (mantenimento nel lotto) di Hibernate &egrave; abbastanza rudimentale.
            Ha lo scopo di aiutarvi a cominciare a lavorare, ma <span class="emphasis"><em>non &egrave; fatto per l'uso in un 
            sistema in produzione</em></span>, o anche solo per dei test di performance. Usate un'altra
            libreria di pooling per le migliori performance e la stabilit&agrave;, ovvero sostituite la propriet&agrave;
            <tt class="literal">hibernate.connection.pool_size</tt> con le propriet&agrave; specifiche per il settaggio 
            del pool.
        </p><p>
            C3P0 &egrave; una libreria open source di pooling per connessioni JDBC 
            che viene distribuita insieme ad Hibernate nella directory <tt class="literal">lib</tt>. 
            Hibernate user&agrave; il <tt class="literal">C3P0ConnectionProvider</tt> integrato per il pooling
            delle connessioni se settate le propriet&agrave; <tt class="literal">hibernate.c3p0.*</tt>.
            C'&egrave; anche un supporto integrato per Apache DBCP e per Proxool. Dovete in questo caso
            impostare le propriet&agrave; <tt class="literal">hibernate.dbcp.*</tt> per abilitare il 
            <tt class="literal">DBCPConnectionProvider</tt>. Il caching dei prepared statement &egrave; 
            abilitato se sono impostate le porpriet&agrave; <tt class="literal">hibernate.dbcp.ps.*</tt>
            (caldamente consigliato). Riferitevi alla documentazione di Apache commons-pool per 
            l'interpretazione di queste propriet&agrave;. Se invece volete usare Proxool, settate le 
            propriet&agrave; <tt class="literal">hibernate.proxool.*</tt>.
        </p><p>
            Questo &egrave; un esempio usando C3P0:
        </p><pre class="programlisting">hibernate.connection.driver_class = org.postgresql.Driver
hibernate.connection.url = jdbc:postgresql://localhost/mydatabase
hibernate.connection.username = myuser
hibernate.connection.password = secret
hibernate.c3p0.minPoolSize=5
hibernate.c3p0.maxPoolSize=20
hibernate.c3p0.timeout=1800
hibernate.c3p0.max_statement=50
hibernate.dialect = net.sf.hibernate.dialect.PostgreSQLDialect</pre><p>
            Per l'uso all'interno di un application server, Hibernate pu&ograve; ottenere connessioni da un 
            <tt class="literal">javax.sql.Datasource</tt> registrato nel JNDI. Impostate per questo le 
            propriet&agrave; seguenti: 
        </p><div class="table"><a name="d0e848"></a><p class="title"><b>Tabella&nbsp;3.2.&nbsp;Hibernate Datasource Properties</b></p><table summary="Hibernate Datasource Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Nome della propriet&agrave;</th><th>Scopo</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.connection.datasource</tt></td><td><span class="emphasis"><em>Nome JNDI del datasource</em></span></td></tr><tr><td><tt class="literal">hibernate.jndi.url</tt></td><td><span class="emphasis"><em>URL del provider JNDI</em></span> (optional)
                </td></tr><tr><td><tt class="literal">hibernate.jndi.class</tt></td><td><span class="emphasis"><em>classe dell'<tt class="literal">InitialContextFactory</tt> JNDI</em></span> (optional)
                </td></tr><tr><td><tt class="literal">hibernate.connection.username</tt></td><td><span class="emphasis"><em>utente del database</em></span> (opzionale)
                </td></tr><tr><td><tt class="literal">hibernate.connection.password</tt></td><td><span class="emphasis"><em>chiave di accesso al database per l'utente</em></span> (opzionale)
                </td></tr></tbody></table></div><p>
            Questo &egrave; un esempio usando un datasource fornito dal JNDI dell'application server:
        </p><pre class="programlisting">hibernate.connection.datasource = java:/comp/env/jdbc/MyDB
hibernate.transaction.factory_class = \
    net.sf.hibernate.transaction.JTATransactionFactory
hibernate.transaction.manager_lookup_class = \
    net.sf.hibernate.transaction.JBossTransactionManagerLookup
hibernate.dialect = \
    net.sf.hibernate.dialect.PostgreSQLDialect</pre><p>
            Connessioni JDBC ottenute da un datasource JNDI parteciperanno automaticamete
            alle transazioni gestite dal container dell'application server.
        </p><p>
            Altre propriet&agrave; per la connessione possono venire impostate facendo precedere
            "<tt class="literal">hibernate.connnection</tt>" al nome della propriet&agrave;. Ad esempio, 
            potete specificare un <tt class="literal">charSet</tt> usando <tt class="literal">hibernate.connnection.charSet</tt>.
        </p><p>
            Potete definire la vostra strategia "plugin" per ottenere le connessioni JDBC implementando
            l'interfaccia <tt class="literal">net.sf.hibernate.connection.ConnectionProvider</tt>. Potete
            selezionare una implementazionee custom impostando <tt class="literal">hibernate.connection.provider_class</tt>.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-optional"></a>3.5.&nbsp;Configurazione di propriet&agrave; opzionali</h2></div></div><div></div></div><p>
            C'&egrave; un certo numero di altre propriet&agrave; che controllano il funzionamento in
            fase di esecuzione di Hibernate. Sono tutte opzionali, e hanno dei valori
            predefiniti ragionevoli.
        </p><p>
            Le propriet&agrave; a livello di sistema possono essere impostate eslusivamente tramite
            <tt class="literal">java -Dproperty=value</tt> o essere definite in <tt class="literal">hibernate.properties</tt> 
            e non con una istanza di <tt class="literal">Properties</tt> passata alla classe <tt class="literal">Configuration</tt>.
        </p><div class="table"><a name="d0e947"></a><p class="title"><b>Tabella&nbsp;3.3.&nbsp;Propriet&agrave; per la configurazione di Hibernate</b></p><table summary="Propriet&agrave; per la configurazione di Hibernate" border="1"><colgroup><col><col></colgroup><thead><tr><th>Nome della propriet&agrave;</th><th>Scopo</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.dialect</tt></td><td>
                            Il nome della classe di un <tt class="literal">Dialect</tt> di Hibernate - 
                            attiva alcune funzionalit&agrave; dipendenti dalla piattaforma di database.
                            <p>
                                <span class="strong">e.g.</span> 
                                <tt class="literal">nome.completo.del.Dialect</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.default_schema</tt></td><td>
                            Specificate il nome dello schema/tablespace nei nomi delle tabelle
                            nell'SQL che viene generato.
                            <p>
                                <span class="strong">e.g.</span> 
                                <tt class="literal">NOME_DELLO_SCHEMA</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.session_factory_name</tt></td><td>
                            Il <tt class="literal">SessionFactory</tt> verr&agrave; automaticamente pubblicato
                            sul JNDI sotto questo nome, se &egrave; stato specificato.
                            <p>
                                <span class="strong">e.g.</span> 
                                <tt class="literal">nome/composito/jndi</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.use_outer_join</tt></td><td>
                            Attiva il reperimento via join esterno. Deprecato, usate <tt class="literal">max_fetch_depth</tt>.
                            <p>
                                <span class="strong">e.g.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.max_fetch_depth</tt></td><td>
                            Imposta una "profondit&agrave;" massima per l'albero di join esterno
                            che risolve le associazioni ad una singola estremit&agrave; (uno-a-uno,
                            molti-a-uno). Uno <tt class="literal">0</tt> disabilita la risoluzione
                            via join esterno (che invece &egrave; attivata per default).
                            <p>
                                <span class="strong">e.g.</span> 
                                i valori raccomandati sono tra <tt class="literal">0</tt> e <tt class="literal">3</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.fetch_size</tt></td><td>
                            Un valore non nullo determina le dimensioni di raccolta
                            del JDBC (chiama <tt class="literal">Statement.setFetchSize()</tt>).
                        </td></tr><tr><td><tt class="literal">hibernate.jdbc.batch_size</tt></td><td>
                            Un valore non nullo abilita l'uso dei "batch update" di JDBC 2
                            da parte di Hibernate (aggiornamenti in blocco).
                            <p>
                                <span class="strong">e.g.</span> 
                                I valori raccomandati sono tra <tt class="literal">5</tt> e <tt class="literal">30</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.use_scrollable_resultset</tt></td><td>
                            Consente l'uso di resultset scrollabili JDBC2 da parte di 
                            Hibernate. Questa propriet&agrave; &egrave; necessaria solo quando 
                            vengono usate connessioni JDBC fornite dall'utente: Hibernate
                            usa i metadati di connessione, altrimenti.
                            <p>
                                <span class="strong">e.g.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.use_streams_for_binary</tt></td><td>
                            Se abilitata, Hibernate usa gli stream quando scrive/legge tipi <tt class="literal">binary</tt>
                            o <tt class="literal">serializable</tt> da/a JDBC
                            (propriet&agrave; di livello di sistema).
                            <p>
                                <span class="strong">e.g.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cglib.use_reflection_optimizer</tt></td><td>
                            Abilita l'uso di CGLIB invece di "reflection" in fase di esecuzione
                            (&egrave; una propriet&agrave; a livello di sistema, il default &egrave; usare CGLIB
                            quando possibile). La "reflection" pu&ograve; a volte essere usata in
                            fase di risoluzione dei problemi.
                            <p>
                                <span class="strong">e.g.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jndi.<span class="emphasis"><em>&lt;propertyName&gt;</em></span></tt></td><td>
                            Passa la propriet&agrave; <tt class="literal">propertyName</tt> all'
                            <tt class="literal">InitialContextFactory</tt> JNDI.
                        </td></tr><tr><td><tt class="literal">hibernate.connection.isolation</tt></td><td>
                        Setta il livello di isolamento transazionale JDBC. Consultate
                        la documentazione di <tt class="literal">java.sql.Connection</tt> per
                        ottenere i valori significativi, ma tenete presente che la maggior
                        parte dei database non supportano tutti i livelli di isolamento.
                        <p>
                            <span class="strong">eg.</span> 
                            <tt class="literal">1, 2, 4, 8</tt>
                        </p></td></tr><tr><td><tt class="literal">hibernate.connection.<span class="emphasis"><em>&lt;propertyName&gt;</em></span></tt></td><td>
                        Passa il nome di propriet&agrave; JDBC <tt class="literal">propertyName</tt>
                        a <tt class="literal">DriverManager.getConnection()</tt>.
                    </td></tr><tr><td><tt class="literal">hibernate.connection.provider_class</tt></td><td>
                            Il nome della classe di un <tt class="literal">ConnectionProvider</tt>
                            definito dall'utente.
                            <p>
                                <span class="strong">e.g.</span> 
                                <tt class="literal">nomediclasse.del.ConnectionProvider</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.provider_class</tt></td><td>
                            Il nome di classe di un <tt class="literal">CacheProvider</tt>
                            fornito dall'utente.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">nomediclasse.del.CacheProvider</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.use_minimal_puts</tt></td><td>
                            Ottimizza le operazioni della cache di secondo livello in modo
                            tale da minimizzare le scritture, al costo di letture pi&ugrave; frequenti
                            (usato per cache in cluster).
                            <p>
                                <span class="strong">e.g.</span> 
                                <tt class="literal">true|false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.use_query_cache</tt></td><td>
                            Attiva il caching delle interrogazioni, le query singole vanno comunque 
                            impostate come "cacheabili".
                            <p>
                                <span class="strong">e.g.</span> 
                                <tt class="literal">true|false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.region_prefix</tt></td><td>
                            Il prefisso da usare per i nomi delle regioni della cache
                            di secondo livello.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">prefisso</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.transaction.factory_class</tt></td><td>
                            Il nome di classe di una <tt class="literal">TransactionFactory</tt>
                            da usare con l'API <tt class="literal">Transaction</tt> di Hibernate
                            (il valore predefinito &egrave; <tt class="literal">JDBCTransactionFactory</tt>).
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">nomediclasse.della.TransactionFactory</tt>
                            </p></td></tr><tr><td><tt class="literal">jta.UserTransaction</tt></td><td>
                            Il nome di classe usato da <tt class="literal">JTATransactionFactory</tt> per
                            ottenere la <tt class="literal">UserTransaction</tt> JTA dall'application
                            server.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">nome/composito/jndi</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.transaction.manager_lookup_class</tt></td><td>
                            Il nome di classe di un <tt class="literal">TransactionManagerLookup</tt>
                            - richiesto quando il caching a livello di JVM &egrave; abilitato in un contesto JTA.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">nomediclasse.del.TransactionManagerLookup</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.query.substitutions</tt></td><td>
                            Mappaggio da alcune etichette nelle query di Hibernate
                            a dei valori di sostituzione per le query SQL
                            (potrebbero essere funzioni o letterali, ad esempio).
                            <p>
                                <span class="strong">e.g.</span> 
                                <tt class="literal">hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.show_sql</tt></td><td>
                            Scrive tutte le istruzioni SQL sulla console.
                            <p>
                                <span class="strong">e.g.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.hbm2ddl.auto</tt></td><td>
                            Esporta automaticamente lo schema DDL sul database quando
                            viene creata la <tt class="literal">SessionFactory</tt>. Con
                            <tt class="literal">create-drop</tt>, lo schema di database 
                            verr&agrave; eliminato subito dopo che la <tt class="literal">SessionFactory</tt>
                            verr&agrave; chiusa esplicitamente.
                            <p>
                                <span class="strong">e.g.</span> 
                                <tt class="literal">update</tt> | <tt class="literal">create</tt> | <tt class="literal">create-drop</tt>
                            </p></td></tr></tbody></table></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-dialects"></a>3.5.1.&nbsp;Dialetti SQL</h3></div></div><div></div></div><p>
                Dovreste sempre impostare la propriet&agrave; <tt class="literal">hibernate.dialect</tt> al valore della
                sottoclasse di <tt class="literal">net.sf.hibernate.dialect.Dialect</tt> giusta per il vostro database.
                Questo non &egrave; strettamente necessario, a meno che desideriate usare la generazione di chiavi primaria
                <tt class="literal">native</tt> o <tt class="literal">sequence</tt> o il locking pessimistico (con, ad esempio,
                <tt class="literal">Session.lock()</tt> o <tt class="literal">Query.setLockMode()</tt>).
                Comunque, se specificate un dialetto, Hibernate imposter&agrave; dei default adatti per alcune delle
                propriet&agrave; elencate in precedenza, risparmiandovi lo sforzo di specificarle manualmente.
            </p><div class="table"><a name="d0e1395"></a><p class="title"><b>Tabella&nbsp;3.4.&nbsp;Dialetti SQL di HIbernate (<tt class="literal">hibernate.dialect</tt>)</b></p><table summary="Dialetti SQL di HIbernate (hibernate.dialect)" border="1"><colgroup><col><col></colgroup><thead><tr><th>RDBMS</th><th>Dialetto</th></tr></thead><tbody><tr><td>DB2</td><td><tt class="literal">net.sf.hibernate.dialect.DB2Dialect</tt></td></tr><tr><td>MySQL</td><td><tt class="literal">net.sf.hibernate.dialect.MySQLDialect</tt></td></tr><tr><td>SAP DB</td><td><tt class="literal">net.sf.hibernate.dialect.SAPDBDialect</tt></td></tr><tr><td>Oracle (any version)</td><td><tt class="literal">net.sf.hibernate.dialect.OracleDialect</tt></td></tr><tr><td>Oracle 9</td><td><tt class="literal">net.sf.hibernate.dialect.Oracle9Dialect</tt></td></tr><tr><td>Sybase</td><td><tt class="literal">net.sf.hibernate.dialect.SybaseDialect</tt></td></tr><tr><td>Sybase Anywhere</td><td><tt class="literal">net.sf.hibernate.dialect.SybaseAnywhereDialect</tt></td></tr><tr><td>Progress</td><td><tt class="literal">net.sf.hibernate.dialect.ProgressDialect</tt></td></tr><tr><td>Mckoi SQL</td><td><tt class="literal">net.sf.hibernate.dialect.MckoiDialect</tt></td></tr><tr><td>Interbase</td><td><tt class="literal">net.sf.hibernate.dialect.InterbaseDialect</tt></td></tr><tr><td>Pointbase</td><td><tt class="literal">net.sf.hibernate.dialect.PointbaseDialect</tt></td></tr><tr><td>PostgreSQL</td><td><tt class="literal">net.sf.hibernate.dialect.PostgreSQLDialect</tt></td></tr><tr><td>HypersonicSQL</td><td><tt class="literal">net.sf.hibernate.dialect.HSQLDialect</tt></td></tr><tr><td>Microsoft SQL Server</td><td><tt class="literal">net.sf.hibernate.dialect.SQLServerDialect</tt></td></tr><tr><td>Ingres</td><td><tt class="literal">net.sf.hibernate.dialect.IngresDialect</tt></td></tr><tr><td>Informix</td><td><tt class="literal">net.sf.hibernate.dialect.InformixDialect</tt></td></tr><tr><td>FrontBase</td><td><tt class="literal">net.sf.hibernate.dialect.FrontbaseDialect</tt></td></tr></tbody></table></div></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-outerjoin"></a>3.5.2.&nbsp;Reperimento via join esterno</h3></div></div><div></div></div><p>
                Se il vostro database supporta i join esterni ANSI o Oracle, il <span class="emphasis"><em>reperimento via 
                join esterno</em></span> pu&ograve; aumentare le performance limitando il numero di accessi
                al database (al costo di un lavoro maggiore probabilmente effettuato dal database stesso). 
                Il reperimento via join esterno consente ad un grafo di oggetti connessi da associazioni 
                molti-a-uno, uno-a-molti o uno-a-uno di essere caricati in una singola 
                <tt class="literal">SELECT</tt> SQL.
            </p><p>
                Per default, il grafo inizializzato quando si carica un oggetto termina agli
                oggetti foglia, alle collezioni, agli oggetti con mediatori (proxy) o dove 
                ci siano delle circolarit&agrave;.
            </p><p>
                Per una <span class="emphasis"><em>associazione particolare</em></span>, il caricamento pu&ograve; 
                essere abilitato o disabilitato (e quindi si pu&ograve; modificare il comportamento
                predefinito) impostando l'attributo <tt class="literal">outer-join</tt> nel mapping
                XML.
            </p><p>
                Il caricamento via join esterno pu&ograve; essere disabilitato <span class="emphasis"><em>globalmente</em></span> 
                impostando la propriet&agrave; <tt class="literal">hibernate.max_fetch_depth</tt> a <tt class="literal">0</tt>.
                Un settaggio di <tt class="literal">1</tt> o pi&ugrave; abilita il join esterno per tutte le associazioni
                uno-a-uno e molti-a-uno che sono, sempre come impostazione predefinita, impostate ad 
                <tt class="literal">auto</tt>. In ogni caso, le associazioni uno-a-molti e le collezioni non vengono
                mai caricate con un join esterno, a meno che questo non venga esplicitamente dichiarato per ogni
                particolare associazione. Anche questo comportamento pu&ograve; essere modificato a runtime con delle 
                query di Hibernate.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-binarystreams"></a>3.5.3.&nbsp;Flussi (stream) binari</h3></div></div><div></div></div><p>
                Oracle limita la dimensione degli array di <tt class="literal">byte</tt> che possono
                essere passati da o al suo driver JDBC. Se volete usare istanze di tipi <tt class="literal">binari</tt> o 
                <tt class="literal">serializzabili</tt> di grandi dimensioni, dovete abilitare 
                <tt class="literal">hibernate.jdbc.use_streams_for_binary</tt>.
                <span class="emphasis"><em>Questa impostazione viene settata esclusivamente a livello di JVM.</em></span>
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-cacheprovider"></a>3.5.4.&nbsp;<tt class="literal">CacheProvider</tt> personalizzati</h3></div></div><div></div></div><p>
                Potete integrare una cache di secondo livello che operi all'interno della virtual machine
                (JVM-level) o sull'intero cluster (clustered) implementando l'interfaccia
                <tt class="literal">net.sf.hibernate.cache.CacheProvider</tt>.
                Potete poi impostare l'implementazione personalizzata con l'opzione
                <tt class="literal">hibernate.cache.provider_class</tt>.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-transactionstrategy"></a>3.5.5.&nbsp;Configurazione della strategia transazionale</h3></div></div><div></div></div><p>
                Se volete usare l'API <tt class="literal">Transaction</tt> di Hibernate, dovete specificare
                una classe factory ("fabbricatore" di istanze) per gli oggetti <tt class="literal">Transaction</tt> 
                impostando la propriet&agrave; <tt class="literal">hibernate.transaction.factory_class</tt>.
                L'API <tt class="literal">Transaction</tt> maschera il meccanismo transazionale sottostante e consente
                al codice di Hibernate di eseguirsi in contesti gestiti dal container (managed) e non.
            </p><p>
                Ci sono due scelte possibili (pre-installate in Hibernate):
            </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">net.sf.hibernate.transaction.JDBCTransactionFactory</tt></span></dt><dd><p>delega al meccanismo transazionale JDBC transactions (impostazione predefinita)</p></dd><dt><span class="term"><tt class="literal">net.sf.hibernate.transaction.JTATransactionFactory</tt></span></dt><dd><p>delega a JTA (se esiste una transazione attiva, la <tt class="literal">Session</tt>
                        esegue il suo lavoro in quel contesto, altrimenti una nuova transazione viene attivata)</p></dd></dl></div><p>
                Potete anche definire le vostre strategie transazionali (per usare un servizio transazionale CORBA, ad esempio).
            </p><p>
                Se volete usare caching a livello di JVM per dati che siano modificabili in un contesto JTA,
                dovete specificare una strategia per ottenere il <tt class="literal">TransactionManager</tt> JTA, poich&eacute; 
                non esiste un metodo standardizzato nei container J2EE per farlo:
            </p><div class="table"><a name="d0e1628"></a><p class="title"><b>Tabella&nbsp;3.5.&nbsp;TransactionManager JTA</b></p><table summary="TransactionManager JTA" border="1"><colgroup><col><col></colgroup><thead><tr><th>Transaction Factory</th><th align="center">Application Server</th></tr></thead><tbody><tr><td><tt class="literal">net.sf.hibernate.transaction.JBossTransactionManagerLookup</tt></td><td align="center">JBoss</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.WeblogicTransactionManagerLookup</tt></td><td align="center">Weblogic</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.WebSphereTransactionManagerLookup</tt></td><td align="center">WebSphere</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.OrionTransactionManagerLookup</tt></td><td align="center">Orion</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.ResinTransactionManagerLookup</tt></td><td align="center">Resin</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.JOTMTransactionManagerLookup</tt></td><td align="center">JOTM</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.JOnASTransactionManagerLookup</tt></td><td align="center">JOnAS</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.JRun4TransactionManagerLookup</tt></td><td align="center">JRun4</td></tr></tbody></table></div></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-jndi"></a>3.5.6.&nbsp;<tt class="literal">SessionFactory</tt> pubblicata sul JNDI</h3></div></div><div></div></div><p>
                Una <tt class="literal">SessionFactory</tt> di Hibernate pubblicata sul JNDI pu&ograve; semplificare il reperimento
                della factory stessa, e la creazione di nuove <tt class="literal">Session</tt>i.
            </p><p>
                Se volete che la <tt class="literal">SessionFactory</tt> venga pubblicata su uno spazio di nomi JNDI, 
                specificate un nome (ad esempio. <tt class="literal">java:comp/env/hibernate/SessionFactory</tt>) 
                usando la propriet&agrave; <tt class="literal">hibernate.session_factory_name</tt>. Se questa propriet&agrave;
                viene omessa, la <tt class="literal">SessionFactory</tt> non verr&agrave; pubblicata sul JNDI. (Questo &egrave; 
                particolarmente utile in ambienti in cui l'implementazione standard del JNDI sia di sola lettura, 
                come ad esempio in Tomcat)
            </p><p>
                Quando Hibernate pubblicher&agrave; la <tt class="literal">SessionFactory</tt> sul JNDI, user&agrave; i valori di 
                <tt class="literal">hibernate.jndi.url</tt> e <tt class="literal">hibernate.jndi.class</tt> per istanziare
                il contesto iniziale JNDI (InitialContext). Se queste propriet&agrave; non vengono specificate, verr&agrave;
                usato l'<tt class="literal">InitialContext</tt> predefinito.
            </p><p>
                Se scegliete di usare il JNDI, un EJB o qualsiasi altra classe di utilit&agrave; pu&ograve; ottenere la
                <tt class="literal">SessionFactory</tt> con una ricerca (lookup) sull'albero JNDI.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-querysubstitution"></a>3.5.7.&nbsp;Sostituzioni per il linguaggio di interrogazione</h3></div></div><div></div></div><p>
                Potete definire nuove etichette per le interrogazioni di Hibernate usando la propriet&agrave;
                <tt class="literal">hibernate.query.substitutions</tt>.
                Ad esempio:
            </p><pre class="programlisting">hibernate.query.substitutions true=1, false=0</pre><p>
                farebbe s&igrave; che le etichette <tt class="literal">true</tt> e <tt class="literal">false</tt> venissero tradotti in 
                letterali interi nell'SQL generato.
            </p><pre class="programlisting">hibernate.query.substitutions toLowercase=LOWER</pre><p>
                permetterebbe di rinominare la funzione <tt class="literal">LOWER</tt> dell'SQL.
            </p></div></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-logging"></a>3.6.&nbsp;Traccia di esecuzione (logging)</h2></div></div><div></div></div><p>
            Hibernate traccia ("logs") vari eventi utilizzando la libreria commons-logging di Apache.
        </p><p>
            Il servizio di commons-logging indirizzer&agrave; l'uscita a Apache Log4j (se includete
            <tt class="literal">log4j.jar</tt> nel vostro classpath) o al logging nativo di
            JDK1.4 (se l'applicazione sta funzionando sotto JDK1.4 o superiori). Potete scaricare
            Log4j da <tt class="literal">http://jakarta.apache.org</tt>. Per usare Log4j avrete bisogno di
            un file <tt class="literal">log4j.properties</tt> sul classpath: un file di propriet&agrave; di esempio
            viene distribuito con Hibernate nella directory <tt class="literal">src/</tt>.
        </p><p>
            Raccomandiamo vivamente che vi familiarizziate con i messaggi di log di 
            Hibernate. &Egrave; stato fatto un grande sforzo per far s&igrave; che le tracce 
            lasciate da Hibernate siano il pi&ugrave; dettagliate possibile senza per questo
            renderle illeggibili. &Egrave; uno strumento di risoluzione dei problemi fondamentale.
            Non dimenticate anche di abilitare la traccia dell'SQL come descritto in precedenza
            (<tt class="literal">hibernate.show_sql</tt>), perch&eacute; &egrave; il primo passo quando si lavori
            alla risoluzione di problemi di performance.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-namingstrategy"></a>3.7.&nbsp;Implementazione di una strategia di denominazione (<tt class="literal">NamingStrategy</tt>)</h2></div></div><div></div></div><p>
            L'interfaccia <tt class="literal">net.sf.hibernate.cfg.NamingStrategy</tt> vi consente 
            di specificare uno "standard di denominazione" per gli oggetti del database e gli
            elementi dello schema.
        </p><p>
            Potete fornire regole per generare automaticamente identificatori di database 
            da identificatori java, o per ricavare nomi "fisici" di tabella e colonna dai
            nomi "logici" dati nel file di mappaggio. Questa funzionalit&agrave; consente di 
            ridurre la prolissit&agrave; del documento di mappaggio, eliminando il rumore 
            ripetitivo (come ad esempio i prefissi <tt class="literal">TBL_</tt>). La strategia
            base &egrave; abbastanza minimale.
        </p><p>
            Potete specificare una strategia differente chiamando <tt class="literal">Configuration.setNamingStrategy()</tt> 
            prima di aggiungere i mappaggi alla configurazione:
        </p><pre class="programlisting">SessionFactory sf = new Configuration()
    .setNamingStrategy(ImprovedNamingStrategy.INSTANCE)
    .addFile("Item.hbm.xml")
    .addFile("Bid.hbm.xml")
    .buildSessionFactory();</pre><p>
            <tt class="literal">net.sf.hibernate.cfg.ImprovedNamingStrategy</tt> &egrave; una strategia
            che viene distribuita con Hibernate e che potrebbe essere un punto di partenza
            utile per alcune applicazioni.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-xmlconfig"></a>3.8.&nbsp;File di configurazione XML</h2></div></div><div></div></div><p>
            Un approccio alternativo &egrave; specificare una configurazione completa in un file 
            chiamato <tt class="literal">hibernate.cfg.xml</tt>. Questo file pu&ograve; essere usato 
            come un'alternativa al file <tt class="literal">hibernate.properties</tt> o, se sono
            presenti entrambi, per ridefinirne le propriet&agrave;.
        </p><p>
            Il file di configurazione XML viene caricato da Hibernate dalla radice del 
            <tt class="literal">CLASSPATH</tt>. Ecco un esempio:
        </p><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 2.0//EN"

 "http://hibernate.sourceforge.net/hibernate-configuration-2.0.dtd"&gt;

&lt;hibernate-configuration&gt;

    &lt;!-- una istanza di SessionFactory indicata con il suo /nome/jndi --&gt;
    &lt;session-factory
        name="java:comp/env/hibernate/SessionFactory"&gt;

        &lt;!-- propriet&agrave; --&gt;
        &lt;property name="connection.datasource"&gt;my/first/datasource&lt;/property&gt;
        &lt;property name="dialect"&gt;net.sf.hibernate.dialect.MySQLDialect&lt;/property&gt;
        &lt;property name="show_sql"&gt;false&lt;/property&gt;
        &lt;property name="use_outer_join"&gt;true&lt;/property&gt;
        &lt;property name="transaction.factory_class"&gt;
            net.sf.hibernate.transaction.JTATransactionFactory
        &lt;/property&gt;
        &lt;property name="jta.UserTransaction"&gt;java:comp/UserTransaction&lt;/property&gt;

        &lt;!-- mapping files --&gt;
        &lt;mapping resource="org/hibernate/auction/Item.hbm.xml"/&gt;
        &lt;mapping resource="org/hibernate/auction/Bid.hbm.xml"/&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre><p>
           La configurazione di Hibernate richiede solo  di scrivere
       </p><pre class="programlisting">SessionFactory sf = new Configuration().configure().buildSessionFactory();</pre><p>
           &Egrave; comunque possibile specificare un differente file di configurazione XML usando
       </p><pre class="programlisting">SessionFactory sf = new Configuration()
    .configure("catdb.cfg.xml")
    .buildSessionFactory();</pre></div></div><div class="chapter" lang="it"><div class="titlepage"><div><div><h2 class="title"><a name="persistent-classes"></a>Capitolo&nbsp;4.&nbsp;Le classi persistenti</h2></div></div><div></div></div><p>
        Le classi persistenti sono quelle che in un'applicazione implementano le 
        entit&agrave; del problema di business (ad esempio Customer e Order in una applicazione
        di e-commerce). Le classi persistenti hanno, come implica il nome, istanze 
        transienti ed istanze persistenti memorizzate nel database.
    </p><p>
        Hibernate funziona meglio se queste classi seguono alcune semplici regole,
        conosciute anche come il modello di programmazione dei "cari vecchi oggetti 
        java" (in inglese e nel seguito si usa l'acronimo POJO che sta per 
        "Plain Old Java Object").
    </p><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-pojo"></a>4.1.&nbsp;Un semplice esempio POJO</h2></div></div><div></div></div><p>
            La maggior parte delle applicazioni java richiede una classe persistente che 
            rappresenti dei felini...
        </p><pre class="programlisting">package eg;
import java.util.Set;
import java.util.Date;

public class Cat {
    private Long id; // identificatore
    private String name;
    private Date birthdate;
    private Cat mate;
    private Set kittens
    private Color color;
    private char sex;
    private float weight;

    private void setId(Long id) {
        this.id=id;
    }
    public Long getId() {
        return id;
    }

    void setName(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }

    void setMate(Cat mate) {
        this.mate = mate;
    }
    public Cat getMate() {
        return mate;
    }

    void setBirthdate(Date date) {
        birthdate = date;
    }
    public Date getBirthdate() {
        return birthdate;
    }
    void setWeight(float weight) {
        this.weight = weight;
    }
    public float getWeight() {
        return weight;
    }

    public Color getColor() {
        return color;
    }
    void setColor(Color color) {
        this.color = color;
    }
    void setKittens(Set kittens) {
        this.kittens = kittens;
    }
    public Set getKittens() {
        return kittens;
    }
    // addKitten non &egrave; richiesto da Hibernate
    public void addKitten(Cat kitten) {
        kittens.add(kitten);
    }
    void setSex(char sex) {
        this.sex=sex;
    }
    public char getSex() {
        return sex;
    }
}</pre><p>
            Ci sono quattro regole principali da seguire, qui:
        </p><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-pojo-accessors"></a>4.1.1.&nbsp;Dichiarate metodi di accesso e di impostazione (get e set) per i campi persistenti</h3></div></div><div></div></div><p>
                <tt class="literal">Cat</tt> dichiara metodi di accesso per tutti i suoi campi persistenti.
                Molti altri strumenti di mappaggio OR rendono direttamente persistenti le variabili
                di istanza. Crediamo che sia molto meglio disaccoppiare questo dettaglio implementativo dal
                meccanismo di persistenza. Hibernate rende persistenti le propriet&agrave; nello stile dei JavaBeans, 
                e riconosce i nomi di metodo nella forma <tt class="literal">getFoo</tt>, <tt class="literal">isFoo</tt> e
                <tt class="literal">setFoo</tt>.
            </p><p>
                <span class="emphasis"><em>Non</em></span> &egrave; necessario che le propriet&agrave; siano dichiarate "public" - Hibernate
                pu&ograve; rendere persistenti propriet&agrave; con coppie di metodi get/ set a visibilit&agrave; default, 
                <tt class="literal">protected</tt> o <tt class="literal"> private</tt>.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-pojo-constructor"></a>4.1.2.&nbsp;Implementate un costruttore di default</h3></div></div><div></div></div><p>
                <tt class="literal">Cat</tt> ha un costruttore di default (senza argomenti) implicito. 
                Tutte le classi persistenti devono avere un costruttore di default (che pu&ograve; non 
                essere pubblico), in modo tale che Hibernate possa costruirle usando 
                <tt class="literal">Constructor.newInstance()</tt>.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-pojo-identifier"></a>4.1.3.&nbsp;Fornite una propriet&agrave; identificatore (opzionale)</h3></div></div><div></div></div><p>
                <tt class="literal">Cat</tt> ha una propriet&agrave; chiamata <tt class="literal">id</tt>. Questa
                propriet&agrave; contiene il valore della chiave primaria di una tabella di database. La
                propriet&agrave; avrebbe potuto essere chiamata in un modo qualunque, e il suo tipo poteva
                essere un qualsiasi tipo primitivo, un "incapsulatore" ("wrapper") di tipi primitivi,
                <tt class="literal">java.lang.String</tt> o <tt class="literal">java.util.Date</tt>. (Se 
                la vostra tabella di database preesistente ha chiavi composte, potete anche usare
                una classe definita da voi con le propriet&agrave; dei tipi delle colonne usate nella chiave - 
                leggete la sezione sugli identificatori composti pi&ugrave; avanti.)
            </p><p>
                La propriet&agrave; identificatore &egrave; opzionale. Potete farne a meno, e Hibernate
                terr&agrave; traccia internamente degli identificatori degli oggetti. In ogni caso,
                per molte applicazioni &egrave; comunque una buona (e molto popolare) decisione di 
                progetto.
            </p><p>
                In pi&ugrave;, alcune funzionalit&agrave; sono possibili solo per classi che dichiarano 
                una propriet&agrave; identificatore:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        Aggiornamenti a cascata (vedete "oggetti del ciclo di vita")
                    </p></li><li><p>
                        <tt class="literal">Session.saveOrUpdate()</tt>
                    </p></li></ul></div><p>
                Vi raccomandiamo di dichiarare propriet&agrave; identificatore con nomi coerenti per
                le classi persistenti, e che usiate un tipo annullabile (cio&egrave; non primitivo).
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-pojo-final"></a>4.1.4.&nbsp;Preferite classi non-final (opzionale)</h3></div></div><div></div></div><p>
                Una funzionalit&agrave; centrale di Hibernate, ovvero i <span class="emphasis"><em>mediatori</em></span>
                ("proxy" in inglese), dipende dal fatto che la classe persistente sia non-final
                o che sia l'implementazione di un'interfaccia che dichiara tutti i suoi metodi
                pubblici.
            </p><p>
                Potete rendere persistenti classi <tt class="literal">final</tt> che non implementino 
                un'interfaccia, con hibernate, ma non potrete usare i mediatori - cosa che limiter&agrave;
                in qualche modo le vostre opzioni per l'ottimizzazione delle prestazioni.
            </p></div></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-inheritance"></a>4.2.&nbsp;Utilizzo dell'ereditariet&agrave;</h2></div></div><div></div></div><p>
            Anche una sottoclasse deve osservare la prima e la seconda regola. Eredita 
            la sua propriet&agrave; di identificazione da <tt class="literal">Cat</tt>.
        </p><pre class="programlisting">package eg;

public class DomesticCat extends Cat {
        private String name;

        public String getName() {
                return name;
        }
        protected void setName(String name) {
                this.name=name;
        }
}</pre></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-equalshashcode"></a>4.3.&nbsp;Implementate <tt class="literal">equals()</tt> e <tt class="literal">hashCode()</tt></h2></div></div><div></div></div><p>
            Dovete sovrascrivere i metodi <tt class="literal">equals()</tt> e <tt class="literal">hashCode()</tt>
            se volete mischiare oggetti di classi persistenti (ad esempio in un <tt class="literal">Set</tt>).
        </p><p>
            <span class="emphasis"><em>Questo vale solo se questi oggetti vengono caricati in due 
            <tt class="literal">Session</tt>i differenti, poich&eacute; Hibernate garantisce l'uguaglianza degli oggetti
            (<tt class="literal"> a == b </tt>, l'implementazione di default di <tt class="literal">equals()</tt>) solo 
            all'interno di una singola <tt class="literal">Session</tt>!</em></span>
        </p><p>
            Anche se entrambi gli oggetti <tt class="literal">a</tt> e <tt class="literal">b</tt> sono la stessa riga di 
            database (hanno come identificatore lo stesso valore della chiave primaria), al di fuori del 
            contesto di una particolare <tt class="literal">Session</tt> non possiamo garantire che siano la stessa 
            istanza di oggetto Java.
        </p><p>
            La maniera pi&ugrave; ovvia &egrave; di implementare <tt class="literal">equals()</tt>/<tt class="literal">hashCode()</tt>
            confrontando il valore di identificazione di entrambi gli oggetti. Se il valore &egrave; lo stesso, 
            deve trattarsi della stessa riga di database, e quindi sono uguali (cio&egrave; se vengono entrambe
            aggiunte ad un <tt class="literal">Set</tt>, avremo solo un elemento al suo interno, dopo). 
            Sfortunatamente, non possiamo usare questo approccio. Hibernate assegna valori di 
            identificazione solo agli oggetti che sono persistenti, mentre una istanza appena creata non 
            avr&agrave; alcun valore di identificatore! Quello che consigliamo, &egrave; di implementare
            <tt class="literal">equals()</tt> e <tt class="literal">hashCode()</tt> usando un concetto di 
            <span class="emphasis"><em>chiave di uguaglianza di business</em></span>.
        </p><p>
            "Chiave di uguaglianza di business" significa che il metodo <tt class="literal">equals()</tt>
            confronta solo le propriet&agrave; che formano la chiave di business, una chiave che 
            identificherebbe la nostra istanza nel mondo reale (cio&egrave; una chiave candidata 
            <span class="emphasis"><em>naturale</em></span>):
        </p><pre class="programlisting">public class Cat {

    ...
    public boolean equals(Object other) {
        if (this == other) return true;
        if (!(other instanceof Cat)) return false;

        final Cat cat = (Cat) other;

        if (!getName().equals(cat.getName())) return false;
        if (!getBirthday().equals(cat.getBirthday())) return false;

        return true;
    }

    public int hashCode() {
        int result;
        result = getName().hashCode();
        result = 29 * result + getBirthday().hashCode();
        return result;
    }

}</pre><p>
            Ricordatevi che la nostra chiave candidata (in questo caso si tratta della 
            composizione di nome e data di nascita) deve essere valida solo per una particolare
            operazione di confronto (magari solo in un singolo caso d'uso). Non abbiamo bisogno
            dei parametri di stabilit&agrave; che solitamente si applicano ad una vera chiave primaria!
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-lifecycle"></a>4.4.&nbsp;Punti di richiamo del ciclo di vita degli oggetti ("lifecycle callbacks")</h2></div></div><div></div></div><p>
            Una classe persistente pu&ograve; implementare in via opzionale l'interfaccia
            <tt class="literal">Lifecycle</tt> che fornisce alcuni punti di aggancio che
            consentono all'oggetto persistente di effettuare operazioni di 
            inizializzazione/pulizia dopo un salvataggio o un caricamento, e prima
            di una cancellazione o un aggiornamento.
        </p><p>
            
            La classe <tt class="literal">Interceptor</tt> offre comunque una alternativa
            meno instrusiva, comunque.
        </p><div class="programlistingco"><pre class="programlisting">public interface Lifecycle {
        public boolean onSave(Session s) throws CallbackException;   <span class="co">(1)</span>
        public boolean onUpdate(Session s) throws CallbackException; <span class="co">(2)</span>
        public boolean onDelete(Session s) throws CallbackException; <span class="co">(3)</span>
        public void onLoad(Session s, Serializable id);              <span class="co">(4)</span>
}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">onSave</tt> - chiamato subito prima che l'oggetto 
                        venga salvato o inserito
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">onUpdate</tt> - chiamato subito prima che un oggetto
                        venga aggiornato (quando viene passato a <tt class="literal">Session.update()</tt>)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">onDelete</tt> - chiamato subito prima che un oggetto venga 
                        cancellato
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                        <tt class="literal">onLoad</tt> - chiamato subito dopo che un oggetto &egrave; caricatocalled just after an object is loaded
                    </p></td></tr></table></div></div><p>
            <tt class="literal">onSave()</tt>, <tt class="literal">onDelete()</tt> e
            <tt class="literal">onUpdate()</tt> possono essere usati per propagare
            salvataggi e cancellazioni degli oggetti dipendenti. &Egrave; un'alternativa 
            alla dichiarazione di operazioni di cascata nel file di mappaggio. 
            <tt class="literal">onLoad()</tt> pu&ograve; essere usato per inizializzare propriet&agrave; 
            dell'oggetto dal suo stato persistente. Non pu&ograve; essere usato per caricare
            oggetti dipendenti poich&eacute; l'interfaccia <tt class="literal">Session</tt> 
            non pu&ograve; venire chiamata dall'interno del metodo. L'utilizzo ulteriore di
            <tt class="literal">onLoad()</tt>, <tt class="literal">onSave()</tt> e 
            <tt class="literal">onUpdate()</tt> &egrave; per memorizzare un riferimento alla 
            <tt class="literal">Session</tt> corrente per utilizzi successivi.
        </p><p>
            Notate che <tt class="literal">onUpdate()</tt> non viene chiamato ogni volta
            che lo stato persistente dell'oggetto viene modificato, ma solo quando l'oggetto
            transiente viene passato a <tt class="literal">Session.update()</tt>.
        </p><p>
            Se <tt class="literal">onSave()</tt>, <tt class="literal">onUpdate()</tt> o
            <tt class="literal">onDelete()</tt> restituiscono <tt class="literal">true</tt>, l'operazione
            viene silenziosamente impedita. Se viene lanciata una <tt class="literal">CallbackException</tt>, 
            l'operazione &egrave; proibita e l'eccezione viene restituita all'applicazione.
        </p><p>
            Notate che <tt class="literal">onSave()</tt> viene chiamata dopo che un identificatore sia
            assegnato all'oggetto, eccetto quando viene usata la strategia di generazione di chiavi 
            nativa.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-validatable"></a>4.5.&nbsp;Punto di aggancio (callback) Validatable</h2></div></div><div></div></div><p>
            Se la classe persistente ha bisogno di controllare degli invarianti
            prima che il suo stato sia reso persistente, pu&ograve; implementare 
            l'interfaccia seguente:
        </p><pre class="programlisting">public interface Validatable {
        public void validate() throws ValidationFailure;
}</pre><p>
            L'oggetto dovrebbe lanciare una <tt class="literal">ValidationFailure</tt> se 
            &egrave; stato violato qualche invariante. Un'istanza di <tt class="literal">Validatable</tt> 
            non dovrebbe per&ograve; cambiare il suo stato, dall'interno di <tt class="literal">validate()</tt>.
        </p><p>
            A differenza dei metodi di richiamo dell'interfaccia <tt class="literal">Lifecycle</tt>, 
            <tt class="literal">validate()</tt> potrebbe venire chiamata in momenti imprevisti. 
            L'applicazione non dovrebbe affidarsi alle chiamate a <tt class="literal">validate()</tt> 
            per implementare funzionalit&agrave; di business.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-xdoclet"></a>4.6.&nbsp;Utilizzo del contrassegno (markup) di XDoclet</h2></div></div><div></div></div><p>
            Nel prossimo capitolo mostreremo come i mappaggi di Hibernate possano venire
            espressi usando un formato XML semplice e leggibile. Molti utenti di Hibernate
            preferiscono inserire l'informazione di mappaggio direttamente nel codice 
            sorgente usando gli <tt class="literal">@hibernate.tags</tt> di XDoclet.
            Non parleremo qui di questo approccio poich&eacute; viene considerato strettamente parte
            di XDoclet. Tuttavia includiamo l'esempio seguente della classe <tt class="literal">Cat</tt>
            con i mappaggi di XDoclet.
        </p><pre class="programlisting">package eg;
import java.util.Set;
import java.util.Date;

/**
 * @hibernate.class
 *  table="CATS"
 */
public class Cat {
    private Long id; // identifier
    private Date birthdate;
    private Cat mate;
    private Set kittens
    private Color color;
    private char sex;
    private float weight;

    /**
     * @hibernate.id
     *  generator-class="native"
     *  column="CAT_ID"
     */
    public Long getId() {
        return id;
    }
    private void setId(Long id) {
        this.id=id;
    }

    /**
     * @hibernate.many-to-one
     *  column="MATE_ID"
     */
    public Cat getMate() {
        return mate;
    }
    void setMate(Cat mate) {
        this.mate = mate;
    }

    /**
     * @hibernate.property
     *  column="BIRTH_DATE"
     */
    public Date getBirthdate() {
        return birthdate;
    }
    void setBirthdate(Date date) {
        birthdate = date;
    }
    /**
     * @hibernate.property
     *  column="WEIGHT"
     */
    public float getWeight() {
        return weight;
    }
    void setWeight(float weight) {
        this.weight = weight;
    }

    /**
     * @hibernate.property
     *  column="COLOR"
     *  not-null="true"
     */
    public Color getColor() {
        return color;
    }
    void setColor(Color color) {
        this.color = color;
    }
    /**
     * @hibernate.set
     *  lazy="true"
     *  order-by="BIRTH_DATE"
     * @hibernate.collection-key
     *  column="PARENT_ID"
     * @hibernate.collection-one-to-many
     */
    public Set getKittens() {
        return kittens;
    }
    void setKittens(Set kittens) {
        this.kittens = kittens;
    }
    // addKitten not needed by Hibernate
    public void addKitten(Cat kitten) {
        kittens.add(kitten);
    }

    /**
     * @hibernate.property
     *  column="SEX"
     *  not-null="true"
     *  update="false"
     */
    public char getSex() {
        return sex;
    }
    void setSex(char sex) {
        this.sex=sex;
    }
}</pre></div></div><div class="chapter" lang="it"><div class="titlepage"><div><div><h2 class="title"><a name="mapping"></a>Capitolo&nbsp;5.&nbsp;Mappaggio O/R di base</h2></div></div><div></div></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-declaration"></a>5.1.&nbsp;Dichiarazione dei mappaggi</h2></div></div><div></div></div><p>
            I mappaggi oggetto/relazione vengono definiti in un documento XML. Il documento di 
            mappaggio &egrave; progettato per essere leggibile e modificabile a mano. Il linguaggio di 
            mappaggio &egrave; java-centrico, nel senso che i mappaggi sono costruiti intorno alle 
            dichiarazioni delle classi persistenti, non sulle dichiarazioni delle tabelle.
        </p><p>
            Notate che anche se molti utenti di Hibernate scelgono di definire i mappaggi XML 
            a mano, esistono un certo numero di strumenti per generare il documento di mappaggio,
            tra cui XDoclet, Middlegen e AndroMDA.
        </p><p>
            Ora cominciamo con un mappaggio di esempio:
        </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 2.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

        &lt;class name="Cat" table="CATS" discriminator-value="C"&gt;
                &lt;id name="id" column="uid" type="long"&gt;
                        &lt;generator class="hilo"/&gt;
                &lt;/id&gt;
                &lt;discriminator column="subclass" type="character"/&gt;
                &lt;property name="birthdate" type="date"/&gt;
                &lt;property name="color" not-null="true"/&gt;
                &lt;property name="sex" not-null="true" update="false"/&gt;
                &lt;property name="weight"/&gt;
                &lt;many-to-one name="mate" column="mate_id"/&gt;
                &lt;set name="kittens"&gt;
                        &lt;key column="mother_id"/&gt;
                        &lt;one-to-many class="Cat"/&gt;
                &lt;/set&gt;
                &lt;subclass name="DomesticCat" discriminator-value="D"&gt;
                        &lt;property name="name" type="string"/&gt;
                &lt;/subclass&gt;
        &lt;/class&gt;

        &lt;class name="Dog"&gt;
                &lt;!-- qui potrebbe stare il mappaggio per Dog --&gt;
        &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
             Ora discuteremo il contenuto del documento di mappaggio. Descriveremo solo gli elementi
             e gli attributi del documento che Hibernate usa in fase di esecuzione. Il documento di 
             mappaggio contiene anche alcuni elementi ed attributi opzionali che hanno effetto sugli 
             schemi del database exportati dallo strumento di generazione dello schema (schemaexport). 
             (Ad esempio l'attributo <tt class="literal">not-null</tt>.)
        </p><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-doctype"></a>5.1.1.&nbsp;Doctype</h3></div></div><div></div></div><p>
                Tutti i mappaggi XML dovrebbero dichiarare il che abbiamo mostrato nell'esempio.
                L'effettivo DTD pu&ograve; essere trovato all'URL indicato, nella directory 
                <tt class="literal">hibernate-x.x.x/src/net/sf/hibernate</tt> del pacchetto di 
                Hibernate o nel file <tt class="literal">hibernate.jar</tt>. Hibernate cercher&agrave; sempre 
                per prima cosa il DTD sul classpath.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-mapping"></a>5.1.2.&nbsp;hibernate-mapping</h3></div></div><div></div></div><p>
                Questo elemento ha tre attributi opzionali. L'attributo <tt class="literal">schema</tt> 
                specifica che le tabelle a cui si fa riferimento nel mappaggio appartengono allo schema
                indicato. Se viene usato, i nomi delle tabelle saranno completati dal nome dello schema
                inidicato. Se manca, i nomi delle tabelle non saranno ulteriormente caratterizzati. 
                L'attributo <tt class="literal">default-cascade</tt> specifica quale stile di cascata dovrebbe
                essere assunto per le propriet&agrave; e le collezioni che non specificano un attributo 
                <tt class="literal">cascade</tt> attribute. L'attributo <tt class="literal">auto-import</tt> ci 
                consente di utilizzare nomi di classe non qualificati nel linguaggio di interrogazione
                come comportamento predefinito.
            </p><div class="programlistingco"><pre class="programlisting">&lt;hibernate-mapping
         schema="schemaName"                          <span class="co">(1)</span>
         default-cascade="none|save-update"           <span class="co">(2)</span>
         auto-import="true|false"                     <span class="co">(3)</span>
         package="package.name"                       <span class="co">(4)</span>
 /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                             <tt class="literal">schema</tt> (opzionale): Il nome di uno schema del database.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                             <tt class="literal">default-cascade</tt> (opzionale - il default &egrave; <tt class="literal">none</tt>): 
                             Uno stile di cascata predefinito.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                             <tt class="literal">auto-import</tt> (opzionale - il default &egrave; <tt class="literal">true</tt>):
                             Specifica se possiamo usare nomi di classe non qualificati (le classi devono essere di 
                             questo mappaggio) nel linguaggio di interrogazione.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                             <tt class="literal">package</tt> (opzionale): Specifica un prefisso di package da assumere per
                             i nomi di classi non qualificati nel documento di mappaggio.
                         </p></td></tr></table></div></div><p>
                 Se avete due classi persistenti con lo stesso nome (non qualificato), dovreste impostare
                 <tt class="literal">auto-import="false"</tt>. Hibernate lancer&agrave; un'eccezione se tentate di assegnare
                 due classi diversse allo stesso nome "importato".
             </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-class"></a>5.1.3.&nbsp;class</h3></div></div><div></div></div><p>
                L'elemento <tt class="literal">class</tt> si usa per dichiarare una classe persistente:
            </p><div class="programlistingco"><pre class="programlisting">&lt;class
        name="ClassName"                              <span class="co">(1)</span>
        table="tableName"                             <span class="co">(2)</span>
        discriminator-value="discriminator_value"     <span class="co">(3)</span>
        mutable="true|false"                          <span class="co">(4)</span>
        schema="owner"                                <span class="co">(5)</span>
        proxy="ProxyInterface"                        <span class="co">(6)</span>
        dynamic-update="true|false"                   <span class="co">(7)</span>
        dynamic-insert="true|false"                   <span class="co">(8)</span>
        select-before-update="true|false"             <span class="co">(9)</span>
        polymorphism="implicit|explicit"              <span class="co">(10)</span>
        where="arbitrary sql where condition"         <span class="co">(11)</span>
        persister="PersisterClass"                    <span class="co">(12)</span>
        batch-size="N"                                <span class="co">(13)</span>
        optimistic-lock="none|version|dirty|all"      <span class="co">(14)</span>
        lazy="true|false"                             <span class="co">(15)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: il nome di classe java completamente qualificato della classe persistente
                            (o l'interfaccia).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">table</tt>: il nome della sua tabella di database.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">discriminator-value</tt> (opzionale - il default &egrave; il nome della classe): un 
                            valore che distingue sottoclassi individuali, usato per il comportamento polimorfico. 
                            I valori accettabili includono <tt class="literal">null</tt> e <tt class="literal">not null</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">mutable</tt> (opzionale, il default &egrave; <tt class="literal">true</tt>): specifica
                            che le istanze della classe (non) sono mutabili.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">schema</tt> (opzionale): sovrascrive il nome dello schema specificato 
                            dall'elemento radice <tt class="literal">&lt;hibernate-mapping&gt;</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">proxy</tt> (opzionale): specifica una interfaccia da usare per i 
                            mediatori (proxy) ad inizializzazione ritardata. Potete specificare il nome 
                            della classe stessa.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">dynamic-update</tt> (opzionale, il default &egrave; <tt class="literal">false</tt>): 
                            specifica che una <tt class="literal">UPDATE</tt> SQL dovrebbe venire generata in fase di 
                            esecuzione e contenere solo i nomi delle colonne di cui sono cambiati i valori.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">dynamic-insert</tt> (opzionale, il default &egrave; <tt class="literal">false</tt>): 
                            specifica che le <tt class="literal">INSERT</tt> SQL dovrebbero venire generate in fase di 
                            esecuzione e contenere solo i nomi delle colonne i cui valori sono non nulli.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                            <tt class="literal">select-before-update</tt> (opzionale, il default &egrave; <tt class="literal">false</tt>): 
                            specifica che Hibernate non dovrebbe <span class="emphasis"><em>mai</em></span> eseguire una <tt class="literal">UPDATE</tt> 
                            a meno che non sia certo che un oggetto non sia davvero stato modificato. In certi casi
                            (in realt&agrave; solo quando un oggetto transiente sia stato associato ad una nuova sessione usando
                            <tt class="literal">update()</tt>), questo significa che Hibernate effettuer&agrave; una istruzione SQL 
                            <tt class="literal">SELECT</tt> in pi&ugrave; per determinare se <tt class="literal">UPDATE</tt> sia realmente 
                            richiesto.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                            <tt class="literal">polymorphism</tt> (opzionale, il default &egrave; <tt class="literal">implicit</tt>): 
                            determina se deve essere usato un polimorfismo di interrogazione implicito o esplicito.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(11)</td><td valign="top" align="left"><p>
                            <tt class="literal">where</tt> (opzionale) specifica una condizione <tt class="literal">WHERE</tt> 
                            dell'SQL arbitraria da usare quando si recuperano oggetti di questa classe
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(12)</td><td valign="top" align="left"><p>
                            <tt class="literal">persister</tt> (opzionale): specifica un <tt class="literal">ClassPersister</tt> personalizzato.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(13)</td><td valign="top" align="left"><p>
                            <tt class="literal">batch-size</tt> (opzionale, il default &egrave; <tt class="literal">1</tt>) specifica una "dimensione
                            di blocco" (batch) per il caricamento di istanze di questa classe per identificatore.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(14)</td><td valign="top" align="left"><p>
                            <tt class="literal">optimistic-lock</tt> (opzionale, il default &egrave; <tt class="literal">version</tt>): 
                            Determina la strategia di locking ottimistico.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(15)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (opzionale): impostare <tt class="literal">lazy="true"</tt> &egrave; una scorciatoia
                            equivalente a specificare il nome stesso della classe come interfaccia
                            <tt class="literal">proxy</tt>.
                        </p></td></tr></table></div></div><p>
                &Egrave; perfettamente accettabile che il nome della classe persistente sia un'interfaccia. In questo
                caso si dichiarano le classi di implementazione di quell'interfaccia utilizzando l'elemento
                <tt class="literal">&lt;subclass&gt;</tt>. Potete persistere anche classi interne
                <span class="emphasis"><em>static</em></span>. In questo caso dovete specificare il nome della classe usando la forma
                standard , cio&egrave; <tt class="literal">eg.Foo$Bar</tt>.
            </p><p>
                Le classi immutabili, <tt class="literal">mutable="false"</tt> non possono essere aggiornate o cancellate
                dall'applicazione. Questo consente ad Hibernate di effettuare alcune ottimizzazioni di performance
                minori.
            </p><p>
                L'attributo <tt class="literal">proxy</tt> opzionale consente l'inizializzazione ritardata delle
                istanze persistenti della classe. Hibernate inizialmente restituir&agrave; dei mediatori (proxy) CGLIB che
                implementano l'interfaccia indicata. Il vero oggetto persistente sar&agrave; caricato quando si 
                invocher&agrave; un metodo del mediatore. Leggete pi&ugrave; oltre il paragrafo "Mediatori per l'inizializzazione
                ritardata".
            </p><p>
                Il polimorfismo <span class="emphasis"><em>implicito</em></span> significa che interrogazioni che indicheranno i nomi 
                di una qualsiasi superclasse o interfaccia implementata da una classe potranno restituire istanze di
                quella classe stessa, e che una query che indichi il nome della classe stessa potr&agrave; restituire anche
                istanze di una qualsiasi sottoclasse. 
                Il polimorfismo <span class="emphasis"><em>Explicit</em></span> significa che le istanze di una classe verranno 
                restituite esclusivamente da interrogazioni che indichino esplicitamente il nome di quella classe, 
                e che interrogazioni che indichino il nome di quella classe restituiranno esclusivamente nomi di 
                sottoclassi mappati all'interno di questa dichiarazione <tt class="literal">&lt;class&gt;</tt> come
                <tt class="literal">&lt;subclass&gt;</tt> o <tt class="literal">&lt;joined-subclass&gt;</tt>. Per la maggior
                parte degli scopi, l'impostazione predefinita, ovvero <tt class="literal">polymorphism="implicit"</tt>, 
                &egrave; appropriata. Il polimorfismo esplicito &egrave; utile quando due classi diverse vengano
                mappate sulla stessa tabella (questo consente di avere una classe "leggera" che contiene un 
                sottoinsieme delle colonne della tabella).
            </p><p>
                L'attributo <tt class="literal">persister</tt> vi consente di personalizzare la strategia di persistenza
                utilizzata per la classe. potete, ad esempio, specificare la vostra sottoclasse di 
                <tt class="literal">net.sf.hibernate.persister.EntityPersister</tt> o potete addiritura fornire una 
                implementazione completamente diversa dell'interfaccia 
                <tt class="literal">net.sf.hibernate.persister.ClassPersister</tt> che implementi la persistenza via, 
                ad esempio, chiamate a procedure memorizzate (stored procedure), serializzazione su file piatti 
                o LDAP. Andate a vedere il codice di <tt class="literal">net.sf.hibernate.test.CustomPersister</tt> per 
                un esempio semplice (di "persistenza" su una <tt class="literal">Hashtable</tt>).
            </p><p>
                Notate che le impostazioni <tt class="literal">dynamic-update</tt> e <tt class="literal">dynamic-insert</tt>
                non vengono ereditate dalle sottoclassi, e quindi potrebbero venire anche specificate sugli elementi
                <tt class="literal">&lt;subclass&gt;</tt> o <tt class="literal">&lt;joined-subclass&gt;</tt>. Queste impostazioni
                possono aumentare le performance, in certi casi, ma potrebbero in realt&agrave; diminuire le performance in 
                altri. Usatele con giudizio.
            </p><p>
                L'uso di <tt class="literal">select-before-update</tt> di solito diminuir&agrave; le performance. &Egrave; molto 
                utile per&ograve; per evitare che dei trigger sul database associati all'update vengano chiamati 
                inutilmente.
            </p><p>
            	Se abilitate <tt class="literal">dynamic-update</tt>, avrete una scelta fra strategie di locking
            	ottimistico:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
            			<tt class="literal">version</tt> controlla le colonne di versione/marca di tempo
            		</p></li><li><p>
            			<tt class="literal">all</tt> controlla tutte le colonne
            		</p></li><li><p>
            			<tt class="literal">dirty</tt> controlla le colonne cambiate
            		</p></li><li><p>
            			<tt class="literal">none</tt> non usa il locking ottimistico
            		</p></li></ul></div><p>
            	Raccomandiamo <span class="emphasis"><em>molto</em></span> che usiate le colonne di versione/marca di tempo
            	per il locking ottimistico con Hibernate. Si tratta della strategia ottimale rispetto alle 
            	performance, ed &egrave; la sola strategia che gestisca correttamente le modifiche fatte al di 
            	fuori della sessione, (ad esempio quando venga usato <tt class="literal">Session.update()</tt>).
            	Ricordatevi che una propriet&agrave; di versione o marca di tempo non dovrebbe mai essere nulla, 
            	indipendentemente da quale sia la strategia <tt class="literal">unsaved-value</tt>, o un'istanza
            	verr&agrave; individuata come transiente.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-id"></a>5.1.4.&nbsp;id</h3></div></div><div></div></div><p>
                Le classi mappate <span class="emphasis"><em>devono</em></span> dichiarare la colonna di chiave primaria della
                tabella sul database. La maggior parte delle classi avr&agrave; anche una propriet&agrave; nello stile dei
                javabean (cio&egrave; con metodi "getter" e "setter") che manterr&agrave; l'identificatore unico di
                un'istanza. L'elemento <tt class="literal">&lt;id&gt;</tt> definisce il mappaggio da quella 
                propriet&agrave; alla colonna di chiave primaria.
            </p><div class="programlistingco"><pre class="programlisting">&lt;id
        name="propertyName"                      <span class="co">(1)</span>
        type="typename"                          <span class="co">(2)</span>
        column="column_name"                     <span class="co">(3)</span>
        unsaved-value="any|none|null|id_value"   <span class="co">(4)</span>
        access="field|property|ClassName"&gt;       <span class="co">(5)</span>

        &lt;generator class="generatorClass"/&gt;
&lt;/id&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> (opzionale): il nome della propriet&agrave; identificatore.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (opzionale): un nome che indica il tipo di Hibernate.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (opzionale - il default &egrave; il nome della propriet&agrave;): il
                            nome della colonna di chiave primaria.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">unsaved-value</tt> (opzionale - il default &egrave; <tt class="literal">null</tt>): 
                            un valore di propriet&agrave; di identificazione che indichi che un'istanza &egrave; appena
                            stata istanziata (&egrave; "unsaved"), distinguendola da istanze transienti che siano state
                            salvate o caricate in una sessione precedente.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (opzionale - il default &egrave; <tt class="literal">property</tt>): la
                            strategia che Hibernate dovrebbe usare per accedere al valore della propriet&agrave;.
                        </p></td></tr></table></div></div><p>
                Se l'attributo <tt class="literal">name</tt> manca, si assume che la classe non abbia propriet&agrave; identificatore.
            </p><p>
                L'attributo <tt class="literal">unsaved-value</tt> &egrave; importante! Se la propriet&agrave; identificatore della
                vostra classe non ha <tt class="literal">null</tt> come valore iniziale, allora dovreste specificare il 
                valore.
            </p><p>
                C'&egrave; una dichiarazione alternativa, <tt class="literal">&lt;composite-id&gt;</tt>, per consentire accesso
                a dati preesistenti con chiavi composite. Scoraggiamo fortemente il suo uso per qualsiasi altro motivo.
            </p><div class="sect3" lang="it"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-generator"></a>5.1.4.1.&nbsp;generator</h4></div></div><div></div></div><p>
                    L'elemento figlio obbligatorio <tt class="literal">&lt;generator&gt;</tt> indica una classe Java utilizzata
                    per generare identificatori unici per istanze di questa classe persistente. Se l'istanza del generatore
                    richiedesse di essere configurata o inizializzata con dei parametri, questi possono essere passati 
                    usando l'elemento <tt class="literal">&lt;param&gt;</tt>.
                </p><pre class="programlisting">&lt;id name="id" type="long" column="uid" unsaved-value="0"&gt;
        &lt;generator class="net.sf.hibernate.id.TableHiLoGenerator"&gt;
                &lt;param name="table"&gt;uid_table&lt;/param&gt;
                &lt;param name="column"&gt;next_hi_value_column&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><p>
                    Tutti i generatori implementano l'interfaccia <tt class="literal">net.sf.hibernate.id.IdentifierGenerator</tt>.
                    &Egrave; un'interfaccia molto semplice; alcune applicazioni potrebbero scegliere di fornire le loro 
                    implementazioni specializzate. In ogni caso, Hibernate fornisce un certo numero di implementazioni
                    preinstallate. Ci sono anche dei nomi abbreviati per i generatori preinstallati:

                    </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">increment</tt></span></dt><dd><p>
                                genera identificatori di tipo <tt class="literal">long</tt>, <tt class="literal">short</tt> o
                                <tt class="literal">int</tt> che sono unici solo quando nessun altro processo inserisce
                                dati nella stessa tabella.
                                <span class="emphasis"><em>Da non usare in un cluster.</em></span>
                            </p></dd><dt><span class="term"><tt class="literal">identity</tt></span></dt><dd><p>
                                supporta le colonne "identity" in DB2, MySQL, MS SQL Server, Sybase e
                                HypersonicSQL. L'identificatore restituito &egrave; di tipo <tt class="literal">long</tt>,
                                <tt class="literal">short</tt> o <tt class="literal">int</tt>.
                            </p></dd><dt><span class="term"><tt class="literal">sequence</tt></span></dt><dd><p>
                                usa una "sequence" in DB2, PostgreSQL, Oracle, SAP DB, McKoi o un generatore
                                in Interbase. L'identificatore restituito &egrave; di tipo <tt class="literal">long</tt>,
                                <tt class="literal">short</tt> o <tt class="literal">int</tt>.
                            </p></dd><dt><span class="term"><tt class="literal">hilo</tt></span></dt><dd><p>
                                usa un algoritmo hi/lo per generare efficientemente identificatori di tipo 
                                <tt class="literal">long</tt>, <tt class="literal">short</tt> o <tt class="literal">int</tt>,
                                date una tabella e una colonna (per default <tt class="literal">hibernate_unique_key</tt> e
                                <tt class="literal">next</tt> rispettivamente) come sorgente di valori "hi". L'algoritmo hi/lo
                                genera identificatori che sono unici solo per un particolare database. <span class="emphasis"><em>Non
                                usate questo generatore con connessioni iscritte con JTA o con una connessione fornita 
                                da voi stessi.</em></span>
                            </p></dd><dt><span class="term"><tt class="literal">seqhilo</tt></span></dt><dd><p>
                                usa un algoritmo hi/lo per generare efficientemente identificatori di tipo 
                                <tt class="literal">long</tt>, <tt class="literal">short</tt> o <tt class="literal">int</tt>,
                                dato il nome di una sequenza sul database.
                            </p></dd><dt><span class="term"><tt class="literal">uuid.hex</tt></span></dt><dd><p>
                                usa un algoritmo UUID a 128-bit per generare identificatori di tipo stringa,
                                unici all'interno di una rete (viene usato l'indirizzo IP). L'UUID &egrave; codificato
                                come una stringa di 32 caratteri esadecimali.
                            </p></dd><dt><span class="term"><tt class="literal">uuid.string</tt></span></dt><dd><p>
                                usa lo stesso algoritmo UUID. L'UUID &egrave; codificato come una stringa di lunghezza
                                16 che consiste di (qualsiasi) carattere ASCII. <span class="emphasis"><em>Non usare con PostgreSQL.</em></span>
                            </p></dd><dt><span class="term"><tt class="literal">native</tt></span></dt><dd><p>
                                usa <tt class="literal">identity</tt>, <tt class="literal">sequence</tt> o
                                <tt class="literal">hilo</tt> a seconda delle capacit&agrave; del database 
                                sottostante.
                            </p></dd><dt><span class="term"><tt class="literal">assigned</tt></span></dt><dd><p>
                                lascia all'applicazione il compito di assegnare un identificatore
                                all'oggetto prima che venga chiamato <tt class="literal">save()</tt>.
                            </p></dd><dt><span class="term"><tt class="literal">foreign</tt></span></dt><dd><p>
                                usa l'identificatore di un altro oggetto associato. Solitamente &egrave; usato 
                                insieme a una associazione di chiave primaria <tt class="literal">&lt;one-to-one&gt;</tt>.
                            </p></dd></dl></div><p>

                </p></div><div class="sect3" lang="it"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-hilo"></a>5.1.4.2.&nbsp;Algoritmo Hi/Lo</h4></div></div><div></div></div><p>
                    I generatori <tt class="literal">hilo</tt> e <tt class="literal">seqhilo</tt> forniscono due implementazioni
                    alternative dell'algoritmo hi/lo, un approccio importante per la generazione di identificatori. 
                    La prima implementazione richiede una tabella "speciale" del database per mantenere il prossimo
                    valore "hi" disponibile. La seconda usa una "sequence" nello stile di Oracle (dove sia supportata).
                </p><pre class="programlisting">&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="hilo"&gt;
                &lt;param name="table"&gt;hi_value&lt;/param&gt;
                &lt;param name="column"&gt;next_value&lt;/param&gt;
                &lt;param name="max_lo"&gt;100&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><pre class="programlisting">&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="seqhilo"&gt;
                &lt;param name="sequence"&gt;hi_value&lt;/param&gt;
                &lt;param name="max_lo"&gt;100&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><p>
                    Sfortunatamente non &egrave; possibile usare <tt class="literal">hilo</tt> quando fornite le vostre
                    <tt class="literal">Connection</tt> a Hibernate, o quando Hibernate sta usando il datasource
                    di un application server per ottenere connessioni iscritte con il JTA. Hibernate deve
                    essere in grado di raccogliere il valore "hi" in una nuova transazione. Un approccio
                    standard in un ambiente EJB &egrave; di implementare l'algoritmo hi/lo usando un session bean
                    senza stato.
                </p></div><div class="sect3" lang="it"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-uuid"></a>5.1.4.3.&nbsp;Algoritmo UUID</h4></div></div><div></div></div><p>
                    Gli UUIDs contengono: indirizzo IP, tempo di partenza della JVM (accurato al quarto di
                    secondo), il tempo di sistema e il valore di un contatore (unico all'interno della JVM). 
                    Non &egrave; possibile ottenere un indirizzo MAC o un indirizzo di memoria da del codice java, 
                    quindi questo &egrave; il massimo che possiamo fare senza usare JNI.
                </p><p>
                    Non tentate di usare <tt class="literal">uuid.string</tt> in PostgreSQL.
                </p></div><div class="sect3" lang="it"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-sequences"></a>5.1.4.4.&nbsp;Colonne "Identity" e "Sequence"</h4></div></div><div></div></div><p>
                    Per i database che supportano le colonne "identity" (DB2, MySQL, Sybase, MS SQL),
                    potete usare la generazione di chiave <tt class="literal">identity</tt>. Per i database
                    che supportano le sequenze (DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB) potete 
                    usare la generazione di chiave nello stile <tt class="literal">sequence</tt>. 
                    Entrambe queste strategie richiedono due istruzioni SQL per inserire un nuovo oggetto.
                </p><pre class="programlisting">&lt;id name="id" type="long" column="uid"&gt;
        &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;uid_sequence&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><pre class="programlisting">&lt;id name="id" type="long" column="uid" unsaved-value="0"&gt;
        &lt;generator class="identity"/&gt;
&lt;/id&gt;</pre><p>
                    Per lo sviluppo cross-piattaforma, la strategia <tt class="literal">native</tt> sceglier&agrave; dalle
                    strategie<tt class="literal">identity</tt>, <tt class="literal">sequence</tt> e
                    <tt class="literal">hilo</tt>, in maniera dipendente dalle capacit&agrave; del database sottostante.
                </p></div><div class="sect3" lang="it"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-assigned"></a>5.1.4.5.&nbsp;Identificatori assegnati</h4></div></div><div></div></div><p>
                    Se volete che sia l'applicazione ad assegnare gli identificatori (rispetto ad una
                    situazione in cui &egrave; Hibernate che li genera), potete usare il generatore 
                    <tt class="literal">assigned</tt>. Questo generatore speciale user&agrave; il valore di identificatore
                    gi&agrave; assegnato alla propriet&agrave; di identificazione dell'oeggetto. State molto attenti quando
                    usate questa funzionalit&agrave; a non assegnare chiavi con significato di business (quasi sempre 
                    una terribile decisione di design).
                </p><p>
                    A causa della sua natura implicita, le entit&agrave; che usano questo generatore non possono essere
                    salvate usando il metodo saveOrUpdate() della Session. Invece dovete specificare esplicitamente
                    ad Hibernate se l'oggetto dovrebbe essere salvato o aggiornato chiamando o il metodo 
                    <tt class="literal">save()</tt> o il metodo <tt class="literal">update()</tt> della Session.
                </p></div></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-compositeid"></a>5.1.5.&nbsp;composite-id</h3></div></div><div></div></div><pre class="programlisting">&lt;composite-id
        name="propertyName"
        class="ClassName"
        unsaved-value="any|none"
        access="field|property|ClassName"&gt;

        &lt;key-property name="propertyName" type="typename" column="column_name"/&gt;
        &lt;key-many-to-one name="propertyName class="ClassName" column="column_name"/&gt;
        ......
&lt;/composite-id&gt;</pre><p>
                Per una tabella con una chiave composita, potete mappare propriet&agrave; multiple della classe
                come propriet&agrave; identificatore. L'elemento <tt class="literal">&lt;composite-id&gt;</tt> accetta
                mappaggi di propriet&agrave; <tt class="literal">&lt;key-property&gt;</tt> e 
                <tt class="literal">&lt;key-many-to-one&gt;</tt> come elementi figli.
            </p><pre class="programlisting">&lt;composite-id&gt;
        &lt;key-property name="medicareNumber"/&gt;
        &lt;key-property name="dependent"/&gt;
&lt;/composite-id&gt;</pre><p>
                La vostra classe persistente <span class="emphasis"><em>deve</em></span> sovrascrivere <tt class="literal">equals()</tt>
                e <tt class="literal">hashCode()</tt> per implementare l'uguaglianza degli identificatori composti.
                Deve anche implementare <tt class="literal">Serializable</tt>.
            </p><p>
                Sfortunatamente, questo approccio agli identificatori compositi significa che un
                oggetto persistente &egrave; il suo proprio identificatore. Non c'&egrave; un "handle" conveniente
                al di l&agrave; dell'oggetto stesso. Dovete istanziare un oggetto della classe persistente
                e popolare le sue propriet&agrave; di identificazione, prima che possiate caricare 
                (<tt class="literal">load()</tt>) lo stato persistente associato ad una classe composita. 
                Descriveremo un approccio molto pi&ugrave; conveniente in cui l'identificatore composito 
                sar&agrave; implementato come una classe separata nel paragrafo <a href="#components-compositeid" title="7.4.&nbsp;Componenti come identificatori composti">Sezione&nbsp;7.4, &#8220;Componenti come identificatori composti&#8221;</a>. 
                Gli attributi descritti sotto si applicano solo a questo approccio alternativo:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        <tt class="literal">name</tt> (opzionale): una propriet&agrave; di un tipo di componente che mantiene
                        l'identificatore composito (vedete la prossima sezione).
                    </p></li><li><p>
                        <tt class="literal">class</tt> (opzionale - il default &egrave; il tipo di propriet&agrave; ricavato via
                        "reflection"): la classe di componente usata come identificatore composito (vedere la 
                        prossima sezione).
                    </p></li><li><p>
                        <tt class="literal">unsaved-value</tt> (opzionale - il default &egrave; <tt class="literal">none</tt>): 
                        indica che le istanze transienti dovrebbero essere considerate appena istanziate, 
                        se impostato ad <tt class="literal">any</tt>.
                    </p></li></ul></div></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-discriminator"></a>5.1.6.&nbsp;discriminatori</h3></div></div><div></div></div><p>
                L'elemento <tt class="literal">&lt;discriminator&gt;</tt> &egrave; richiesto per la persistenza polimorfica 
                quando si usa la strategia di mappaggio "tabella per gerarchia di classi" e dichiara una 
                colonna discriminatore della tabella. La colonna discriminatore contiene valori di indicazione
                che informano lo strato persistente riguardo alla particolare sottoclasse da istanziare per una
                riga. Si pu&ograve; usare solo un insieme ristretto di tipi: 
                <tt class="literal">string</tt>, <tt class="literal">character</tt>, <tt class="literal">integer</tt>, 
                <tt class="literal">byte</tt>, <tt class="literal">short</tt>, <tt class="literal">boolean</tt>, 
                <tt class="literal">yes_no</tt>, <tt class="literal">true_false</tt>.
            </p><div class="programlistingco"><pre class="programlisting">&lt;discriminator
        column="discriminator_column"  <span class="co">(1)</span>
        type="discriminator_type"      <span class="co">(2)</span>
        force="true|false"             <span class="co">(3)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (opzionale - il default &egrave; <tt class="literal">class</tt>) il 
                            nome della colonna discriminatore.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (opzionale - il default &egrave; <tt class="literal">string</tt>) il nome 
                            che indica il tipo di Hibernate
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">force</tt> (opzionale - il default &egrave; <tt class="literal">false</tt>) 
                            "forza" Hibernate a specificare valori consentiti del discriminatore anche quando 
                            si stanno recuperando tutte le istanze della classe radice.
                        </p></td></tr></table></div></div><p>
                I valori effettivi della colonna discriminatore sono specificati dall'attributo 
                <tt class="literal">discriminator-value</tt> degli elementi <tt class="literal">&lt;class&gt;</tt> e
                <tt class="literal">&lt;subclass&gt;</tt>.
            </p><p>
                L'attributo <tt class="literal">force</tt> &egrave; utile (solo) se la tabella contiene righe con 
                valori di discriminatore "extra" che non sono mappati su una classe persistente. Questo 
                solitamente non &egrave; il caso.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-version"></a>5.1.7.&nbsp;versione (opzionale)</h3></div></div><div></div></div><p>
                L'elemento <tt class="literal">&lt;version&gt;</tt> &egrave; opzionale, e indica che la tabella
                contiene dati versionati. &Egrave; particolarmente utile se progettate di usare 
                <span class="emphasis"><em>transazioni lunghe</em></span> (vedete oltre).
            </p><div class="programlistingco"><pre class="programlisting">&lt;version
        column="version_column"                            <span class="co">(1)</span>
        name="propertyName"                                <span class="co">(2)</span>
        type="typename"                                    <span class="co">(3)</span>
        access="field|property|ClassName"                  <span class="co">(4)</span>
        unsaved-value="null|negative|undefined"            <span class="co">(5)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (opzionale - il default &egrave; il nome di propriet&agrave;): il nome
                            della colonna che mantiene il numero di versione.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: il nome di una propriet&agrave; della classe persistente.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (opzionale - il default &egrave; <tt class="literal">integer</tt>): 
                            il tipo del numero di versione.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (opzionale - il default &egrave; <tt class="literal">property</tt>): la strategia
                            che Hibernate deve usare per accedere al valore della propriet&agrave;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">unsaved-value</tt> (opzionale - il default &egrave; <tt class="literal">undefined</tt>): 
                            il valore di una propriet&agrave; di versione che indica che un'istanza &egrave; appena stata istanziata
                            (&egrave; "unsaved"), distinguendola da istanze transienti che erano state salvate o caricate in 
                            una sessione precedente. (<tt class="literal">undefined</tt> specifica che bisogna usare il valore
                            della propriet&agrave; identificatore.)
                        </p></td></tr></table></div></div><p>
                I numeri di versione possono essere di tipo <tt class="literal">long</tt>, <tt class="literal">integer</tt>,
                <tt class="literal">short</tt>, <tt class="literal">timestamp</tt> o <tt class="literal">calendar</tt>.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-timestamp"></a>5.1.8.&nbsp;timestamp (opzionale)</h3></div></div><div></div></div><p>
                L'elemento opzionale <tt class="literal">&lt;timestamp&gt;</tt> indica che la tabella contiene dati 
                con marche di tempo. Si intende come un'alternativa al versionamento. Le marche di tempo sono 
                per natura un'implementazione meno sicura del locking ottimistico. In ogni caso, a volte 
                l'applicazione potrebbe usare le marche di tempo in altri modi.
            </p><div class="programlistingco"><pre class="programlisting">&lt;timestamp
        column="timestamp_column"           <span class="co">(1)</span>
        name="propertyName"                 <span class="co">(2)</span>
        access="field|property|ClassName"   <span class="co">(3)</span>
        unsaved-value="null|undefined"      <span class="co">(4)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (opzionale - il default &egrave; il nome di propriet&agrave;): il nome di una
                            colonna che contiene la marca di tempo.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: il nome di una propriet&agrave; in stile JavaBeans del tipo java 
                            <tt class="literal">Date</tt> o <tt class="literal">Timestamp</tt> della classe persistente.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (opzionale - il default &egrave; <tt class="literal">property</tt>): la
                            strategia che Hibernate dovrebbe usare per accedere ai valori delle propriet&agrave;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">unsaved-value</tt> (opzionale - il default &egrave; <tt class="literal">null</tt>): 
                            il valore di una propriet&agrave; di versione che indica che l'istanza &egrave; appena stata 
                            istanziata (&egrave; "unsaved"), distinguendola dalle istanze transienti che sono state 
                            savlate o caricate in una sessione precedente. (<tt class="literal">undefined</tt> specifica
                            che bisogna usare il valore della propriet&agrave; identificatore.)
                        </p></td></tr></table></div></div><p>
                Notate che <tt class="literal">&lt;timestamp&gt;</tt> &egrave; equivalente a 
                <tt class="literal">&lt;version type="timestamp"&gt;</tt>.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-property"></a>5.1.9.&nbsp;property</h3></div></div><div></div></div><p>
                L'elemento <tt class="literal">&lt;property&gt;</tt> dichiara una propriet&agrave; persistente in stile JavaBeans della
                classe.
            </p><div class="programlistingco"><pre class="programlisting">&lt;property
        name="propertyName"                 <span class="co">(1)</span>
        column="column_name"                <span class="co">(2)</span>
        type="typename"                     <span class="co">(3)</span>
        update="true|false"                 <span class="co">(4)</span>
        insert="true|false"                 <span class="co">(4)</span>
        formula="arbitrary SQL expression"  <span class="co">(5)</span>
        access="field|property|ClassName"   <span class="co">(6)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: il nome della propriet&agrave; con iniziale minuscola.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (opzionale - il default &egrave; usare il nome della propriet&agrave;): il nome della
                            colonna mappata della tabella del database.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (opzionale): il nome che indica il tipo di Hibernate.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">update, insert</tt> (opzionale - il default &egrave; <tt class="literal">true</tt>):
                            specifica che le colonne mappate dovrebbero essere incluse in istruzioni SQL 
                            <tt class="literal">UPDATE</tt> e/o <tt class="literal">INSERT</tt>. Impostare entrambe a 
                            <tt class="literal">false</tt> consente una propriet&agrave; puramente "derivata" il cui 
                            valore &egrave; inizializzato da qualche altra propriet&agrave; che si mappa sulla stessa
                            colonna (o colonne), o da un trigger o da un'altra applicazione.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">formula</tt> (opzionale): una espressione SQL che definisce il valore per una propriet&agrave;
                            <span class="emphasis"><em>calcolata</em></span>. Le propriet&agrave; calcolate non hanno un mappaggio di colonna proprio.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (opzionale - il default &egrave; <tt class="literal">property</tt>): la strategia che
                            Hibernate deve usare per accedere al valore della propriet&agrave;.
                        </p></td></tr></table></div></div><p>
                <span class="emphasis"><em>typename</em></span> potrebbe essere:
            </p><div class="orderedlist"><ol type="1" compact><li><p>
                        Il nome di un tipo di base di Hibernate (ad esempio. <tt class="literal">integer, string, character,
                        date, timestamp, float, binary, serializable, object, blob</tt>).
                    </p></li><li><p>
                        Il nome di una classe Java con un tipo di default base (e.g. <tt class="literal">int, float,
                        char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</tt>).
                    </p></li><li><p>
                        Il nome di una sottoclasse di <tt class="literal">PersistentEnum</tt> (e.g. <tt class="literal">eg.Color</tt>).
                    </p></li><li><p>
                        Il nome di una classe java serializzabile.
                    </p></li><li><p>
                        Il nome della classe di un tipo personalizzato (e.g. <tt class="literal">com.illflow.type.MyCustomType</tt>).
                    </p></li></ol></div><p>
                Se non specificate un tipo, Hibernate user&agrave; la "reflection" sul nome della propriet&agrave; per indovinare
                il tipo di Hibernate corretto. Hibernate cercher&agrave; di interpretare il nome della classe di ritorno del
                metodo recuperatore ("getter") usando le regole 2, 3 e 4 in questo ordine. Per&ograve;, questo non &egrave; sempre
                abbastanza. In certi casi, avrete comunque bisogno dell'attributo <tt class="literal">type</tt>. 
                (Ad esempio, per distinguere tra <tt class="literal">Hibernate.DATE</tt> e <tt class="literal">Hibernate.TIMESTAMP</tt>, 
                o per specificare un tipo personalizzato.)
            </p><p>
            	L'attributo <tt class="literal">access</tt> vi consente di controllare come Hibernate acceder&agrave; 
            	al valore dell'attributo in fase di esecuzione. Il comportamento predefinito di Hibernate &egrave; di 
            	chiamare la coppia get/set della propriet&agrave;. Se per&ograve; specificate <tt class="literal">access="field"</tt>, 
            	Hibernate aggirer&agrave; la coppia get/set ed acceder&agrave; direttamente al campo utilizzando la "reflection". 
            	Potete anche specificare la vostra strategia per l'accesso alle propriet&agrave; indicando una classe che
            	implementi l'interfaccia <tt class="literal">net.sf.hibernate.property.PropertyAccessor</tt>.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-manytoone"></a>5.1.10.&nbsp;many-to-one</h3></div></div><div></div></div><p>
                Un'associazione ordinaria ad un'altra classe persistente si dichiara usando un elemento 
                <tt class="literal">many-to-one</tt>. Il modello relazionale &egrave; un'associazione molti-a-uno. 
                (In realt&agrave; si tratta semplicemente di un riferimento ad oggetto.)
            </p><div class="programlistingco"><pre class="programlisting">&lt;many-to-one
        name="propertyName"                                <span class="co">(1)</span>
        column="column_name"                               <span class="co">(2)</span>
        class="ClassName"                                  <span class="co">(3)</span>
        cascade="all|none|save-update|delete"              <span class="co">(4)</span>
        outer-join="true|false|auto"                       <span class="co">(5)</span>
        update="true|false"                                <span class="co">(6)</span>
        insert="true|false"                                <span class="co">(6)</span>
        property-ref="propertyNameFromAssociatedClass"     <span class="co">(7)</span>
        access="field|property|ClassName"                  <span class="co">(8)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: il nome della propriet&agrave;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (opzionale): il nome della colonna.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> (opzionale - il default &egrave; il tipo della propriet&agrave; 
                            determinato per "reflection"): il nome della classe associata.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">cascade</tt> (opzionale): specifica quali operazioni dovrebbero 
                            andare in cascata dall'oggetto genitore all'oggetto associato.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">outer-join</tt> (opzionale - il default &egrave; <tt class="literal">auto</tt>): 
                            consente la raccolta via outer-join per questa associazione se &egrave; impostata la 
                            propriet&agrave; <tt class="literal">hibernate.use_outer_join</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">update, insert</tt> (opzionale - il default &egrave; <tt class="literal">true</tt>) 
                            specifica che la colonna mappata dovrebbe venire inclusa nelle istruzioni SQL 
                            <tt class="literal">UPDATE</tt> e/o <tt class="literal">INSERT</tt>. Impostare entrambe a 
                            <tt class="literal">false</tt> consente di avere una associazione puramente "derivata" 
                            il cui valore &egrave; inizializzato da qualche altra propriet&agrave; che si mappi sulla stessa
                            colonna o da un trigger o da un'altra applicazione.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">property-ref</tt>: (opzionale) il nome di una propriet&agrave; della classe
                            associata che &egrave; messa in join a questa chiave esterna. Se non viene specificata, si
                            usa la chiave primaria della classe associata.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (opzionale - il default &egrave; <tt class="literal">property</tt>): la 
                            strategia che Hibernate deve usare per accedere al valore di questa propriet&agrave;.
                        </p></td></tr></table></div></div><p>
                L'attributo <tt class="literal">cascade</tt> accetta i valori seguenti: 
                <tt class="literal">all</tt>, <tt class="literal">save-update</tt>, <tt class="literal">delete</tt>,
                <tt class="literal">none</tt>. Impostare un valore diverso da <tt class="literal">none</tt>
                far&agrave; s&igrave; che certe operazioni si propaghino sull'oggetto associato (figlio).
                Vedete anche "oggetti a ciclo di vita" pi&ugrave; oltre.
            </p><p>
                L'attributo <tt class="literal">outer-join</tt> accetta tre valori differenti:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        <tt class="literal">auto</tt> (default) recupera l'associazione utilizzando un 
                        join esterno se la classe associata non ha proxy
                    </p></li><li><p>
                        <tt class="literal">true</tt> carica sempre l'associazione con un join esterno
                    </p></li><li><p>
                        <tt class="literal">false</tt> non carica mai l'associazione con un outer join
                    </p></li></ul></div><p>
                Una tipica dichiarazione <tt class="literal">many-to-one</tt> appare cos&igrave; semplice:
            </p><pre class="programlisting">&lt;many-to-one name="product" class="Product" column="PRODUCT_ID"/&gt;</pre><p>
                L'attributo <tt class="literal">property-ref</tt> dovrebbe venire usato solo per mappare 
                dati preesistenti in cui una chiave esterna faccia riferimento ad una chiave unica
                della tabella associata che sia diversa dalla chiave primaria. Si tratta di un modello
                relazionale decisamente orrido. Ad esempio, immaginate che la classe 
                <tt class="literal">Product</tt> abbia un numero di serie unico che non sia la chiave primaria.
                (L'attributo <tt class="literal">unique</tt> controlla la generazione del DDL da parte di 
                Hibernate con il tool SchemaExport.)
            </p><pre class="programlisting">&lt;property name="serialNumber" unique="true" type="string" column="SERIAL_NUMBER"/&gt;</pre><p>
                A questo punto il mappaggio per <tt class="literal">OrderItem</tt> potrebbe usare:
            </p><pre class="programlisting">&lt;many-to-one name="product" property-ref="serialNumber" column="PRODUCT_SERIAL_NUMBER"/&gt;</pre><p>
                In ogni modo questo &egrave; di certo non incoraggiato.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-onetoone"></a>5.1.11.&nbsp;one-to-one</h3></div></div><div></div></div><p>
                Una associazione uno-a-uno con un'altra classe persistente si dichiara usando un elemento
                <tt class="literal">one-to-one</tt> .
            </p><div class="programlistingco"><pre class="programlisting">&lt;one-to-one
        name="propertyName"                                <span class="co">(1)</span>
        class="ClassName"                                  <span class="co">(2)</span>
        cascade="all|none|save-update|delete"              <span class="co">(3)</span>
        constrained="true|false"                           <span class="co">(4)</span>
        outer-join="true|false|auto"                       <span class="co">(5)</span>
        property-ref="propertyNameFromAssociatedClass"     <span class="co">(6)</span>
        access="field|property|ClassName"                  <span class="co">(7)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: il nome della propriet&agrave;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> (opzionale - il default &egrave; il tipo della propriet&agrave;
                            determinato per "reflection"): il nome della classe associata.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">cascade</tt> (opzionale) specifica quali operazioni dovrebbero
                            propagarsi in cascata dall'oggetto genitore all'oggetto associato.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">constrained</tt> (opzionale) specifica che un vincolo di chiave
                            esterna sulla chiave primaria della tabella mappata fa riferimento alla tabella
                            della classe associata. Questa opzione condiziona l'ordine in cui <tt class="literal">save()</tt> 
                            e <tt class="literal">delete()</tt> vengono propagate (ed &egrave; anche usata dallo strumento di 
                            generazione dello schema ).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">outer-join</tt> (opzionale - il default &egrave; <tt class="literal">auto</tt>): 
                            consente la raccolta via join esterno per questa associazione quando viene impostato 
                            <tt class="literal">hibernate.use_outer_join</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">property-ref</tt>: (opzionale) il nome di una propriet&agrave; della classe
                            associata che &egrave; messa in join alla chiave primaria di questa classe. Se non viene 
                            specificata, viene usata la chiave primaria della classe associata.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (opzionale - il default &egrave; <tt class="literal">property</tt>): la
                            strategia che Hibernate dovrebbe usare per accedere al valore della propriet&agrave;.
                        </p></td></tr></table></div></div><p>
                Ci sono due variet&agrave; di associazioni uno-a-uno:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                associazioni di chiave primaria
            </p></li><li><p>
                associazioni di chiave esterna univoca
            </p></li></ul></div><p>
                Le associazioni di chiave primaria non hanno bisogno di una colonna extra nella tabella; 
                se due righe sono messe in relazione dall'associazione, allora le due righe condividono
                lo stesso valore di chiave primaria. Per questo, se volete che due oggetti siano correlati
                da un'associazion di chiave primaria, dovete assicurarvi che venga loro assegnato lo 
                stesso valore di identificatore!
            </p><p>
                Per un'associazione di chiave primaria, si aggiungono i mappaggi seguenti rispettivamente a
                <tt class="literal">Employee</tt> e <tt class="literal">Person</tt>.
            </p><pre class="programlisting">&lt;one-to-one name="person" class="Person"/&gt;</pre><pre class="programlisting">&lt;one-to-one name="employee" class="Employee" constrained="true"/&gt;</pre><p>
                Ora ci dobbiamo assicurare che le chiavi primarie delle righe correlate nelle
                tabelle PERSON e EMPLOYEE siano uguali. Usiamo una strategia di generazione di identificatore
                speciale di Hibernate, chiamata <tt class="literal">foreign</tt>:
            </p><pre class="programlisting">&lt;class name="person" table="PERSON"&gt;
    &lt;id name="id" column="PERSON_ID"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"&gt;employee&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    ...
    &lt;one-to-one name="employee"
        class="Employee"
        constrained="true"/&gt;
&lt;/class&gt;</pre><p>
                Ad un'istanza appena salvata di <tt class="literal">Person</tt> si assegna poi lo stesso valore di chiave
                primaria dell'istanza di <tt class="literal">Employee</tt> a cui fa riferimento la propriet&agrave; 
                <tt class="literal">employee</tt> di quella <tt class="literal">Person</tt>.
            </p><p>
                In alternativa, una chiave esterna con un vincolo di unicit&agrave; da <tt class="literal">Employee</tt> a
                <tt class="literal">Person</tt> pu&ograve; essere espressa come:
            </p><pre class="programlisting">&lt;many-to-one name="person" class="Person" column="PERSON_ID" unique="true"/&gt;</pre><p>
                E questa associazione pu&ograve; essere resa bidirezionale aggiungendo quanto segue al mappaggio di 
                <tt class="literal">Person</tt>:
            </p><pre class="programlisting">&lt;one-to-one name"employee" class="Employee" property-ref="person"/&gt;</pre></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-component"></a>5.1.12.&nbsp;component, dynamic-component</h3></div></div><div></div></div><p>
                L'elemento <tt class="literal">&lt;component&gt;</tt> mappa propriet&agrave; di un oggetto figlio 
                su colonne della tabella di una classe genitore. I componenti possono, a loro volta,
                dichiarare le proprie propriet&agrave;, componenti o collezioni. Vedete "Componenti" pi&ugrave; oltre.
            </p><div class="programlistingco"><pre class="programlisting">&lt;component 
        name="propertyName"                 <span class="co">(1)</span>
        class="className"                   <span class="co">(2)</span>
        insert="true|false"                 <span class="co">(3)</span>
        upate="true|false"                  <span class="co">(4)</span>
        access="field|property|ClassName"&gt;  <span class="co">(5)</span>
        
        &lt;property ...../&gt;
        &lt;many-to-one .... /&gt;
        ........
&lt;/component&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: il nome della propriet&agrave;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> (opzionale - il default &egrave; il tipo della propriet&agrave; 
                            individuato per "reflection"): il nome della classe componente (figlio).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">insert</tt>: le colonne mappate devono apparire nelle
                            <tt class="literal">INSERT</tt> SQL?
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">update</tt>: le colonne mappate devono apparire nelle
                            <tt class="literal">UPDATE</tt> SQL?
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (opzionale - il default &egrave; <tt class="literal">property</tt>): la 
                            strategia che Hibernate dovrebbe usare per accedere ai valori delle propriet&agrave;.
                        </p></td></tr></table></div></div><p>
                I tag figli <tt class="literal">&lt;property&gt;</tt> mappano propriet&agrave; della classe figlio a colonne
                della tabella.
            </p><p>
                L'elemento <tt class="literal">&lt;component&gt;</tt> consente un sottoelemento <tt class="literal">&lt;parent&gt;</tt>
                che mappa una propriet&agrave; della classe componente come un riferimento all'entit&agrave; contenitore.
            </p><p>
                L'elemento <tt class="literal">&lt;dynamic-component&gt;</tt> consente ad una <tt class="literal">Map</tt>
                di essere mappata come componente in cui i nomi delle propriet&agrave; si riferiscono a chiavi della mappa.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-subclass"></a>5.1.13.&nbsp;subclass</h3></div></div><div></div></div><p>
                Infine, la persistenza polimorfica richiede la dichiarazione di ogni sottoclasse della classe 
                persistente radice. Per la strategia di mappaggio (raccomandata) tabella-per-classe, 
                si usa la dichiarazione <tt class="literal">&lt;subclass&gt;</tt>.
            </p><div class="programlistingco"><pre class="programlisting">&lt;subclass
        name="ClassName"                              <span class="co">(1)</span>
        discriminator-value="discriminator_value"     <span class="co">(2)</span>
        proxy="ProxyInterface"                        <span class="co">(3)</span>
        lazy="true|false"                             <span class="co">(4)</span>
        dynamic-update="true|false"
        dynamic-insert="true|false"&gt;

        &lt;property .... /&gt;
        .....
&lt;/subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: il nomoe di classe completamente qualificato della sottoclasse.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">discriminator-value</tt> (opzionale - il default &egrave; il nome della classe): un valore 
                            che distingue le sottoclassi individuali.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">proxy</tt> (opzionale): specifica una classe o interfaccia da usare per i mediatori
                            ad inizializzazione ritardata ("lazy initializing proxy").
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (opzionale): impostare <tt class="literal">lazy="true"</tt> &egrave; un'abbreviazione
                            equivalente a specificare il nome della classe stessa come interfaccia <tt class="literal">proxy</tt>.
                        </p></td></tr></table></div></div><p>
                Ogni sottoclasse dovrebbe dichiarare le sue propriet&agrave; persistenti e le sottoclassi.
                Si assume che le propriet&agrave; <tt class="literal">&lt;version&gt;</tt> e <tt class="literal">&lt;id&gt;</tt>
                siano ereditate dalla classe radice. Ogni sottoclasse in una gerarchia deve definire
                un valore unico di <tt class="literal">discriminator-value</tt>. Se non viene specificato
                un valore viene usato il nome della classe java completamente qualificato.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-joinedsubclass"></a>5.1.14.&nbsp;joined-subclass</h3></div></div><div></div></div><p>
                In alternativa, una sottoclasse che sia resa persistente sulla sua propria tabella (strategia di 
                mappaggio "tabella per sottoclasse") si dichiara usando un elemento <tt class="literal">&lt;joined-subclass&gt;</tt>
                element.
            </p><div class="programlistingco"><pre class="programlisting">&lt;joined-subclass
        name="ClassName"                    <span class="co">(1)</span>
        proxy="ProxyInterface"              <span class="co">(2)</span>
        lazy="true|false"                   <span class="co">(3)</span>
        dynamic-update="true|false"
        dynamic-insert="true|false"&gt;

        &lt;key .... &gt;

        &lt;property .... /&gt;
        .....
&lt;/subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: il nome di classe completamente qualificato della sottoclasse.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">proxy</tt> (opzionale): specifica una classe od interfaccia da usare per i 
                            mediatori a inizializzazione ritardata ("lazy initializing proxy").
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional): impostare <tt class="literal">lazy="true"</tt> &egrave; un'abbreviazione
                            equivalente a specificare il nome della classe stessa come interfaccia <tt class="literal">proxy</tt>.
                        </p></td></tr></table></div></div><p>
                Non viene richiesta alcuna colonna discriminatore per questa strategia di mappaggio. Ogni sottoclasse deve,
                per&ograve;, dichiarare una colonna della tabella che contiene l'identificatore dell'oggetto usando l'elemento 
                <tt class="literal">&lt;key&gt;</tt>. Il mappaggio all'inizio del capitolo verrebbe riscritto come:
            </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

        &lt;class name="Cat" table="CATS"&gt;
                &lt;id name="id" column="uid" type="long"&gt;
                        &lt;generator class="hilo"/&gt;
                &lt;/id&gt;
                &lt;property name="birthdate" type="date"/&gt;
                &lt;property name="color" not-null="true"/&gt;
                &lt;property name="sex" not-null="true"/&gt;
                &lt;property name="weight"/&gt;
                &lt;many-to-one name="mate"/&gt;
                &lt;set name="kittens"&gt;
                        &lt;key column="MOTHER"/&gt;
                        &lt;one-to-many class="Cat"/&gt;
                &lt;/set&gt;
                &lt;joined-subclass name="DomesticCat" table="DOMESTIC_CATS"&gt;
                	&lt;key column="CAT"/&gt;
                        &lt;property name="name" type="string"/&gt;
                &lt;/joined-subclass&gt;
        &lt;/class&gt;

        &lt;class name="eg.Dog"&gt;
                &lt;!-- mapping for Dog could go here --&gt;
        &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-collections"></a>5.1.15.&nbsp;map, set, list, bag</h3></div></div><div></div></div><p>
                Le collezioni sono descritte pi&ugrave; avanti.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-import"></a>5.1.16.&nbsp;import</h3></div></div><div></div></div><p>
                Supponete che la vostra applicazione abbia due classi persistenti con lo stesso nome, 
                e non vogliate specificare il nome completamente qualificato (con il package) nelle 
                interrogazioni di Hibernate. Le classi possono essere "importate" esplicitamente invece
                di fare affidamento a <tt class="literal">auto-import="true"</tt>. Potete anche importare 
                classi e interfacce che non sono mappate esplicitamente.
            </p><pre class="programlisting">&lt;import class="java.lang.Object" rename="Universe"/&gt;</pre><div class="programlistingco"><pre class="programlisting">&lt;import
        class="ClassName"              <span class="co">(1)</span>
        rename="ShortName"             <span class="co">(2)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt>: il nome completamente qualificato di una classe java qualunque.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">rename</tt> (opzionale - il default &egrave; il nome non qualificato della classe):
                            un nome che pu&ograve; essere usato nel linguaggio di interrogazione.
                        </p></td></tr></table></div></div></div></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-types"></a>5.2.&nbsp;Tipi di Hibernate</h2></div></div><div></div></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-entitiesvalues"></a>5.2.1.&nbsp;Entit&agrave; e valori</h3></div></div><div></div></div><p>
                Per capire il comportamento di vari oggetti java a livello del linguaggio rispetto al 
                servizio di persistenza, dobbiamo classificarli in due gruppi:
            </p><p>
                Una <span class="emphasis"><em>entity</em></span> esiste indipendentemente dal fatto che altri
                oggetti mantengano riferimenti ad essa. Questo &egrave; in contrasto con il modello
                java usuale in cui un oggetto non referenziato &egrave; fatto oggetto di garbage 
                collection. Le entit&agrave; devono essere salvate e cancellate esplicitamente (eccetto
                il fatto che salvataggi e cancellamenti possono essere <span class="emphasis"><em>cascaded</em></span>
                ovvero propagati da un'entit&agrave; genitore ai suoi figli). Questo &egrave; differente dal 
                modello ODMG di persistenza per raggiungibilit&agrave; degli oggetti - e corrisponde 
                pi&ugrave; strettamente a come gli oggetti applicativi sono solitamente usati nei
                grandi sistemi. Le entit&agrave; supportano riferimenti circolari e condivisi: possono
                anche essere versionati.
            </p><p>
                Lo stato persistente di un'entit&agrave; consiste di riferimenti ad altre entit&agrave; e di 
                istanze di <span class="emphasis"><em>tipi di valore</em></span>. I valori sono tipi primitivi, collezioni
                componenti e alcuni oggetti immutabili. A differenza delle entit&agrave;, i tipi di valore
                (in particolare le collezioni e i componenti) <span class="emphasis"><em>sono</em></span> resi 
                persistenti e cancellati per raggiungibilit&agrave;. Poich&eacute; gli oggetti di valore (e i
                primitivi) sono resi persistenti e cancellati insieme all'entit&agrave; che li contiene,
                non possono essere versionati indipendentemente. I valori non hanno identit&agrave; 
                indipendente, e per questo non possono essere condivisi da due entit&agrave; o collezioni.
            </p><p>
                Tutti i tipi di Hibernate eccetto le collezioni devono supportare la semantica null.
            </p><p>
                Fino ad ora, abbiamo usato il termine "classe persistente" per riferirci alle entit&agrave;. 
                Continueremo a farlo. Parlando esattamente, per&ograve;, non tutte le classi definite dall'utente
                con uno stato persistente sono entit&agrave;. Un componente (<span class="emphasis"><em>component</em></span>) &egrave;
                una classe definita dall'utente con semantica di valore.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-basictypes"></a>5.2.2.&nbsp;Tipi di valore di base</h3></div></div><div></div></div><p>
                I <span class="emphasis"><em>tipi di base</em></span> possono a grandi linee essere catalogati in

                </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">integer, long, short, float, double, character, byte,
                            boolean, yes_no, true_false</tt></span></dt><dd><p>
                                Mappaggi di tipo dai primitivi java o dalle classi incapsulatore
                                su tipi di colonna SQL appropriati (e specifici della marca del database).
                                <tt class="literal">boolean, yes_no</tt> e <tt class="literal">true_false</tt> sono tutte
                                codifiche alternative per un <tt class="literal">boolean</tt> o <tt class="literal">java.lang.Boolean</tt>
                                di java.
                            </p></dd><dt><span class="term"><tt class="literal">string</tt></span></dt><dd><p>
                                Mappaggio di tipo da <tt class="literal">java.lang.String</tt> a
                                <tt class="literal">VARCHAR</tt> (o <tt class="literal">VARCHAR2</tt> di Oracle).
                            </p></dd><dt><span class="term"><tt class="literal">date, time, timestamp</tt></span></dt><dd><p>
                                Mappaggi di tipo da <tt class="literal">java.util.Date</tt> e le sue sottoclassi
                                ai tipi SQL <tt class="literal">DATE</tt>, <tt class="literal">TIME</tt> e 
                                <tt class="literal">TIMESTAMP</tt> (o equivalenti).
                            </p></dd><dt><span class="term"><tt class="literal">calendar, calendar_date</tt></span></dt><dd><p>
                                Mappaggi di tipo da <tt class="literal">java.util.Calendar</tt> ai tipi SQL
                                <tt class="literal">TIMESTAMP</tt> e <tt class="literal">DATE</tt>
                                (o equivalenti).
                            </p></dd><dt><span class="term"><tt class="literal">big_decimal</tt></span></dt><dd><p>
                                Mappaggio di tipo da <tt class="literal">java.math.BigDecimal</tt> a
                                <tt class="literal">NUMERIC</tt> (o <tt class="literal">NUMBER</tt> in Oracle).
                            </p></dd><dt><span class="term"><tt class="literal">locale, timezone, currency</tt></span></dt><dd><p>
                                Mappaggi di tipo da <tt class="literal">java.util.Locale</tt>,
                                <tt class="literal">java.util.TimeZone</tt> e 
                                <tt class="literal">java.util.Currency</tt> 
                                verso <tt class="literal">VARCHAR</tt> (o <tt class="literal">VARCHAR2</tt> in Oracle).
                                Istanze di <tt class="literal">Locale</tt> e <tt class="literal">Currency</tt> vengono
                                mappati sui loro codici ISO. Le istanze di TimeZone vengono mappate sul 
                                loro <tt class="literal">ID</tt>. 
                            </p></dd><dt><span class="term"><tt class="literal">class</tt></span></dt><dd><p>
                                Mappaggio di tipo da <tt class="literal">java.lang.Class</tt> a
                                <tt class="literal">VARCHAR</tt> (o <tt class="literal">VARCHAR2</tt> in Oracle).
                                Un oggetto <tt class="literal">Class</tt> viene mappato sul suo nome di classe
                                completamente qualificato.
                            </p></dd><dt><span class="term"><tt class="literal">binary</tt></span></dt><dd><p>
                                Mappa array di byte su un tipo binario SQL appropriato.
                            </p></dd><dt><span class="term"><tt class="literal">text</tt></span></dt><dd><p>
                                Mappa stringhe java lunghe su un tipo <tt class="literal">CLOB</tt> or 
                                <tt class="literal">TEXT</tt> dell'SQL.
                            </p></dd><dt><span class="term"><tt class="literal">serializable</tt></span></dt><dd><p>
                                Mappa tipi java serializzabili su un tipo binario SQL appropriato.
                                Potete anche indicare il tipo Hibernate <tt class="literal">serializable</tt> con
                                il nome di una classe java serializzabile o un'interfaccia che non abbia
                                come default un tipo di base, o implementare <tt class="literal">PersistentEnum</tt>.
                            </p></dd><dt><span class="term"><tt class="literal">clob, blob</tt></span></dt><dd><p>
                                Mappaggi di tipo per le classi JDBC <tt class="literal">java.sql.Clob</tt> e
                                <tt class="literal">java.sql.Blob</tt>. Questi tipi possono non essere convenienti
                                per alcune applicazioni, perch&eacute; gli oggetti blob o clob non possono essere
                                riutilizzati al di fuori di una transazione (e per di pi&ugrave; il supporto da 
                                parte dei driver &egrave; approssimativo e inconsistente.)
                            </p></dd></dl></div><p>
            
            </p><p>
                Gli identificatori unici delle entit&agrave; e le collezioni possono essere di qualsiasi tipo di base
                eccetto <tt class="literal">binary</tt>, <tt class="literal">blob</tt> e <tt class="literal">clob</tt>. 
                (Sono permessi anche identificatori compositi, leggete pi&ugrave; sotto.)
            </p><p>
                I tipi di valore di base hanno costanti <tt class="literal">Type</tt> corrispondenti definite nella classe
                <tt class="literal">net.sf.hibernate.Hibernate</tt>. Ad esempio, <tt class="literal">Hibernate.STRING</tt>
                rappresenta il tipo <tt class="literal">string</tt>.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-enum"></a>5.2.3.&nbsp;Tipi di enumerazione persistente</h3></div></div><div></div></div><p>
                Un tipo <span class="emphasis"><em>enumerativo</em></span> &egrave; un idioma java comune in cui una classe ha un (piccolo) numero
                costante di istanze immutabili. Potete creare un tipo enumerativo persistente implementando
                <tt class="literal">net.sf.hibernate.PersistentEnum</tt>, definendo le operazioni <tt class="literal">toInt()</tt> 
                e <tt class="literal">fromInt()</tt>:
            </p><pre class="programlisting">package eg;
import net.sf.hibernate.PersistentEnum;

public class Color implements PersistentEnum {
    private final int code;
    private Color(int code) {
        this.code = code;
    }
    public static final Color TABBY = new Color(0);
    public static final Color GINGER = new Color(1);
    public static final Color BLACK = new Color(2);

    public int toInt() { return code; }

    public static Color fromInt(int code) {
        switch (code) {
            case 0: return TABBY;
            case 1: return GINGER;
            case 2: return BLACK;
            default: throw new RuntimeException("Unknown color code");
        }
    }
}</pre><p>
                Il nome di tipo di Hibernate in questo caso &egrave; semplicemente il nome della classe enumerativa.
                <tt class="literal">eg.Color</tt>.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-custom"></a>5.2.4.&nbsp;Tipi di valore personalizzati</h3></div></div><div></div></div><p>
                Per gli sviluppatori &egrave; relativamente facile creare i prorpi tipi di valore. Ad esempio,
                potreste desiderare rendere persistenti propriet&agrave; di tipo  <tt class="literal">java.lang.BigInteger</tt>
                su colonne <tt class="literal">VARCHAR</tt>. Hibernate non fornisce un tipo predefinito per questo, ma
                i tipi personalizzati non sono limitati al mappaggio di una propriet&agrave; (o elemento di collezione)
                su una singola colonna di tabella. Allora, ad esempio, potreste avere una propriet&agrave; java
                <tt class="literal">getName()</tt>/<tt class="literal">setName()</tt> di tipo
                <tt class="literal">java.lang.String</tt> che sia resa persistente sulle colonne
                <tt class="literal">FIRST_NAME</tt>, <tt class="literal">INITIAL</tt>, <tt class="literal">SURNAME</tt>. 
            </p><p>
                Per implementare un tipo personalizzato, implementate <tt class="literal">net.sf.hibernate.UserType</tt> 
                o <tt class="literal">net.sf.hibernate.CompositeUserType</tt> e dichiarate le propriet&agrave; usando il nome
                di classe completamente qualificato del tipo. Guardate il codice di 
                <tt class="literal">net.sf.hibernate.test.DoubleStringType</tt> per vedere il genere di cose che sono
                possibili.
            </p><pre class="programlisting">&lt;property name="twoStrings" type="net.sf.hibernate.test.DoubleStringType"&gt;
    &lt;column name="first_string"/&gt;
    &lt;column name="second_string"/&gt;
&lt;/property&gt;</pre><p>
                Notate l'uso di elementi <tt class="literal">&lt;column&gt;</tt> per mappare una propriet&agrave; su colonne
                multiple.
            </p><p>
                Anche se l'insieme ricco di tipi predefiniti e il supporto per i componenti significa che
                avrete molto raramente <span class="emphasis"><em>bisogno</em></span> di usare un tipo personalizzato, &egrave; comunque
                considerata una buona norma usare i tipi personalizzati per le classi (non di entit&agrave;) che 
                si presentino frequentemente nella vostra applicazione. Ad esempio, una classe
                <tt class="literal">MonetaryAmount</tt> &egrave; un buon candidato per un <tt class="literal">CompositeUserType</tt>, 
                anche se potrebbe essere facilmente mappato come componente. Una ragione per questo &egrave; l'astrazione.
                Con un tipo personalizzato i vostri documenti di mappaggio sarebbero a prova di cambiamenti possibili
                nella vostra maniera di rappresentare valori monetari in futuro.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-anymapping"></a>5.2.5.&nbsp;Tipi di mappaggio "any"</h3></div></div><div></div></div><p>
                C'&egrave; un tipo ulteriore di mappaggio di propriet&agrave;. L'elemento di mappaggio <tt class="literal">&lt;any&gt;</tt>
                definisce una associazione polimorfica alle classi da tabelle multiple. Questo tipo di mappaggio
                richiede sempre pi&ugrave; di una colonna. La prima colonna mantiene il tipo dell'entit&agrave; associata. Le 
                colonne rimanenti mantengono l'identificatore. &Egrave; impossibile specificare un vincolo di chiave esterna
                per questo genere di associazioni, cos&igrave; non si tratta certamente del modo usuale di mappare associazioni
                (polimorfiche). Dovreste usarlo solo in casi molto speciali (ad esempio registri di auditing, dati 
                delle sessioni utente, ecc.). 
            </p><pre class="programlisting">&lt;any name="anyEntity" id-type="long" meta-type="eg.custom.Class2TablenameType"&gt;
    &lt;column name="table_name"/&gt;
    &lt;column name="id"/&gt;
&lt;/any&gt;</pre><p>
                 L'attributo <tt class="literal">meta-type</tt> consente all'applicazione di specificare un 
                 tipo personalizzato che mappi valori di colonne del database su classi persistenti che abbiano
                 propriet&agrave; identificatore del tipo specificato da <tt class="literal">id-type</tt>. Se il meta-tipo
                 restituisce istanze di <tt class="literal">java.lang.Class</tt>, non &egrave; richiesto nient'altro. Da 
                 un altro punto di vista, se &egrave; un tipo basico come <tt class="literal">string</tt> o <tt class="literal">character</tt>, 
                 dovete specificare il mappaggio da valori a classi.
            </p><pre class="programlisting">&lt;any name="anyEntity" id-type="long" meta-type="string"&gt;
    &lt;meta-value value="TBL_ANIMAL" class="Animal"/&gt;
    &lt;meta-value value="TBL_HUMAN" class="Human"/&gt;
    &lt;meta-value value="TBL_ALIEN" class="Alien"/&gt;
    &lt;column name="table_name"/&gt;
    &lt;column name="id"/&gt;
&lt;/any&gt;</pre><div class="programlistingco"><pre class="programlisting">&lt;any
        name="propertyName"                      <span class="co">(1)</span>
        id-type="idtypename"                     <span class="co">(2)</span>
        meta-type="metatypename"                 <span class="co">(3)</span>
        cascade="none|all|save-update"           <span class="co">(4)</span>
        access="field|property|ClassName"        <span class="co">(5)</span>
&gt;
        &lt;meta-value ... /&gt;
        &lt;meta-value ... /&gt;
        .....
        &lt;column .... /&gt;
        &lt;column .... /&gt;
        .....
&lt;/any&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: il nome della propriet&agrave;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">id-type</tt>: il nome dell'identificatore.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">meta-type</tt> (opzionale - il default &egrave; <tt class="literal">class</tt>): 
                            un tipo che mappa <tt class="literal">java.lang.Class</tt> su una singola colonna del database 
                            o, alternativamente, un tipo che sia consentito per un mappaggio a discriminatore.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">cascade</tt> (opzionale - il default &egrave; <tt class="literal">none</tt>): 
                            il tipo di cascata.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (opzionale - il default &egrave; <tt class="literal">property</tt>): la
                            strategia che Hibernate dovrebbe usare per accedere al valore delle propriet&agrave;.
                        </p></td></tr></table></div></div><p>
                Il vecchio tipo <tt class="literal">object</tt> che svolgeva un ruolo simile in Hibernate 1.2 &egrave; ancora
                supportato, ma &egrave; oramai semi-deprecato.
            </p></div></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-quotedidentifiers"></a>5.3.&nbsp;Identificatori SQL tra virgolette</h2></div></div><div></div></div><p>
                Potete forzare Hibernate a mettere un identificatore tra virgolette nell'SQL generato mettendo
                il nome della tabella tra "backtick" (virgolette inverse) nel documento di mappaggio. Hibernate
                user&agrave; lo stile di virgolettatura corretta per il <tt class="literal">Dialect</tt> SQL (di solito
                sono virgolette doppie, ma SQL Server usa parentesi quadre, e MySQL usa backtick).
            </p><pre class="programlisting">&lt;class name="LineItem" table="`Line Item`"&gt;
    &lt;id name="id" column="`Item Id`"/&gt;&lt;generator class="assigned"/&gt;&lt;/id&gt;
    &lt;property name="itemNumber" column="`Item #`"/&gt;
    ...
&lt;/class&gt;</pre></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-modularfiles"></a>5.4.&nbsp;File di mappaggio modulari</h2></div></div><div></div></div><p>
            &Egrave; possibile definire mappaggi <tt class="literal">subclass</tt> e <tt class="literal">joined-subclass</tt>
            in documenti di mappaggio separati, direttamente sotto a <tt class="literal">hibernate-mapping</tt>.
            Questo vi consente di estendere una gerarchia di classe aggiungendo semplicemente un nuovo 
            file di mappaggio. Dovete specificare un attributo <tt class="literal">extends</tt> nel mappaggio di sottoclasse, 
            indicando una superclasse mappata preventivamente: l'uso di questa funzionalit&agrave; fa s&igrave; che
            l'ordinamento dei documenti di mappaggio sia importante!
        </p><pre class="programlisting">
&lt;hibernate-mapping&gt;
        &lt;subclass name="eg.subclass.DomesticCat" extends="eg.Cat" discriminator-value="D"&gt;
             &lt;property name="name" type="string"/&gt;
        &lt;/subclass&gt;
&lt;/hibernate-mapping&gt;</pre></div></div><div class="chapter" lang="it"><div class="titlepage"><div><div><h2 class="title"><a name="collections"></a>Capitolo&nbsp;6.&nbsp;Mappaggio delle collezioni</h2></div></div><div></div></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-persistent"></a>6.1.&nbsp;Collezioni persistenti</h2></div></div><div></div></div><p>
            Questa sezione non contiene molto codice Java di esempio. Diamo per scontato che
            conosciate gi&agrave; come usare l'infrastruttura delle collezioni in Java. Se &egrave; cos&igrave;, 
            non c'&egrave; davvero niente di pi&ugrave; da sapere - con un'unica avvertenza, potete usare
            le collezioni di Java nello stesso modo in cui avete sempre fatto.
        </p><p>
            Hibernate pu&ograve; rendere persistenti istanze di 
            <tt class="literal">java.util.Map</tt>,
            <tt class="literal">java.util.Set</tt>,
            <tt class="literal">java.util.SortedMap</tt>,
            <tt class="literal">java.util.SortedSet</tt>,
            <tt class="literal">java.util.List</tt>,
            e qualsiasi array di entit&agrave; persistenti o valori. Le propriet&agrave; di tipo
            <tt class="literal">java.util.Collection</tt> or
            <tt class="literal">java.util.List</tt>
            possono anche essere rese persistenti con semantiche a "sacco" ("bag").
        </p><p>
            Ed ora l'avvertenza: le collezioni persistenti non mantengono nessuna semantica aggiunta dalla
            classe che implementa l'interfaccia di base della collezione particolare (come ad esempio l'ordine
            di iterazione in un <tt class="literal">LinkedHashSet</tt>).
            Le collezioni persistenti in particolare si comportano come
            <tt class="literal">HashMap</tt>,
            <tt class="literal">HashSet</tt>,
            <tt class="literal">TreeMap</tt>,
            <tt class="literal">TreeSet</tt> e
            <tt class="literal">ArrayList</tt>
            rispettivamente. Inoltre, il tipo di oggetto java di una propriet&agrave; che contiene una collezione, deve
            essere quello dell'interfaccia (ovvero <tt class="literal">Map</tt>, <tt class="literal">Set</tt> o
            <tt class="literal">List</tt>; mai <tt class="literal">HashMap</tt>, <tt class="literal">TreeSet</tt> o
            <tt class="literal">ArrayList</tt>). Questa restrizione esiste perch&eacute;, a vostra insaputa, Hibernate
            sostituisce le istanze di <tt class="literal">Map</tt>, <tt class="literal">Set</tt>
            e <tt class="literal">List</tt> con istanze delle sue implementazioni persistenti di queste interfacce. 
            Per questo motivo, dovete anche fare attenzione quando usate <tt class="literal">==</tt> sulle collezioni.
        </p><pre class="programlisting">Cat cat = new DomesticCat();
Cat kitten = new DomesticCat();
....
Set kittens = new HashSet();
kittens.add(kitten);
cat.setKittens(kittens);
session.save(cat);
kittens = cat.getKittens(); //Ok, la collezione "kittens" &egrave; un Set
(HashSet) cat.getKittens(); //Errore!</pre><p>
            Le collezioni rispettano le normali regole per i tipi di valore: niente riferimenti 
            condivisi, vengono create e cancellate insieme all'entit&agrave; che le contiene. A causa
            delle caratteristiche del modello relazionale sottostante, non sopportano semantiche
            a valore nullo: Hibernate non distingue tra il riferimento ad una collezione nulla e 
            una collezione vuota.
        </p><p>
            Le collezioni sono automaticamente rese persistenti quando sono referenziate da 
            un oggetto persistente, e cancellate automaticamente quando il riferimento
            viene eliminato. Se una collezione viene passata da un oggetto persistente ad un altro, 
            i suoi elementi vengono spostati da una tabella ad un'altra. Non dovreste preoccuparvi
            molto di questo: semplicemente usate le collezioni di Hibernate nello stesso modo in cui
            usate le normali collezioni di Java, ma assicuratevi di comprendere la semantica delle
            associazioni bidirezionali (discussa pi&ugrave; avanti), prima di farlo.
        </p><p>
            Le istanze di collezione sono distinte nel database da una chiave esterna verso l'entit&agrave; 
            che le contiene. Questa chiave esterna viene chiamata la 
            <span class="emphasis"><em>chiave di collezione</em></span>. La chiave di collezione &egrave; mappata con l'elemento
            <tt class="literal">&lt;key&gt;</tt>.
        </p><p>
            Le collezioni possono contenere quasi ogni altro tipo di Hibernate, compresi tutti 
            i tipi di base, i tipi personalizzati (custom), i tipi di entit&agrave; e i componenti. 
            Questa &egrave; una definizione importante: un oggetto in una collezione pu&ograve; essere gestito
            sia con una semantica di "passaggio per valore" (del resto dipende completamente 
            dal proprietario della collezione) o pu&ograve; essere un riferimento ad un'altra entit&agrave; di
            Hibernate, con il suo proprio ciclo di vita. Le collezioni non possono contenere
            altre collezioni. Il tipo contenuto viene chiamato il <span class="emphasis"><em>tipo di elemento della collezione</em></span>. 
            Gli elementi della collezione vengono mappati da<tt class="literal">&lt;element&gt;</tt>, 
            <tt class="literal">&lt;composite-element&gt;</tt>,
            <tt class="literal">&lt;one-to-many&gt;</tt>, <tt class="literal">&lt;many-to-many&gt;</tt> or
            <tt class="literal">&lt;many-to-any&gt;</tt>. I primi due mappano elementi con semantica di valore, 
            mentre gli altri tre vengono usati per mappare associazioni tra entit&agrave;.
        </p><p>
            Tutti i tipi di collezione eccetto <tt class="literal">Set</tt> e bag hanno una colonna 
            <span class="emphasis"><em>indice</em></span> , ovvero una colonna che mappa l'indice di un array o di una 
            <tt class="literal">List</tt> o la chiave di una <tt class="literal">Map</tt>. L'indice di una 
            <tt class="literal">Map</tt> pu&ograve; essere di qualsiasi tipo di base, un tipo di entit&agrave; o anche un 
            tipo composito (ma non pu&ograve; essere una collezione). L'indice di un array o di una lista &egrave; 
            sempre di tipo <tt class="literal">integer</tt>. Gli indici vengono mappati usando <tt class="literal">&lt;index&gt;</tt>, 
            <tt class="literal">&lt;index-many-to-many&gt;</tt>,
            <tt class="literal">&lt;composite-index&gt;</tt> o <tt class="literal">&lt;index-many-to-any&gt;</tt>.
        </p><p>
            C'&egrave; un insieme abbastanza vario di mappaggi che possono venire generati per le collezioni, 
            e coprono molti modelli relazionali comuni. Suggeriamo che sperimentiate con lo strumento
            di generazione dello schema per avere un'idea di come i vari tipi di dichiarazione si 
            traducono in tabelle di database.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-mapping"></a>6.2.&nbsp;Come mappare una collezione</h2></div></div><div></div></div><p>
            Le collezioni vengono dichiarate tramite gli elementi
            <tt class="literal">&lt;set&gt;</tt>,
            <tt class="literal">&lt;list&gt;</tt>,
            <tt class="literal">&lt;map&gt;</tt>,
            <tt class="literal">&lt;bag&gt;</tt>,
            <tt class="literal">&lt;array&gt;</tt> e
            <tt class="literal">&lt;primitive-array&gt;</tt>.
            <tt class="literal">&lt;map&gt;</tt> &egrave; un buon esempio:
        </p><div class="programlistingco"><pre class="programlisting">&lt;map
    name="propertyName"                                         <span class="co">(1)</span>
    table="table_name"                                          <span class="co">(2)</span>
    schema="schema_name"                                        <span class="co">(3)</span>
    lazy="true|false"                                           <span class="co">(4)</span>
    inverse="true|false"                                        <span class="co">(5)</span>
    cascade="all|none|save-update|delete|all-delete-orphan"     <span class="co">(6)</span>
    sort="unsorted|natural|comparatorClass"                     <span class="co">(7)</span>
    order-by="column_name asc|desc"                             <span class="co">(8)</span>
    where="arbitrary sql where condition"                       <span class="co">(9)</span>
    outer-join="true|false|auto"                                <span class="co">(10)</span>
    batch-size="N"                                              <span class="co">(11)</span>
    access="field|property|ClassName"                           <span class="co">(12)</span>
&gt;

    &lt;key .... /&gt;
    &lt;index .... /&gt;
    &lt;element .... /&gt;
&lt;/map&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">name</tt> il nome della propriet&agrave; corrispondente alla collezione
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">table</tt> (opzionale - se assente &egrave; uguale al nome della propriet&agrave;) il
                        nome della tabella che corrisponde alla collezione (non usato per le associazioni uno-a-molti)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">schema</tt> (opzionale) il nome di uno schema di tabella che sovrascriva
                        quello dichiarato sull'elemento radice
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                        <tt class="literal">lazy</tt> (opzionale - se assente &egrave; <tt class="literal">false</tt>)
                        consente l'inizializzazione differita (non usato per gli array)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                        <tt class="literal">inverse</tt> (opzionale - se assente vale <tt class="literal">false</tt>)
                        indica che questa collezione &egrave; il lato "opposto" di una associazione bidirezionale
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                        <tt class="literal">cascade</tt> (opzionale - se assente vale <tt class="literal">none</tt>)
                        consente che le operazioni si propaghino sugli elementi figli della collezione
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                        <tt class="literal">sort</tt> (opzionale) specifica una collezione ordinata con un metodo 
                        di ordinamento <tt class="literal">naturale</tt>, o una classe di comparazione specifica
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                        <tt class="literal">order-by</tt> (opzionale, solo JDK1.4) specifica una colonna della tabella 
                        (o pi&ugrave; colonne) che indica l'ordine di iterazione della <tt class="literal">Map</tt>, del <tt class="literal">Set</tt>
                        o del bag, con un indicatore <tt class="literal">asc</tt> o <tt class="literal">desc</tt> (ascendente o discendente) 
                        opzionale.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                        <tt class="literal">where</tt> (opzionale) specifica una condizione <tt class="literal">WHERE</tt> opzionale
                        da usare quando si carica o rimuove la collezione (utile se la collezione deve contenere solo un 
                        sottoinsieme dei dati presenti)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                        <tt class="literal">outer-join</tt> (opzionale) specifica che la collezione dovrebbe essere caricata 
                        tramite un outer join, quando possibile. Solo una collezione pu&ograve; venire caricata in questo modo
                        in una <tt class="literal">SELECT</tt> SQL.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(11)</td><td valign="top" align="left"><p>
                        <tt class="literal">batch-size</tt> (opzionale, per default vale <tt class="literal">1</tt>) specifica
                        una dimensione del "batch" (blocco di caricamento) per il caricamento differito di istanze 
                        di questa collezione.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(12)</td><td valign="top" align="left"><p>
                        <tt class="literal">access</tt> (opzionale - se assente vale <tt class="literal">property</tt>): La 
                        strategia che Hibernate dovrebbe utilizzare per accedere al valore di questa propriet&agrave;.
                    </p></td></tr></table></div></div><p>
            Il mappaggio di una <tt class="literal">List</tt> o di un array richiede una colonna separata della tabella
            per mantenere l'indice (l'elemento <tt class="literal">i</tt> in <tt class="literal">foo[i]</tt>). Se il vostro 
            modello relazionale non ha una colonna indice, ad esempio perch&eacute; state lavorando con dati preesistenti,
            usate un <tt class="literal">Set</tt> non ordinato. Questo sembra deludere le persone che assumono che una 
            <tt class="literal">List</tt> sia un modo pi&ugrave; conveniente di accedere ad una collezione non ordinata, ma 
            le collezioni di Hibernate obbediscono strettamente alla semantica associata alle interfacce 
            <tt class="literal">Set</tt>, <tt class="literal">List</tt> e <tt class="literal">Map</tt>, e semplicemente gli elementi di una 
            <tt class="literal">List</tt> non si ordinano spontaneamente!
        </p><p>
            Da un altro punto di vista, le persone che immaginavano di usare <tt class="literal">List</tt> per emilare 
            la semantica di un <span class="emphasis"><em>bag</em></span> hanno un motivo legittimo di lamentela, qui.
            Un bag &egrave; una collezione non ordinata e non indicizzata di elementi, che pu&ograve; quindi contenere lo stesso
            elemento pi&ugrave; volte. L'infrastruttura delle collezioni di java non specifica un'interfaccia 
            <tt class="literal">Bag</tt>, per cui la si deve emulare con una <tt class="literal">List</tt>. Hibernate consente
            di mappare propriet&agrave; di tipo <tt class="literal">List</tt> o <tt class="literal">Collection</tt> con l'elemento 
            <tt class="literal">&lt;bag&gt;</tt>. Notate che la semantica del sacco (bag) non sono realmente parte del 
            contratto di <tt class="literal">Collection</tt> ed in realt&agrave; confliggono con il contratto della 
            <tt class="literal">List</tt> contract (anche se, come discusso pi&ugrave; avanti nel capitolo, potete ordinare 
            a piacimento il bag).
        </p><p>
            Nota: bag molto grandi mappati con <tt class="literal">inverse="false"</tt> in Hibernate sono inefficienti, 
            e andrebbero evitati; Hiberante non pu&ograve; creare, cancellare o aggiornare righe individualmente perch&eacute;
            non c'&egrave; una chiave che possa identificare una riga singola.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-ofvalues"></a>6.3.&nbsp;Collezioni di valori e associazioni molti-a-molti</h2></div></div><div></div></div><p>
            Una tabella di collezione &egrave; richiesta per ogni collezione di valori o di riferimenti ad 
            altre entit&agrave; che sia mappada come un'associazione molti-a-molti (la semantica naturale
            per una collezione java). La tabella richiede colonne di chiave (esterna), colonne
            di elemento e possibilmente colonne indice.
        </p><p>
            La chiave esterna dalla tabella di collezione verso la tabella della classe
            proprietaria &egrave; dichiarata usando un elemento <tt class="literal">&lt;key&gt;</tt>.
        </p><div class="programlistingco"><pre class="programlisting">&lt;key column="column_name"/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (obbligatorio): Il nome della colonna di chiave esterna.
                    </p></td></tr></table></div></div><p>
            Per le collezioni indicizzate come le mappe e le liste, &egrave; necessario un elemento <tt class="literal">&lt;index&gt;</tt>. 
            Per le liste, questa colonna deve contenere interi in sequenza, numerati a partire da zero. Assicuratevi che il vostro
            indice parta davvero da zero, se dovete avere a che fare con dati preesistenti. Per le mappe, la colonna pu&ograve; 
            contenere valori di un tipo qualsiasi gestito da Hibernate.
        </p><div class="programlistingco"><pre class="programlisting">&lt;index
        column="column_name"                <span class="co">(1)</span>
        type="typename"                     <span class="co">(2)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (obbligatorio): Il nome della colonna che contiene i valori dell'indice di 
                        collezione.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">type</tt> (opzionale, se assente vale <tt class="literal">integer</tt>):
                        Il tipo dell'indice di collezione.
                    </p></td></tr></table></div></div><p>
            In alternativa, una mappa pu&ograve; essere indicizzata da oggetti di tipo "entit&agrave;". Usiamo in 
            questo caso l'elemento <tt class="literal">&lt;index-many-to-many&gt;</tt>.
        </p><div class="programlistingco"><pre class="programlisting">&lt;index-many-to-many
        column="column_name"                <span class="co">(1)</span>
        class="ClassName"                   <span class="co">(2)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (obbligatorio): Il nome della colonna che contiene la
                        chiave esterna verso i valori di indice della collezione.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">class</tt> (obbligatorio): La classe dell'entit&agrave; che &egrave; usata come 
                        indice della collezione.
                    </p></td></tr></table></div></div><p>
            Per una collezione di valori usiamo l'etichetta <tt class="literal">&lt;element&gt;</tt>.
        </p><div class="programlistingco"><pre class="programlisting">&lt;element
        column="column_name"                <span class="co">(1)</span>
        type="typename"                     <span class="co">(2)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (obbligatorio): Il nome della colonna che contiene i valori degli 
                        elementi della collezione.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">type</tt> (obbligatorio): Il tipo degli elementi della collezione.
                    </p></td></tr></table></div></div><p>
            Una collezione di entit&agrave; con la propria tabella corrisponde alla nozione relazionale di
            <span class="emphasis"><em>associazione molti-a-molti</em></span>. Una associazione di questo tipo &egrave; il 
            mappaggio pi&ugrave; naturale per una collezione java, ma solitamente non rappresenta il miglior
            modello relazionale.
        </p><div class="programlistingco"><pre class="programlisting">&lt;many-to-many
        column="column_name"                               <span class="co">(1)</span>
        class="ClassName"                                  <span class="co">(2)</span>
        outer-join="true|false|auto"                       <span class="co">(3)</span>
    /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (obbligatorio): Il nome della colonna con la chiave esterna verso l'elemento.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">class</tt> (obbligatorio): Il nome della classe associata.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">outer-join</tt> (opzionale - se assente vale <tt class="literal">auto</tt>):
                        quando il parametro <tt class="literal">hibernate.use_outer_join</tt> &egrave; impostato, consente 
                        il caricamento via join esterno per questa associazione .
                    </p></td></tr></table></div></div><p>
            Alcuni esempio. Prima di tutto, un insieme di stringhe:
        </p><pre class="programlisting">&lt;set name="names" table="NAMES"&gt;
    &lt;key column="GROUPID"/&gt;
    &lt;element column="NAME" type="string"/&gt;
&lt;/set&gt;</pre><p>
            Un "sacco" (bag) contenente interi (con un ordine di iterazione determinato dall'attributo 
            <tt class="literal">order-by</tt>):
        </p><pre class="programlisting">&lt;bag name="sizes" table="SIZES" order-by="SIZE ASC"&gt;
    &lt;key column="OWNER"/&gt;
    &lt;element column="SIZE" type="integer"/&gt;
&lt;/bag&gt;</pre><p>
            Un array di entit&agrave; - in questo caso un'associazione molti-a-molti (notate che 
            le entit&agrave; vengono gestite nel ciclo di vita dell'entit&agrave; proprietaria, grazie 
            al settaggio <tt class="literal">cascade="all"</tt>):
        </p><pre class="programlisting">&lt;array name="foos" table="BAR_FOOS" cascade="all"&gt;
    &lt;key column="BAR_ID"/&gt;
    &lt;index column="I"/&gt;
    &lt;many-to-many column="FOO_ID" class="org.hibernate.Foo"/&gt;
&lt;/array&gt;</pre><p>
            Una mappa da indici stringa a date:
        </p><pre class="programlisting">&lt;map name="holidays" table="holidays" schema="dbo" order-by="hol_name asc"&gt;
    &lt;key column="id"/&gt;
    &lt;index column="hol_name" type="string"/&gt;
    &lt;element column="hol_date" type="date"/&gt;
&lt;/map&gt;</pre><p>
            Una lista di componenti (discussi nel prossimo capitolo):
        </p><pre class="programlisting">&lt;list name="carComponents" table="car_components"&gt;
    &lt;key column="car_id"/&gt;
    &lt;index column="posn"/&gt;
    &lt;composite-element class="org.hibernate.car.CarComponent"&gt;
            &lt;property name="price" type="float"/&gt;
            &lt;property name="type" type="org.hibernate.car.ComponentType"/&gt;
            &lt;property name="serialNumber" column="serial_no" type="string"/&gt;
    &lt;/composite-element&gt;
&lt;/list&gt;</pre></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-onetomany"></a>6.4.&nbsp;Associazioni uno-a-molti</h2></div></div><div></div></div><p>
            Una <span class="emphasis"><em>associazione uno a molti</em></span> collega <span class="emphasis"><em>direttamente</em></span> le tabelle 
            di due classi, senza che intervenga una apposita tabella di collezione.
            (ci&ograve; corrisponde al modello relazionale <span class="emphasis"><em>uno-a-molti</em></span>.) In questo modello, si perde
            un po' della semantica delle collezioni di Java:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Non &egrave; possibile avere valori null contenuti in una mappa, un insieme o una lista.
                </p></li><li><p>
                    Una istanza dell'entit&agrave; contenuta non pu&ograve; appartenere a pi&ugrave; di una istanza della collezione.
                </p></li><li><p>
                    Una istanza dell'entit&agrave; contenuta non pu&ograve; apparire in corrispondenza di pi&ugrave; di un valore
                    dell'indice di collezione.
                </p></li></ul></div><p>
            Un'associazione da <tt class="literal">Pippo</tt> a <tt class="literal">Pluto</tt> richiede l'aggiunta
            di una colonna chiave, e possibilmente anche di una colonna indice alla tabella della classe
            di entit&agrave; contenuta, <tt class="literal">Pluto</tt>. Queste colonne vengono mappate usando gli elementi
            <tt class="literal">&lt;key&gt;</tt> e <tt class="literal">&lt;index&gt;</tt> gi&agrave; descritti in precedenza.
        </p><p>
            L'etichetta <tt class="literal">&lt;one-to-many&gt;</tt> indica un'associazione uno a molti.
        </p><div class="programlistingco"><pre class="programlisting">&lt;one-to-many class="ClassName"/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">class</tt> (obbligatorio): Il nome della classe associata.
                    </p></td></tr></table></div></div><p>
            Esempio:
        </p><pre class="programlisting">&lt;set name="bars"&gt;
    &lt;key column="foo_id"/&gt;
    &lt;one-to-many class="org.hibernate.Bar"/&gt;
&lt;/set&gt;</pre><p>
            Notate che l'elemento <tt class="literal">&lt;one-to-many&gt;</tt> non ha bisogno di dichiarare 
            alcuna colonna. Non &egrave; neppure necessario specificare il nome della tabella.
        </p><p>
            <span class="emphasis"><em>Nota Molto Importante:</em></span> se la colonna <tt class="literal">&lt;key&gt;</tt>
            di una associazione <tt class="literal">&lt;one-to-many&gt;</tt> viene dichiarata
            <tt class="literal">NOT NULL</tt>, Hibernate pu&ograve; causare violazioni di vincoli quando 
            crea o aggiorna le associazioni. Per prevenire questo problema, 
            <span class="emphasis"><em>dovete usare una associazione bidirezionale</em></span> con l'estremit&agrave; "many" 
            (l'insieme o il sacco) impostati a <tt class="literal">inverse="true"</tt>.
            Per ulteriori informazioni si legga la discussioni sulle associazioni bidirezionali pi&ugrave; 
            avanti in questo capitolo.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-lazy"></a>6.5.&nbsp;Inizializzazione differita (lazy)</h2></div></div><div></div></div><p>
            Le collezioni (a differenza degli array) possono essere inizializzate in maniera
            differita, ovvero possono caricare il proprio stato dal database solo quando 
            l'applicazione ha bisogno di accedervi. L'inizializzazione avviene trasparentemente
            per l'utente, in modo tale che l'applicazione non ha normalmente bisogno di 
            preoccuparssene (in effetti, l'inizializzazione trasparente e differita &egrave; 
            la ragione principale per cui Hibernate ha bisogno di implementazioni proprie 
            delle collezioni). Nonostante ci&ograve;, se l'applicazione tenta di fare qualcosa come
            nel codice seguente:
        </p><pre class="programlisting">s = sessions.openSession();
User u = (User) s.find("from User u where u.name=?", userName, Hibernate.STRING).get(0);
Map permissions = u.getPermissions();
s.connection().commit();
s.close();

Integer accessLevel = (Integer) permissions.get("accounts");  // Error!</pre><p>
            Pu&ograve; ritrovarsi di fronte ad una brutta sorpresa. Poich&eacute; la collezione dei 
            permessi (permissions) non era stata inizializzata quando la 
            <tt class="literal">Session</tt> &egrave; stata committata, la collezione non sar&agrave; mai
            capace di caricare il suo stato. La correzione consiste nel muovere la riga
            che legge dalla collezione subito prima del commit. (In ogni caso ci sono
            altre maniere pi&ugrave; avanzate di risolvere il problema).
        </p><p>
            In alternativa, potete usare una collezione ad inizializzazione non differita.
            Poich&eacute; l'inizializzazione differita pu&ograve; portare a bachi come nel codice precedente,
            la "non-lazyness" (il "non differimento" o, letteralmente, la "non pigrizia") &egrave;
            il comportamento predefinito. Comunque, &egrave; sottinteso che l'inizializzazione differita
            venga usata per quasi tutte le collezioni, in particolar modo per le collezioni di 
            entit&agrave; (per questioni di efficienza).
        </p><p>
            Le eccezioni che accadono mentre si inizializza in maniera differita le collezioni
            sono incapsulate in una <tt class="literal">LazyInitializationException</tt>.
        </p><p>
            Potete dichiarare una collezione differita usando l'attributo opzionale
            <tt class="literal">lazy</tt>:
        </p><pre class="programlisting">&lt;set name="names" table="NAMES" lazy="true"&gt;
    &lt;key column="group_id"/&gt;
    &lt;element column="NAME" type="string"/&gt;
&lt;/set&gt;</pre><p>
            In alcune architetture applicative, in particolare quando il codice che accede ai
            dati con Hibernate e il codice che lo usa sono in differenti livelli applicativi,
            pu&ograve; essere un problema assicurarsi che la <tt class="literal">Session</tt> sia aperta
            quando una collezione viene inizializzata. Ci sono due maniere principali, per 
            trattare questa questione:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    In una applicazione basata sul web, si pu&ograve; usare un "servlet filter" per
                    chiudere la <tt class="literal">Session</tt> solo alla fine della richiesta di
                    un utente, quando la costruzione della vista &egrave; completa. Naturalmente, 
                    questo impone dei vincoli molto importanti sulla correttezza della gestione
                    delle eccezioni nella vostra infrastruttura applicativa. &Egrave; vitalmente 
                    importante che la <tt class="literal">Session</tt> venga chiusa e la transazione
                    conclusa prima di restituire il controllo all'utente, anche quando una
                    eccezione avviene durante la resa della vista. Il servlet filter deve essere
                    in grado di accedere la <tt class="literal">Session</tt> perch&eacute; questo sia possibile.
                    Raccomandiamo l'uso di una variabile <tt class="literal">ThreadLocal</tt> per 
                    mangenere la <tt class="literal">Session</tt> corrente (vedere il capitolo 1,
                    <a href="#quickstart-playingwithcats" title="1.4.&nbsp;Giochiamo con i gatti">Sezione&nbsp;1.4, &#8220;Giochiamo con i gatti&#8221;</a>, per un'implementazione di 
                    esempio).
                </p></li><li><p>
                    In una applicazione con uno strato di business separato, la logica 
                    applicativa deve "preparare" tutte le collezioni che saranno necessarie
                    per lo strato web prima di ritornare. Questo significa che lo strato
                    di business dovrebbe caricare tutti i dati che siano richiesti per un 
                    particolare caso d'uso, e restituirli allo strato web di presentazione 
                    una volta inizializzati . Solitamente, l'applicazione chiama 
                    <tt class="literal">Hibernate.initialize()</tt> per ogni collezione che sar&agrave; 
                    necessaria nello strato web (la chiamata deve avvenire prima che la 
                    sessione venga chiusa), o carica la collezione direttamente usando una
                    query di Hibernate che comprende una clausola <tt class="literal">FETCH</tt>.
                </p></li><li><p>
                    Potete anche attaccare un oggetto caricato precedentemente ad una nuova
                    <tt class="literal">Session</tt> con <tt class="literal">update()</tt> o 
                    <tt class="literal">lock()</tt> prima di accedere a collezioni non inizializzate 
                    (o altri tipi di mediatori). Hibernate non pu&ograve; farlo automaticamente, 
                    perch&eacute; dovrebbe introdurre semantica transazionale ad-hoc!
                </p></li></ul></div><p>
            Potete usare il metodo <tt class="literal">filter()</tt> dell'API della classe Session di 
            Hibernate per ottenere la dimensione di una collezione senza doverla inizializzare:
        </p><pre class="programlisting">( (Integer) s.filter( collection, "select count(*)" ).get(0) ).intValue()</pre><p>
            <tt class="literal">filter()</tt> o <tt class="literal">createFilter()</tt> vengono anche usati
            per caricare efficientemente sottoinsiemi di una collezione senza bisogno di inizializzare
            l'intera collezione.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-sorted"></a>6.6.&nbsp;Collezioni ordinate</h2></div></div><div></div></div><p>
            Hibernate supporta collezioni che implementano <tt class="literal">java.util.SortedMap</tt> 
            e <tt class="literal">java.util.SortedSet</tt>. Dovete specificare esplicitamente un 
            comparatore nel file di mappaggio:
        </p><pre class="programlisting">&lt;set name="aliases" table="person_aliases" sort="natural"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="string"/&gt;
&lt;/set&gt;

&lt;map name="holidays" sort="my.custom.HolidayComparator" lazy="true"&gt;
    &lt;key column="year_id"/&gt;
    &lt;index column="hol_name" type="string"/&gt;
    &lt;element column="hol_date type="date"/&gt;
&lt;/map&gt;</pre><p>
            I valori permessi per l'attributo <tt class="literal">sort</tt> sono
            <tt class="literal">unsorted</tt>, <tt class="literal">natural</tt> e il nome di una classe che
            implementi <tt class="literal">java.util.Comparator</tt>.
        </p><p>
            Le collezioni ordinate si comportano in effetti come 
            <tt class="literal">java.util.TreeSet</tt> o <tt class="literal">java.util.TreeMap</tt>.
        </p><p>
            Se volete che sia il database stesso ad ordinare gli elementi della collezione,
            usate l'attributo <tt class="literal">order-by</tt> dei mappaggi dei <tt class="literal">set</tt>, 
            <tt class="literal">bag</tt> o delle <tt class="literal">map</tt>. Questa soluzione funziona solo
            sotto JDK 1.4 o superiori (&egrave; implementata usando <tt class="literal">LinkedHashSet</tt> o
            <tt class="literal">LinkedHashMap</tt>). Questo fa s&igrave; che l'ordinamento avvenga durante 
            l'esecuzione della query SQL, non in memoria.
        </p><pre class="programlisting">&lt;set name="aliases" table="person_aliases" order-by="name asc"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="string"/&gt;
&lt;/set&gt;

&lt;map name="holidays" order-by="hol_date, hol_name" lazy="true"&gt;
    &lt;key column="year_id"/&gt;
    &lt;index column="hol_name" type="string"/&gt;
    &lt;element column="hol_date type="date"/&gt;
&lt;/map&gt;</pre><p>
            Notate che il valore dell'attributo <tt class="literal">order-by</tt> si riferisce all'SQL, 
            non all'HQL!
        </p><p>
            Le associazioni possono anche venire ordinate usando criteri arbitrari in fase
            di esecuzione usando un <tt class="literal">filter()</tt>.
        </p><pre class="programlisting">sortedUsers = s.filter( group.getUsers(), "order by this.name" );</pre></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-idbag"></a>6.7.&nbsp;<tt class="literal">L'uso degli &lt;idbag&gt;</tt></h2></div></div><div></div></div><p>
            Se avete abbracciato il nostro punto di vista, secondo cui le chiavi composte
            sono una cattiva cosa, e le entit&agrave; dovrebbero avere identificatori sintetici
            (chiavi surrogate), potreste trovare un po' strano che le associazioni 
            molti-a-molti e le collezioni di valori che abbiamo mostrato fin qui, si mappano
            tutte su tabelle con chiavi composte! Ora, questo punto &egrave; abbastanza discutibile;
            una tabella di pura associazione non sembra trarre molto beneficio da una chiave
            surrogata (bench&eacute; una collezione di valori composti <span class="emphasis"><em>potrebbe</em></span>).
            Ciononostante, Hibern ate fornisce una funzionalit&agrave; (lievemente sperimentale),
            che consente di mappare associazioni molti-a-molti e collezioni di valori su una
            tabella con una chiave surrogata.
        </p><p>
            L'elemento <tt class="literal">&lt;idbag&gt;</tt> vi permette di mappare una 
            <tt class="literal">List</tt> (o una <tt class="literal">Collection</tt>) con la semantica del 
            sacco ("bag").
        </p><pre class="programlisting">&lt;idbag name="lovers" table="LOVERS" lazy="true"&gt;
    &lt;collection-id column="ID" type="long"&gt;
        &lt;generator class="hilo"/&gt;
    &lt;/collection-id&gt;
    &lt;key column="PERSON1"/&gt;
    &lt;many-to-many column="PERSON2" class="eg.Person" outer-join="true"/&gt;
&lt;/idbag&gt;</pre><p>
            Come potete vedere, un <tt class="literal">&lt;idbag&gt;</tt> ha un generatore di id
            sintetici essattamente come una classe di entit&agrave;! Una chiave surrogata diversa 
            viene assegnata ad ogni riga della collezione. Hibernate non fornisce alcun meccanismo
            per scoprire la chiave surrogata di una particolare riga, per&ograve;.
        </p><p>
            Notate che le performance in aggiornamento di un <tt class="literal">&lt;idbag&gt;</tt> sono
            <span class="emphasis"><em>molto</em></span> migliori di un <tt class="literal">&lt;bag&gt;</tt> normale!
            Hibernate pu&ograve; individuare chiavi individuali in maniera efficiente, e aggiornare o cancellarle
            individualmente esattamente come in una lista, una mappa o un insieme.
        </p><p>
            Nell'implementazione corrente, la strategia di generazione degli identificatori 
            indicata con <tt class="literal">identity</tt> non viene supportata per gli identificatori
            di collezione <tt class="literal">&lt;idbag&gt;</tt>.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-bidirectional"></a>6.8.&nbsp;Associazioni bidirezionali</h2></div></div><div></div></div><p>
            Una <span class="emphasis"><em>associazione bidirezionale</em></span> consente la navigazione
            da entrambe le estremit&agrave; dell'associazione. Vengono supportati due stili 
            differenti di associazioni bidirezionali:

            </p><div class="variablelist"><dl><dt><span class="term">one-to-many</span></dt><dd><p>
                            un insieme o un sacco ad una estremit&agrave;, un valore singolo dall'altra
                        </p></dd><dt><span class="term">many-to-many</span></dt><dd><p>
                            entrambe le estremit&agrave; sono valorizzate con un set o un sacco
                        </p></dd></dl></div><p>

        </p><p>
            Tenete presente che HIbernate non supporta associazioni bidirezionali uno-a-molti
            con una collezione indicizzata (lista, mappa o array) come estremit&agrave; "molti": dovete
            usare un mappaggio "set" o "bag".
        </p><p>
            Potete specificare una associazione bidirezionale molti-a-molti semplicemente
            mappando due associazioni molti-a-molti sulla stessa tabella di database e 
            dichiarando una estremit&agrave; come <span class="emphasis"><em>inverse</em></span> (decidere quale
            &egrave; una scelta che sta a voi). Ecco un esempio di un'associazione bidirezionale
            molti-a-molti da una classe a se <span class="emphasis"><em>stessa</em></span> (ogni categoria
            pu&ograve; avere molti elementi, ed ogni elemento pu&ograve; essere in molte categorie):
        </p><pre class="programlisting">&lt;class name="org.hibernate.auction.Category"&gt;
    &lt;id name="id" column="ID"/&gt;
    ...
    &lt;bag name="items" table="CATEGORY_ITEM" lazy="true"&gt;
        &lt;key column="CATEGORY_ID"/&gt;
        &lt;many-to-many class="org.hibernate.auction.Item" column="ITEM_ID"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;

&lt;class name="org.hibernate.auction.Item"&gt;
    &lt;id name="id" column="ID"/&gt;
    ...

    &lt;!-- inverse end --&gt;
    &lt;bag name="categories" table="CATEGORY_ITEM" inverse="true" lazy="true"&gt;
        &lt;key column="ITEM_ID"/&gt;
        &lt;many-to-many class="org.hibernate.auction.Category" column="CATEGORY_ID"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;</pre><p>
            Dei cambiamenti fatto esclusivamente all'estremit&agrave; "inversa" dell'associazione 
            <span class="emphasis"><em>non</em></span> vengono resi persistenti. Questo significa che Hibernate
            ha due rappresentazioni in memoria per ogni associazione bidirezionale: un 
            collegamento da A a B e un altro collegamento da B ad A. Questa cosa &egrave; pi&ugrave; facile da comprendere
            se pensate al modello ad oggetti Java e come creiamo una relazione molti-a-molti in Java:
        </p><pre class="programlisting">
category.getItems().add(item);          // La categoria ora "sa" della relazione
item.getCategories().add(category);     // L'elemento ora "sa" della relazione

session.update(item);                     // Nessun effetto, niente verr&agrave; salvato!
session.update(category);                 // La relazione verr&agrave; salvata</pre><p>
            Il lato non-inverso viene usato per salvare la rappresentazione in-memoria sul database.
            Otterremmo un INSERT/UPDATE non necessario e probabilmente anche una violazione di chiave
            esterna se entrambe le estremit&agrave; scatenassero dei cambiamenti! La stessa cosa vale naturalmente
            per le associazioni bidirezionali uno-a-molti.
        </p><p>
            Potete mappare una associazione bidirezionale uno-a-molti mappandola sulle stesse colonne 
            come una associazione molti-a-uno e dichiarando l'estremit&agrave; "molti" come <tt class="literal">inverse="true"</tt>.
        </p><pre class="programlisting">&lt;class name="eg.Parent"&gt;
    &lt;id name="id" column="id"/&gt;
    ....
    &lt;set name="children" inverse="true" lazy="true"&gt;
        &lt;key column="parent_id"/&gt;
        &lt;one-to-many class="eg.Child"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="eg.Child"&gt;
    &lt;id name="id" column="id"/&gt;
    ....
    &lt;many-to-one name="parent" class="eg.Parent" column="parent_id"/&gt;
&lt;/class&gt;</pre><p>
            Mappare una estremit&agrave; di un'associazione con <tt class="literal">inverse="true"</tt> non condiziona
            il funzionamento delle cascate, si tratta di concetti differenti!
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-ternary"></a>6.9.&nbsp;Associazioni ternarie</h2></div></div><div></div></div><p>
            Ci sono due approcci possibili per mappare una associazione ternaria. Uno &egrave; usare elementi
            compositi (discusso pi&ugrave; avanti). Un altro &egrave; di usare una mappa con un'associazione come indice:
        </p><pre class="programlisting">&lt;map name="contracts" lazy="true"&gt;
    &lt;key column="employer_id"/&gt;
    &lt;index-many-to-many column="employee_id" class="Employee"/&gt;
    &lt;one-to-many class="Contract"/&gt;
&lt;/map&gt;</pre><pre class="programlisting">&lt;map name="connections" lazy="true"&gt;
    &lt;key column="node1_id"/&gt;
    &lt;index-many-to-many column="node2_id" class="Node"/&gt;
    &lt;many-to-many column="connection_id" class="Connection"/&gt;
&lt;/map&gt;</pre></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-heterogeneous"></a>6.10.&nbsp;Associazioni eterogenee</h2></div></div><div></div></div><p>
	        Gli elementi <tt class="literal">&lt;many-to-any&gt;</tt> e <tt class="literal">&lt;index-many-to-any&gt;</tt>
	        permettono di utilizzare vere e proprie associazioni eterogenee. Questi elementi di mappaggio
	        funzionano nello stesso modo ini cui funziona l'elemento <tt class="literal">&lt;any&gt;</tt>, e come questo
	        dovrebbero essere usate raramente, se proprio devono esserlo.
	    </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-example"></a>6.11.&nbsp;Esempi di collezioni</h2></div></div><div></div></div><p>
            Le sezioni precedenti sono abbastanza complesse, quindi vediamo un esempio. 
            La classe seguente:
        </p><pre class="programlisting">package eg;
import java.util.Set;

public class Parent {
    private long id;
    private Set children;

    public long getId() { return id; }
    private void setId(long id) { this.id=id; }

    private Set getChildren() { return children; }
    private void setChildren(Set children) { this.children=children; }

    ....
    ....
}</pre><p>
            ha una collezione di istanze di <tt class="literal">eg.Child</tt>. Se ogni figlio
            ha al pi&ugrave; un genitore, il mappaggio pi&ugrave; naturale &egrave; un'associazione uno-a-molti:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="eg.Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" lazy="true"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="eg.Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="eg.Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            Questo si mappa sulle seguenti definizioni di tabella:
        </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null primary key, name varchar(255), parent_id bigint )
alter table child add constraint childfk0 (parent_id) references parent</pre><p>
            Se il genitore &egrave; <span class="emphasis"><em>obbligatorio</em></span>, usate una associazione bidirezionale uno-a-molti:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="eg.Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" inverse="true" lazy="true"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="eg.Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="eg.Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
        &lt;many-to-one name="parent" class="eg.Parent" column="parent_id" not-null="true"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            Notate il vincolo <tt class="literal">NOT NULL</tt>:
        </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null
                     primary key,
                     name varchar(255),
                     parent_id bigint not null )
alter table child add constraint childfk0 (parent_id) references parent</pre><p>
            Dall'altro lato, se un figlio potesse avere genitori multipli, sarebbe appropriata
            una associazione molti-a-molti:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="eg.Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" lazy="true" table="childset"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;many-to-many class="eg.Child" column="child_id"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="eg.Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            Definizioni delle tabelle:
        </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null primary key, name varchar(255) )
create table childset ( parent_id bigint not null,
                        child_id bigint not null,
                        primary key ( parent_id, child_id ) )
alter table childset add constraint childsetfk0 (parent_id) references parent
alter table childset add constraint childsetfk1 (child_id) references child</pre></div></div><div class="chapter" lang="it"><div class="titlepage"><div><div><h2 class="title"><a name="components"></a>Capitolo&nbsp;7.&nbsp;Mappaggio dei componenti</h2></div></div><div></div></div><p>
        La nozione di un <span class="emphasis"><em>componente</em></span> viene usata in differenti contesti per scopi diversi, 
        in tutto Hibernate.
    </p><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-dependentobjects"></a>7.1.&nbsp;Oggetti dipendenti</h2></div></div><div></div></div><p>
            Un componente &egrave; un oggetto contenuto, che viene reso persistente come un tipo di valore ("value type"),
            non un'entit&agrave;. Il termine "componente" si riferisce al concetto "orientato agli oggetti" della composizione
            (non a componenti di livello architetturale). Per esempio, potreste modellare una persona come segue:
        </p><pre class="programlisting">public class Person {
    private java.util.Date birthday;
    private Name name;
    private String key;
    public String getKey() {
        return key;
    }
    private void setKey(String key) {
        this.key=key;
    }
    public java.util.Date getBirthday() {
        return birthday;
    }
    public void setBirthday(java.util.Date birthday) {
        this.birthday = birthday;
    }
    public Name getName() {
        return name;
    }
    public void setName(Name name) {
        this.name = name;
    }
    ......
    ......
}</pre><pre class="programlisting">public class Name {
    char initial;
    String first;
    String last;
    public String getFirst() {
        return first;
    }
    void setFirst(String first) {
        this.first = first;
    }
    public String getLast() {
        return last;
    }
    void setLast(String last) {
        this.last = last;
    }
    public char getInitial() {
        return initial;
    }
    void setInitial(char initial) {
        this.initial = initial;
    }
}</pre><p>
            Ora <tt class="literal">Name</tt> pu&ograve; essere reso persistente come un componente di 
            <tt class="literal">Person</tt>. Notate che <tt class="literal">Name</tt> definisce metodi "getter"
            e "setter" per le sue propriet&agrave; persistenti, ma non deve dichiarare alcuna interfaccia o 
            propriet&agrave; identificatore.
        </p><p>
            Il nostro mappaggio Hibernate avrebbe questo aspetto:
        </p><pre class="programlisting">&lt;class name="eg.Person" table="person"&gt;
    &lt;id name="Key" column="pid" type="string"&gt;
        &lt;generator class="uuid.hex"/&gt;
    &lt;/id&gt;
    &lt;property name="birthday" type="date"/&gt;
    &lt;component name="Name" class="eg.Name"&gt; &lt;!-- l'attributo class &egrave; opzionale --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/component&gt;
&lt;/class&gt;</pre><p>
            La tabella "person" avrebbe le colonne <tt class="literal">pid</tt>,
            <tt class="literal">birthday</tt>,
            <tt class="literal">initial</tt>,
            <tt class="literal">first</tt> e
            <tt class="literal">last</tt>.
        </p><p>
            Come tutti i tipi di valore, i componenti non supportano riferimenti condivisi. 
            La semantica di valore nullo di un componente &egrave; <span class="emphasis"><em>ad hoc</em></span>. Quando si 
            ricarica l'oggetto contenitore, Hibernate supporr&agrave; che se tutte le colonne del componente
            sono nulle, allora l'intero componente &egrave; nullo. Questo dovrebbe adattarsi alla maggior parte
            degli scopi.
        </p><p>
            Le propriet&agrave; di un componente possono essere di un tipo qualunque di Hibernate (collezioni
            associazioni molti-a-uno, altri componenti, ecc.). Componenti annidati <span class="emphasis"><em>non</em></span> 
            dovrebbero essere considerati un utilizzo esotico. Hibernate &egrave; pensato per supportare un 
            modello ad oggetti a grana molto fine.
        </p><p>
            L'elemento <tt class="literal">&lt;component&gt;</tt> consente di usare un sotto-elemento <tt class="literal">&lt;parent&gt;</tt>
            che mappa la propriet&agrave; di una classe componente come un riferimento "indietro" all'entit&agrave; contenitore.
        </p><pre class="programlisting">&lt;class name="eg.Person" table="person"&gt;
    &lt;id name="Key" column="pid" type="string"&gt;
        &lt;generator class="uuid.hex"/&gt;
    &lt;/id&gt;
    &lt;property name="birthday" type="date"/&gt;
    &lt;component name="Name" class="eg.Name"&gt;
        &lt;parent name="namedPerson"/&gt; &lt;!-- retro-riferimento all'oggetto Person --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/component&gt;
&lt;/class&gt;</pre></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-incollections"></a>7.2.&nbsp;Collezioni di oggetti dipendenti</h2></div></div><div></div></div><p>
            Le collezioni di componenti sono permesse (ad esempio un array di 
            tipo <tt class="literal">Name</tt>). Dichiarate le collezioni di componenti
            rimpiazzando l'etichetta <tt class="literal">&lt;element&gt;</tt> con una 
            <tt class="literal">&lt;composite-element&gt;</tt>.
        </p><pre class="programlisting">&lt;set name="someNames" table="some_names" lazy="true"&gt;
    &lt;key column="id"/&gt;
    &lt;composite-element class="eg.Name"&gt; &lt;!-- l'attributo class &egrave; obbligatorio --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/composite-element&gt;
&lt;/set&gt;</pre><p>
            Nota: se definite un <tt class="literal">Set</tt> di elementi composti, &egrave; molto importante
            definire correttamente <tt class="literal">equals()</tt> e 
            <tt class="literal">hashCode()</tt> correctly.
        </p><p>
            Gli elementi composti possono contenere componenti ma non collezioni. Se il 
            vostro elemento composto contiene componenti, usate l'etichetta 
            <tt class="literal">&lt;nested-composite-element&gt;</tt>. Si tratta di un caso abbastanza
            esotico - una collezione di componenti che a loro volta hanno componenti. A questo
            stadio dovreste chiedervi se una associazione uno-a-molti non sia pi&ugrave; appropriata.
            Provate a rimodellare l'elemento composto come una entit&agrave; - ma notate che anche se
            il modello java &egrave; lo stesso, il modello relazionale e la semantica di persistenza
            sono leggermente diversi.
        </p><p>
            Tenete presente che un mappaggio ad elemento composto non supporta propriet&agrave; nulle
            se state usando un <tt class="literal">&lt;set&gt;</tt>. Hibernate deve usare
            ogni colonna per identificare un record quando cancella oggetti (non c'&egrave; 
            una colonna separata di chiave primaria, nella tabella dell'elemento composto), 
            cosa che non &egrave; possibile con valori nulli. In un composite-element dovete usare solo propriet&agrave; 
            non nulle o scegliere una 
            <tt class="literal">&lt;list&gt;</tt>, <tt class="literal">&lt;map&gt;</tt>,
            <tt class="literal">&lt;bag&gt;</tt> o <tt class="literal">&lt;idbag&gt;</tt>.
        </p><p>
            Un caso speciale di elemento composto &egrave; quello in cui l'elemento stesso ha
            un altro elemento annidato <tt class="literal">&lt;many-to-one&gt;</tt>. Un 
            mappaggio di questo tipo, vi consente di mappare colonne extra di una
            tabella molti-a-molti sulla classe dell'elemento composto. Qui di seguito
            mostriamo una associazione molti-a-molti da <tt class="literal">Order</tt> a <tt class="literal">Item</tt> 
            in cui <tt class="literal">purchaseDate</tt>, <tt class="literal">price</tt> e
            <tt class="literal">quantity</tt> sono propriet&agrave; dell'associazione:
        </p><pre class="programlisting">&lt;class name="eg.Order" .... &gt;
    ....
    &lt;set name="purchasedItems" table="purchase_items" lazy="true"&gt;
        &lt;key column="order_id"&gt;
        &lt;composite-element class="eg.Purchase"&gt;
            &lt;property name="purchaseDate"/&gt;
            &lt;property name="price"/&gt;
            &lt;property name="quantity"/&gt;
            &lt;many-to-one name="item" class="eg.Item"/&gt; &lt;!-- l'attributo class &egrave; opzionale --&gt;
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>Sono possibili anche associazioni ternarie (o quaternarie, ecc):</p><pre class="programlisting">&lt;class name="eg.Order" .... &gt;
    ....
    &lt;set name="purchasedItems" table="purchase_items" lazy="true"&gt;
        &lt;key column="order_id"&gt;
        &lt;composite-element class="eg.OrderLine"&gt;
            &lt;many-to-one name="purchaseDetails class="eg.Purchase"/&gt;
            &lt;many-to-one name="item" class="eg.Item"/&gt;
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
            Gli elementi composti possono apparire nelle query usando la stessa
            sintassi delle associazioni ad altre entit&agrave;.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-asmapindex"></a>7.3.&nbsp;Componenti come indici delle mappe</h2></div></div><div></div></div><p>
            L'elemento <tt class="literal">&lt;composite-index&gt;</tt> vi consente di mappare 
            una classe di componente come chiave di una <tt class="literal">Map</tt>. Assicuratevi
            di implementare <tt class="literal">hashCode()</tt> e <tt class="literal">equals()</tt> correttamente
            sulla classe componente, in questo caso.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-compositeid"></a>7.4.&nbsp;Componenti come identificatori composti</h2></div></div><div></div></div><p>
            Potete usare un componente come un identificatore di una classe di entit&agrave;. La vostra classe di 
            componente deve soddisfare alcuni requisiti:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Deve implementare <tt class="literal">java.io.Serializable</tt>.
                </p></li><li><p>
                    Deve re-implementare <tt class="literal">equals()</tt> and
                    <tt class="literal">hashCode()</tt>, consistentemente con la nozione
                    di uguaglianza di chiave sul database.
                </p></li></ul></div><p>
            Non potete usare un  <tt class="literal">IdentifierGenerator</tt> per generare chiavi 
            composte. Al contrario, sar&agrave; l'applicazione che deve assegnare i propri identificatori.
        </p><p>
            Poich&eacute; un identificatore composto deve venire assegnato all'oggetto prima di salvarlo,
            non possiamo usare un "valore non salvato" (<tt class="literal">unsaved-value</tt>) sull'identificatore
            per distinguere tra istanze appena istanziate e istanze salvate in una sessione precedente.
        </p><p>
            Se volete usare <tt class="literal">saveOrUpdate()</tt> o save / update in cascata, 
            potete invece implementare <tt class="literal">Interceptor.isUnsaved()</tt> .
            In alternativa, potete anche impostare l'attributo <tt class="literal">unsaved-value</tt>
            su un elemento <tt class="literal">&lt;version&gt;</tt> (o
            <tt class="literal">&lt;timestamp&gt;</tt>) per specificare il valore che identifica una nuova
            istanza transiente. In questo caso, viene usata la versione dell'entit&agrave; invece dell'identificatore
            (assegnato), e non dovete essere voi ad implementare <tt class="literal">Interceptor.isUnsaved()</tt>.
        </p><p>
            Per dichiarare un identificatore di classe composta, usate l'elemento <tt class="literal">&lt;composite-id&gt;</tt> 
            (con gli stessi attributi ed elementi di <tt class="literal">&lt;component&gt;</tt>) al posto di 
            <tt class="literal">&lt;id&gt;</tt>:
        </p><pre class="programlisting">&lt;class name="eg.Foo" table"FOOS"&gt;
    &lt;composite-id name="compId" class="eg.FooCompositeID"&gt;
        &lt;key-property name="string"/&gt;
        &lt;key-property name="short"/&gt;
        &lt;key-property name="date" column="date_" type="date"/&gt;
    &lt;/composite-id&gt;
    &lt;property name="name"/&gt;
    ....
&lt;/class&gt;</pre><p>
            Ora, qualsiasi chiave esterna verso la tabella <tt class="literal">FOOS</tt> deve necessariamente
            essere composta, e dovete dichiararlo nei vostri mappaggi delle altre classi. Una associazione
            verso <tt class="literal">Foo</tt> verr&agrave; dichiarata in questo modo:
        </p><pre class="programlisting">&lt;many-to-one name="foo" class="eg.Foo"&gt;
&lt;!-- come sempre l'attributo "class" &egrave; opzionale --&gt;
    &lt;column name="foo_string"/&gt;
    &lt;column name="foo_short"/&gt;
    &lt;column name="foo_date"/&gt;
&lt;/many-to-one&gt;</pre><p>
        Questo nuovo elemento <tt class="literal">&lt;column&gt;</tt> viene anche usato dai tipi personalizzati
        multi-colonna. In effetti &egrave; ovunque un'alternativa all'attributo <tt class="literal">column</tt>. Una collezione
        con elementi di tipo <tt class="literal">Foo</tt> utilizzerebbe:
    </p><pre class="programlisting">&lt;set name="foos"&gt;
    &lt;key column="owner_id"/&gt;
    &lt;many-to-many class="eg.Foo"&gt;
        &lt;column name="foo_string"/&gt;
        &lt;column name="foo_short"/&gt;
        &lt;column name="foo_date"/&gt;
    &lt;/many-to-many&gt;
&lt;/set&gt;</pre><p>
            Dall'altro lato, <tt class="literal">&lt;one-to-many&gt;</tt>, non dichiara colonne, come sempre.
        </p><p>
            Se lo stesso <tt class="literal">Foo</tt> contiene collezioni, anch'esse richiederanno una chiave
            esterna composta.
        </p><pre class="programlisting">&lt;class name="eg.Foo"&gt;
    ....
    ....
    &lt;set name="dates" lazy="true"&gt;
        &lt;key&gt;   &lt;!-- la collezione eredita il tipo della chiave composta --&gt;
            &lt;column name="foo_string"/&gt;
            &lt;column name="foo_short"/&gt;
            &lt;column name="foo_date"/&gt;
        &lt;/key&gt;
        &lt;element column="foo_date" type="date"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-dynamic"></a>7.5.&nbsp;Componenti dinamici</h2></div></div><div></div></div><p>
            Potete anche mappare una propriet&agrave; di tipo <tt class="literal">Map</tt>:
        </p><pre class="programlisting">&lt;dynamic-component name="userAttributes"&gt;
    &lt;property name="foo" column="FOO"/&gt;
    &lt;property name="bar" column="BAR"/&gt;
    &lt;many-to-one name="baz" class="eg.Baz" column="BAZ"/&gt;
&lt;/dynamic-component&gt;</pre><p>
            La semantica di un mappaggio <tt class="literal">&lt;dynamic-component&gt;</tt> &egrave; identica a 
            <tt class="literal">&lt;component&gt;</tt>. Il vantaggio di questo tipo di mappaggio &egrave; la 
            capacit&agrave; di determinare le vere propriet&agrave; del bean in fase di messa in esecuzione, 
            semplicemente cambiando il documento di mappaggio. ( &Egrave; anche possibile manipolare in fase
            di esecuzione il documento di mappaggio usando un parser DOM)
        </p></div></div><div class="chapter" lang="it"><div class="titlepage"><div><div><h2 class="title"><a name="inheritance"></a>Capitolo&nbsp;8.&nbsp;Mappaggio di gerarchie di ereditariet&agrave;</h2></div></div><div></div></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="inheritance-strategies"></a>8.1.&nbsp;Le tre strategie</h2></div></div><div></div></div><p>
            Hibernate supporta le tre strategie di base per il mappaggio dell'ereditariet&agrave;.
        </p><div class="itemizedlist"><ul type="disc"><li><p>
            una tabella per un'intera gerarchia di classi
        </p></li><li><p>
            una tabella per ogni sottoclasse
        </p></li><li><p>
            una tabella per ogni classe concreta (con qualche limitazione)
        </p></li></ul></div><p>
            &Egrave; anche possibile utilizzare differenti strategie di mappaggio per rami 
            differenti della stessa gerarchia di ereditariet&agrave;, ma questo scenario &egrave; soggetto 
            alle stesse limitazioni dei mappaggi "una tabella per ogni classe 
            concreta" (che vedremo nel seguito). Hibernate non supporta 
            la possibilit&agrave; di mischiare mappaggi <tt class="literal">&lt;subclass&gt;</tt> e
            <tt class="literal">&lt;joined-subclass&gt;</tt> nello stesso elemento 
            <tt class="literal">&lt;class&gt;</tt>.
        </p><p>
            Immaginiamo di avere un'interfaccia <tt class="literal">Payment</tt>, con le seguenti classi
            che la implementino: <tt class="literal">CreditCardPayment</tt>, <tt class="literal">CashPayment</tt>,
            <tt class="literal">ChequePayment</tt>. Il mappaggio a "una tabella per gerarchia" apparirebbe
            cos&igrave;:
        </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        ...
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
            &Egrave; quindi necessaria esattamente una tabella. C'&egrave; una importante
            limitazione in questa strategia di mappaggio: le colonne dichiarate
            dalle sottoclassi non possono avere vincoli <tt class="literal">NOT NULL</tt>.
        </p><p>
            Il mappaggio a "una tabella per sottoclasse" apparirebbe cos&igrave;:
        </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;joined-subclass name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/subclass&gt;
    &lt;joined-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/subclass&gt;
    &lt;joined-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
            Sono quindi richieste quattro tabelle. Le tre tabelle di sottoclasse
            hanno associazioni di chiave primaria con la tabella di superclasse 
            (cosicch&eacute; il modello relazionale &egrave; in realt&agrave; una associazione uno-a-uno).
        </p><p>
            &Egrave; importante notare che l'implementazione di Hibernate della strategia
            "una tabella per sottoclasse" non richiede una colonna discriminatore.
            Altri sistemi di mappaggio oggetto/relazione usano una implementazione
            differente di questa strategia, che richiede una colonna di discriminazione
            del tipo nella tabella della superclasse. L'approccio assunto da Hibernate &egrave; 
            molto pi&ugrave; difficile da implementare, ma pi&ugrave; corretto da un punto di vista
            relazionale.
        </p><p>
            Per ognuna di queste strategie di mappaggio, una associazione 
            polimorfica a <tt class="literal">Payment</tt> viene mappata usando
            <tt class="literal">&lt;many-to-one&gt;</tt>.
        </p><pre class="programlisting">&lt;many-to-one name="payment"
    column="PAYMENT"
    class="Payment"/&gt;</pre><p>La strategia "una tabella per classe concreta" &egrave; molto differente.</p><pre class="programlisting">&lt;class name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CREDIT_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CREDIT_AMOUNT"/&gt;
    ...
&lt;/class&gt;

&lt;class name="CashPayment" table="CASH_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CASH_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CASH_AMOUNT"/&gt;
    ...
&lt;/class&gt;

&lt;class name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CHEQUE_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CHEQUE_AMOUNT"/&gt;
    ...
&lt;/class&gt;</pre><p>
            Sono state necessarie tre tabelle. Si noti che non menzioniamo
            esplicitamente da nessuna parte l'interfaccia <tt class="literal">Payment</tt>.
            Invece, usiamo il <span class="emphasis"><em>polimorfismo implicito</em></span> di Hibernate. 
            Notate anche che le propriet&agrave; di <tt class="literal">Payment</tt> sono state mappate
            in ognuna delle sue sottoclassi.
        </p><p>
            In questo caso, una associazione polimorfica a <tt class="literal">Payment</tt>
            viene mappata usando <tt class="literal">&lt;any&gt;</tt>.
        </p><pre class="programlisting">&lt;any name="payment"
        meta-type="class"
        id-type="long"&gt;
    &lt;column name="PAYMENT_CLASS"/&gt;
    &lt;column name="PAYMENT_ID"/&gt;
&lt;/any&gt;</pre><p>
            Sarebbe meglio se definissimo uno <tt class="literal">UserType</tt>
            come <tt class="literal">meta-tipo</tt>, per gestire il mappaggio dalle 
            stringhe di discriminazione verso la sottoclasse di <tt class="literal">Payment</tt>.
        </p><pre class="programlisting">&lt;any name="payment"
        meta-type="PaymentMetaType"
        id-type="long"&gt;
    &lt;column name="PAYMENT_TYPE"/&gt; &lt;!-- CREDIT, CASH or CHEQUE --&gt;
    &lt;column name="PAYMENT_ID"/&gt;
&lt;/any&gt;</pre><p>
            C'&egrave; ancora una cosa da considerare riguardo a questo mappaggio.
            Poich&eacute; le sottoclassi sono mappate ognuna nel proprio elemento
            <tt class="literal">&lt;class&gt;</tt> (e poich&eacute;
            <tt class="literal">Payment</tt> &egrave; solo un'interfaccia), ognuna delle
            sottoclassi potrebbe essere parte di un'altra gerarchia di ereditariet&agrave; di 
            tipo "tabella per classe" o "tabella per sottoclasse"! (Ed &egrave; comunque 
            possibile lanciare interrogazioni polimorfiche sull'interfaccia
            <tt class="literal">Payment</tt>).
       </p><pre class="programlisting">&lt;class name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CREDIT_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="CREDIT_CARD" type="string"/&gt;
    &lt;property name="amount" column="CREDIT_AMOUNT"/&gt;
    ...
    &lt;subclass name="MasterCardPayment" discriminator-value="MDC"/&gt;
    &lt;subclass name="VisaPayment" discriminator-value="VISA"/&gt;
&lt;/class&gt;

&lt;class name="NonelectronicTransaction" table="NONELECTRONIC_TXN"&gt;
    &lt;id name="id" type="long" column="TXN_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    ...
    &lt;joined-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="amount" column="CASH_AMOUNT"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="amount" column="CHEQUE_AMOUNT"/&gt;
        ...
    &lt;/joined-subclass&gt;
&lt;/class&gt;</pre><p>
            Anche in questo caso non menzioniamo <tt class="literal">Payment</tt> esplicitamente. 
            Se eseguiamo un'interrogazione sull'interfaccia <tt class="literal">Payment</tt>  - ad
            esempio, <tt class="literal">from Payment</tt> - Hibernate
            resistuisce automaticamente istanze di <tt class="literal">CreditCardPayment</tt>
            (e delle sue sottoclassi, poich&eacute; anch'esse implementano <tt class="literal">Payment</tt>),
            <tt class="literal">CashPayment</tt> e <tt class="literal">ChequePayment</tt> ma non istanze di 
            <tt class="literal">NonelectronicTransaction</tt>.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="inheritance-limitations"></a>8.2.&nbsp;Limitazioni</h2></div></div><div></div></div><p>
            Hibernate assume che un'associazione corrisponda esattamente ad una colonna di 
            chiave esterna. Associazioni multiple per chiave esterna sono tollerate (potete
            avere bisogno di specificare <tt class="literal">inverse="true"</tt> o 
            <tt class="literal">insert="false" update="false"</tt>),
            ma non c'&egrave; modo di mappare una associazione a pi&ugrave; chiavi esterne.
            Questo significa che:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
            quando un'associazione viene modificata, &egrave; sempre la stessa chiave esterna che 
            viene aggiornata
        </p></li><li><p>
            quando un'associazione &egrave; risolta in maniera differita ("fetched lazily"), 
            viene usata una singola interrogazione sulla base di dati
        </p></li><li><p>
            quando un'associazione &egrave; risolta in maniera immediata ("fetched eagerly"), 
            pu&ograve; venire risolta usando una singola join esterna
        </p></li></ul></div><p>
            In particolare, questo implica che le associazioni polimorfiche uno-a-molti
            verso classi mappate usando la strategia "tabella per classe concreta"
            <span class="emphasis"><em>non sono supportate</em></span>. (Risolvere queste associazioni 
            implicherebbe effettuare interrogazioni o join multiple.)
        </p><p>
            La tabella seguente mostra le limitazioni dei mappaggi a "tabella per 
            classe concreta" e del polimorfismo implicito in Hibernate.
        </p><div class="table"><a name="d0e5662"></a><p class="title"><b>Tabella&nbsp;8.1.&nbsp;Funzionalit&agrave; dei mappaggi di ereditariet&agrave;</b></p><table summary="Funzionalit&agrave; dei mappaggi di ereditariet&agrave;" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Strategia di ereditariet&agrave;</th><th align="left">Molti-a-uno polimorfico</th><th align="left">Uno-a-uno polimorfico</th><th align="left">Uno-a-molti polimorfico</th><th align="left">Molti-a-molti polimorfico</th><th align="left"><tt class="literal">load()/get()</tt> polimorfiche</th><th align="left">Interrogazioni polimorfiche</th><th align="left">Join polimorfici</th><th align="left">Risoluzione con join esterna</th></tr></thead><tbody><tr><td align="left">"tabella per gerarchia"</td><td align="left"><tt class="literal">&lt;many-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-many&gt;</tt></td><td align="left"><tt class="literal">&lt;many-to-many&gt;</tt></td><td align="left"><tt class="literal">s.get(Payment.class, id)</tt></td><td align="left"><tt class="literal">from Payment p</tt></td><td align="left"><tt class="literal">from Order o join o.payment p</tt></td><td align="left"><span class="emphasis"><em>supportata</em></span></td></tr><tr><td align="left">"tabella per sottoclasse"</td><td align="left"><tt class="literal">&lt;many-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-many&gt;</tt></td><td align="left"><tt class="literal">&lt;many-to-many&gt;</tt></td><td align="left"><tt class="literal">s.get(Payment.class, id)</tt></td><td align="left"><tt class="literal">from Payment p</tt></td><td align="left"><tt class="literal">from Order o join o.payment p</tt></td><td align="left"><span class="emphasis"><em>supportata</em></span></td></tr><tr><td align="left">"tabella per classe concreta" (polimorfismo implicito)</td><td align="left"><tt class="literal">&lt;any&gt;</tt></td><td align="left"><span class="emphasis"><em>non supportata</em></span></td><td align="left"><span class="emphasis"><em>non supportata</em></span></td><td align="left"><tt class="literal">&lt;many-to-any&gt;</tt></td><td align="left"><span class="emphasis"><em>usando una query</em></span></td><td align="left"><tt class="literal">from Payment p</tt></td><td align="left"><span class="emphasis"><em>non supportata</em></span></td><td align="left"><span class="emphasis"><em>non supportata</em></span></td></tr></tbody></table></div></div></div><div class="chapter" lang="it"><div class="titlepage"><div><div><h2 class="title"><a name="manipulatingdata"></a>Capitolo&nbsp;9.&nbsp;Lavorare con i dati persistenti</h2></div></div><div></div></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-creating"></a>9.1.&nbsp;Creazione di un oggetto persistente</h2></div></div><div></div></div><p>
            Un oggetto (istanza di entit&agrave;) &egrave; <span class="emphasis"><em>transiente</em></span> o
            <span class="emphasis"><em>persistente</em></span> rispetto ad una particolare 
            <tt class="literal">sessione (Session)</tt>. Oggetti appena istanziati sono naturalmente
            transienti. La sessione offre servizi per salvare (cio&egrave; rendere persistenti, o "persistere")
            istanze transienti:
        </p><pre class="programlisting">DomesticCat fritz = new DomesticCat();
fritz.setColor(Color.GINGER);
fritz.setSex('M');
fritz.setName("Fritz");
Long generatedId = (Long) sess.save(fritz);</pre><pre class="programlisting">DomesticCat pk = new DomesticCat();
pk.setColor(Color.TABBY);
pk.setSex('F');
pk.setName("PK");
pk.setKittens( new HashSet() );
pk.addKitten(fritz);
sess.save( pk, new Long(1234) );</pre><p>
            Il metodo <tt class="literal">save()</tt> con un solo argomento genera e assegna un 
            identificatore unico a <tt class="literal">fritz</tt>. La forma con due argomenti tenta di 
            rendere persistente <tt class="literal">pk</tt> utilizzando l'identificatore fornito. In generale
            scoraggiamo l'uso della forma con due argomenti perch&eacute; pu&ograve; essere usata per creare chiavi primarie
            con un significato "di business" (ovvero legato in qualche modo al dominio applicativo). &Egrave; 
            pi&ugrave; utile in certe situazioni speciali come quando si usa Hibernate per persistere 
            un bean di entit&agrave; ("entity bean") di tipo BMP ("bean managed persistence").
        </p><p>
            Gli oggetti associati possono essere resi persistenti in un ordine qualunque, a meno che
            abbiate un vincolo <tt class="literal">NOT NULL</tt> su una colonna di chiave esterna. Non c'&egrave; 
            rischio di violare vincoli di chiave esterna, per&ograve; potreste violare un vincolo
            <tt class="literal">NOT NULL</tt> se salvate (<tt class="literal">save()</tt>) gli oggetti nell'ordine
            sbagliato. 
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-loading"></a>9.2.&nbsp;Caricamento di un oggetto</h2></div></div><div></div></div><p>
            I metodi <tt class="literal">load()</tt> della <tt class="literal">Session</tt> vi danno un modo
            per recuperare un'istanza persistente se gi&agrave; conoscete il suo identificatore. Una prima
            versione del metodo riceve un oggetto di tipo "class" e caricher&agrave; lo stato in un oggetto nuovo.
            La seconda versione consente di fornire un'istanza in cui verr&agrave; caricato lo stato.
            La forma che riceve un'istanza &egrave; particolarmente utile se progettate di usare 
            Hibernate con bean di entit&agrave; BMP ed &egrave; fornita esattamente per questa ragione. Potete
            comunque scoprire altri usi (pooling di istanza fatto in casa, ecc.).
        </p><pre class="programlisting">Cat fritz = (Cat) sess.load(Cat.class, generatedId);</pre><pre class="programlisting">// bisogna incapsulare gli identificatori primitivi
long pkId = 1234;
DomesticCat pk = (DomesticCat) sess.load( Cat.class, new Long(pkId) );</pre><pre class="programlisting">Cat cat = new DomesticCat();
// load pk's state into cat
sess.load( cat, new Long(pkId) );
Set kittens = cat.getKittens();</pre><p>
            Notate che <tt class="literal">load()</tt> lancer&agrave; un'eccezione non recuperabile se non c'&egrave; una riga
            di database corrispondente. Se la classe &egrave; mappata con un mediatore (proxy), <tt class="literal">load()</tt> 
            restituisce un oggetto che &egrave; un mediatore non inizializzato e non tocca realmente il database finch&eacute; 
            non viene invocato un metodo dell'oggetto. Questo comportamento &egrave; molto utile se volete creare 
            un'associazione ad un oggetto senza realmente caricarlo dal database.
        </p><p>
            Se non siete certi che una riga corrispondente esista, dovreste usare il metodo <tt class="literal">get()</tt>, 
            che va direttamente sul database e ritorna null se la riga non esiste.
        </p><pre class="programlisting">Cat cat = (Cat) sess.get(Cat.class, id);
if (cat==null) {
    cat = new Cat();
    sess.save(cat, id);
}
return cat;</pre><p>
            Potete anche caricare un oggetto usando una istruzione SQL <tt class="literal">SELECT ... FOR UPDATE</tt>. 
            Leggete la prossima sezione per una discussione dei <tt class="literal">LockMode</tt> (modalit&agrave; di locking)
            di Hibernate.
        </p><pre class="programlisting">Cat cat = (Cat) sess.get(Cat.class, id, LockMode.UPGRADE);</pre><p>
            Notate che ogni istanza associata o le collezioni contenute <span class="emphasis"><em>non</em></span> vengono
            caricate con una select <tt class="literal">FOR UPDATE</tt>.
        </p><p>
            &Egrave; possibile ricaricare un oggetto e tutte le sue collezioni in qualsiasi momento, usando il 
            metodo <tt class="literal">refresh()</tt>. &Egrave; una cosa particolarmente utile quando dei trigger del 
            database vengono usati per inizializzare alcune propriet&agrave; dell'oggetto.
        </p><pre class="programlisting">sess.save(cat);
sess.flush(); //forza l'INSERT SQL
sess.refresh(cat); //rilegge lo stato (dopo che il trigger si esegue)</pre></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-querying"></a>9.3.&nbsp;Interrogazioni</h2></div></div><div></div></div><p>
            Se non conoscete l'identificatore (o gli identificatori) deli oggetti che state cercando, usate
            i metodi <tt class="literal">find()</tt> di <tt class="literal">Session</tt>. Hibernate supporta un linguaggio
            di interrogazione orientato agli oggetti semplice ma potente.
        </p><pre class="programlisting">List cats = sess.find(
    "from Cat as cat where cat.birthdate = ?",
    date,
    Hibernate.DATE
);

List mates = sess.find(
    "select mate from Cat as cat join cat.mate as mate " +
    "where cat.name = ?",
    name,
    Hibernate.STRING
);

List cats = sess.find( "from Cat as cat where cat.mate.bithdate is null" );

List moreCats = sess.find(
    "from Cat as cat where " + 
    "cat.name = 'Fritz' or cat.id = ? or cat.id = ?",
    new Object[] { id1, id2 },
    new Type[] { Hibernate.LONG, Hibernate.LONG }
);

List mates = sess.find(
    "from Cat as cat where cat.mate = ?",
    izi,
    Hibernate.entity(Cat.class)
);

List problems = sess.find(
    "from GoldFish as fish " +
    "where fish.birthday &gt; fish.deceased or fish.birthday is null"
);</pre><p>
            Il secondo argomento del metodo <tt class="literal">find()</tt> riceve un oggetto o 
            un array di oggetti. Il terzo argomento accetta un tipo di Hibernate o un 
            array di tipi. Questi tipi vengono usati per collegare gli oggetti dati ai 
            segnaposto <tt class="literal">?</tt> nelle query JDBC (che a loro volta si mappano su 
            parametri IN di un <tt class="literal">PreparedStatement</tt>). Cos&igrave; come nel 
            JDBC, dovreste usare questo meccanismo di associazione preferibilmente alla
            manipolazione delle stringhe.
        </p><p>
            La classe <tt class="literal">Hibernate</tt> definisce un certo numero di metodi
            statici e costanti che forniscono accesso alla maggior parte dei tipi 
            predefiniti, sotto forma di istanze della classe 
            <tt class="literal">net.sf.hibernate.type.Type</tt>.
        </p><p>
            Se vi aspettate che la vostra query restituisca un numero di oggetti molto
            largo, ma non vi aspettate di usarli tutti, potreste ottenere performance
            migliori dai metodi <tt class="literal">iterate()</tt>, che restituiscono un 
            <tt class="literal">java.util.Iterator</tt>. L'iteratore caricher&agrave; oggetti al 
            bisogno, usando gli identificatori restituiti da una query SQL iniziale
            (facendo n+1 select totali).
        </p><pre class="programlisting">// caricamento degli id
Iterator iter = sess.iterate("from eg.Qux q order by q.likeliness"); 
while ( iter.hasNext() ) {
    Qux qux = (Qux) iter.next();  // reperimento dell'oggetto
    // qualcosa che non abbiamo potuto esprimere nella query
    if ( qux.calculateComplicatedAlgorithm() ) {
        // cancellazione dell'istanza corrente
        iter.remove();
        // non abbiamo bisogno di gestire il resto
        break;
    }
}</pre><p>
            Sfortunatamente, <tt class="literal">java.util.Iterator</tt> non dichiara
            eccezioni, cos&igrave; qualsiasi eccezione SQL o di Hibernate che capiti 
            viene incapsulata in una <tt class="literal">LazyInitializationException</tt> 
            (una sottoclasse di <tt class="literal">RuntimeException</tt>).
        </p><p>
            Il metodo <tt class="literal">iterate()</tt> ottiene performance migliori 
            anche nel caso in cui ci si aspetti che molti oggetti siano gi&agrave; stati caricati e 
            messi in cache dalla sessione, o se i risultati della query ottengono 
            molte volte gli stessi oggetti. (Quando non ci sono dati in cache o 
            dati ripetuti, <tt class="literal">find()</tt> &egrave; quasi sempre pi&ugrave; veloce.)
            Ecco un esempio di un'interrogazione che dovrebbe venire chiamata
            usando <tt class="literal">iterate()</tt>:
        </p><pre class="programlisting">
Iterator iter = sess.iterate(
    "select customer, product " + 
    "from Customer customer, " +
    "Product product " +
    "join customer.purchases purchase " +
    "where product = purchase.product"
);</pre><p>
            Se chiamassimo l'interrogazione precedente usando <tt class="literal">find()</tt> restituiremmo 
            un <tt class="literal">ResultSet</tt> JDBC molto ampio che conterrebbe gli stessi dati molte volte.
        </p><p>
            Le query di Hibernate a volte restituiscono tuple di oggetti, nel qual caso ogni tupla viene
            restituita come un array:
        </p><pre class="programlisting">Iterator foosAndBars = sess.iterate(
    "select foo, bar from Foo foo, Bar bar " +
    "where bar.date = foo.date"
);
while ( foosAndBars.hasNext() ) {
    Object[] tuple = (Object[]) foosAndBars.next();
    Foo foo = tuple[0]; Bar bar = tuple[1];
    ....
}</pre><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-scalarqueries"></a>9.3.1.&nbsp;Interrogazioni scalari</h3></div></div><div></div></div><p>
                Le interrogazioni possono specificare una propriet&agrave; di una classe nella clausola
                <tt class="literal">select</tt>. Possono anche chiamare funzioni aggregate SQL. Le propriet&agrave;
                o gli aggregati sono considerati risultati "scalari".
            </p><pre class="programlisting">Iterator results = sess.iterate(
        "select cat.color, min(cat.birthdate), count(cat) from Cat cat " +
        "group by cat.color"
);
while ( results.hasNext() ) {
    Object[] row = results.next();
    Color type = (Color) row[0];
    Date oldest = (Date) row[1];
    Integer count = (Integer) row[2];
    .....
}</pre><pre class="programlisting">Iterator iter = sess.iterate(
    "select cat.type, cat.birthdate, cat.name from DomesticCat cat"
);</pre><pre class="programlisting">List list = sess.find(
    "select cat, cat.mate.name from DomesticCat cat"
);</pre></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-queryinterface"></a>9.3.2.&nbsp;L'interfaccia Query</h3></div></div><div></div></div><p>
                Se avete bisogno di specificare limiti per il vostro set di risultati
                (il numero massimo di righe che volete recuperare o la prima riga che volete
                caricare) dovreste ottenere un'istanza di <tt class="literal">net.sf.hibernate.Query</tt>:
            </p><pre class="programlisting">Query q = sess.createQuery("from DomesticCat cat");
q.setFirstResult(20);
q.setMaxResults(10);
List cats = q.list();</pre><p>
                Potete anche definire una query con un nome nel documento di mappaggio. 
                (Ricordatevi di usare una sezione <tt class="literal">CDATA</tt> se la vostra
                query contiene caratteri che potrebbero essere interpretati come caratteri
                di contrassegno.)
            </p><pre class="programlisting">&lt;query name="eg.DomesticCat.by.name.and.minimum.weight"&gt;&lt;![CDATA[
    from eg.DomesticCat as cat
        where cat.name = ?
        and cat.weight &gt; ?
] ]&gt;&lt;/query&gt;</pre><pre class="programlisting">Query q = sess.getNamedQuery("eg.DomesticCat.by.name.and.minimum.weight");
q.setString(0, name);
q.setInt(1, minWeight);
List cats = q.list();</pre><p>
                L'interfaccia Query supporta l'utilizzo di parametri per nome. I parametri per nome sono identificatori
                nella forma <tt class="literal">:name</tt> nella stringa di interrogazione. Ci sono metodi su 
                <tt class="literal">Query</tt> per collegare valori ai parametri per nome o ai parametri <tt class="literal">?</tt> 
                nello stile di JDBC. <span class="emphasis"><em>Contrariamente a JDBC, Hibernate numera i parametri a partire da zero.</em></span> 
                I vantaggi dei parametri per nome sono:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        i parametri per nome non hanno dipendenza dall'ordine con cui appaiono nella stringa di 
                        interrogazione
                    </p></li><li><p>
                        possono apparire pi&ugrave; volte nella stessa query
                    </p></li><li><p>
                        sono auto-documentanti
                    </p></li></ul></div><pre class="programlisting">//parametro per nome (consigliato)
Query q = sess.createQuery("from DomesticCat cat where cat.name = :name");
q.setString("name", "Fritz");
Iterator cats = q.iterate();</pre><pre class="programlisting">//parametro posizionale
Query q = sess.createQuery("from DomesticCat cat where cat.name = ?");
q.setString(0, "Izi");
Iterator cats = q.iterate();</pre><pre class="programlisting">//lista di parametri con nome
List names = new ArrayList();
names.add("Izi");
names.add("Fritz");
Query q = sess.createQuery("from DomesticCat cat where cat.name in (:namesList)");
q.setParameterList("namesList", names);
List cats = q.list();</pre></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-scrolling"></a>9.3.3.&nbsp;Iterazioni scrollabili</h3></div></div><div></div></div><p>
                Se il vostro driver JDBC supporta i <tt class="literal">ResultSet</tt> scrollabili, l'interfaccia
                <tt class="literal">Query</tt> pu&ograve; essere usata per ottenere un oggetto <tt class="literal">ScrollableResults</tt> 
                che consente una navigazione pi&ugrave; flessibile dei risultati dell'interrogazione.
            </p><pre class="programlisting">Query q = sess.createQuery("select cat.name, cat from DomesticCat cat " +
                            "order by cat.name");
ScrollableResults cats = q.scroll();
if ( cats.first() ) {

    // trova il primo nome su ogni pagina di una lista alfabetica di gatti per nome
    firstNamesOfPages = new ArrayList();
    do {
        String name = cats.getString(0);
        firstNamesOfPages.add(name);
    }
    while ( cats.scroll(PAGE_SIZE) );

    // ora recuperiamo la prima pagina di gatti
    pageOfCats = new ArrayList();
    cats.beforeFirst();
    int i=0;
    while( ( PAGE_SIZE &gt; i++ ) &amp;&amp; cats.next() ) pageOfCats.add( cats.get(1) );

}</pre><p>
                Il comportamento del metodo <tt class="literal">scroll()</tt> &egrave; simile ad <tt class="literal">iterate()</tt>, eccettuato
                il fatto che gli oggetti possono essere inizializzati selettivamente da <tt class="literal">get(int)</tt>, 
                invece di essere inizializzati uno ad uno a righe intere.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-filtering"></a>9.3.4.&nbsp;Filtraggio delle collezioni</h3></div></div><div></div></div><p>
                Un <span class="emphasis"><em>filtro</em></span> di collezione &egrave; un tipo speciale di interrogazione che pu&ograve; essere
                applicato ad una collezione persistente od un array. La stringa di interrogazione pu&ograve; fare 
                riferimento a <tt class="literal">this</tt>, per indicare l'elemento corrente della collezione.
            </p><pre class="programlisting">Collection blackKittens = session.filter(
    pk.getKittens(), "where this.color = ?", Color.BLACK, Hibernate.enum(Color.class)
);</pre><p>
                La collezione restituita viene considerata un "sacco" (bag).
            </p><p>
                Osservate che i filtri non richiedono una clausola <tt class="literal">from</tt> 
                (bench&eacute; possano averne una, se &egrave; necessario). I filtri non si limitano a 
                restituire gli elementi stessi delle collezioni.
            </p><pre class="programlisting">Collection blackKittenMates = session.filter(
    pk.getKittens(), "select this.mate where this.color = eg.Color.BLACK"
);</pre></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-criteria"></a>9.3.5.&nbsp;Interrogazioni per criteri</h3></div></div><div></div></div><p>
                L'HQL &egrave; molto potente, ma alcune persone preferiscono costruire dinamicamente le 
                interrogazioni, usando un'API orientata agli oggetti, piuttosto che inserire 
                stringhe nel loro codice Java. Per queste persone, Hibernate fornisce una API di 
                interrogazione intuitiva per criteri (<tt class="literal">Criteria</tt>).
            </p><pre class="programlisting">Criteria crit = session.createCriteria(Cat.class);
crit.add( Expression.eq("color", eg.Color.BLACK) );
crit.setMaxResults(10);
List cats = crit.list();</pre><p>
                Se non avete familiarit&agrave; con le sintassi "simil-SQL", questa &egrave; forse la maniera 
                pi&ugrave; semplice di approcciare Hibernate. Questa API &egrave; poi anche pi&ugrave; estensibile dell'SQL: le 
                applicazioni potrebbero fornire le loro implementazioni dell'interfaccia
                <tt class="literal">Criterion</tt>.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-nativesql"></a>9.3.6.&nbsp;Interrogazioni in SQL nativo</h3></div></div><div></div></div><p>
                &Egrave; possibile esprimere una query in SQL, usando <tt class="literal">createSQLQuery()</tt>. 
                Dovete circondare gli alias SQL di parentesi graffe.
            </p><pre class="programlisting">List cats = session.createSQLQuery(
    "SELECT {cat.*} FROM CAT AS {cat} WHERE ROWNUM&lt;10", 
    "cat",
    Cat.class
).list();</pre><pre class="programlisting">List cats = session.createSQLQuery(
    "SELECT {cat}.ID AS {cat.id}, {cat}.SEX AS {cat.sex}, " +
           "{cat}.MATE AS {cat.mate}, {cat}.SUBCLASS AS {cat.class}, ... " +
    "FROM CAT AS {cat} WHERE ROWNUM&lt;10", 
    "cat",
    Cat.class
).list()</pre><p>
                Le interrogazioni SQL possono contenere parametri per nome e posizionali, proprio come
                quelle di Hibernate.
            </p></div></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-updating"></a>9.4.&nbsp;Aggiornamento degli oggetti</h2></div></div><div></div></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-updating-insession"></a>9.4.1.&nbsp;Aggiornamento nella stessa Session</h3></div></div><div></div></div><p>
                <span class="emphasis"><em>Le istanze persistenti e transazionali</em></span> (cio&egrave; gli oggetti 
                caricati, salvati, creati o interrogati dalla <tt class="literal">Session</tt>) possono 
                venire manipolati dall'applicazione, ed ogni cambiamento allo stato persistente
                verr&agrave; salvato quando la <tt class="literal">Session</tt> viene scaricata 
                (<span class="emphasis"><em>flushed</em></span>) (questo concetto &egrave; discusso pi&ugrave; oltre in questo 
                stesso capitolo). Quindi, la maniera pi&ugrave; semplice di aggiornare lo stato di un 
                oggetto &egrave; di caricarlo (<tt class="literal">load()</tt>), e poi manipolarlo direttamente
                mentre la <tt class="literal">Session</tt> &egrave; aperta:
            </p><pre class="programlisting">DomesticCat cat = (DomesticCat) sess.load( Cat.class, new Long(69) );
cat.setName("PK");
sess.flush();  // i cambiamenti all'oggetto gatto vengono automaticamente 
	       // individuati e resi persistenti</pre><p>
                Alcune volte questo modello di programmazione &egrave; inefficiente, poich&eacute; richiederebbe
                sia una <tt class="literal">SELECT</tt> SQL (per caricare un oggetto) sia una 
                <tt class="literal">UPDATE</tt> (per rendere persistente il suo stato aggiornato) nella 
                stessa sessione. Per questo, Hibernate offre un approccio alternativo.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-updating-detached"></a>9.4.2.&nbsp;Aggiornamento di oggetti sganciati</h3></div></div><div></div></div><p>
                Molte applicazioni hanno bisogno di recuperare un oggetto in una transazione,
                mandarlo allo strato di interfaccia perch&eacute; venga manipolato, e poi salvarne
                i cambiamenti in una nuova transazione. (Le applicazioni che usano questo genere
                di approccio in un ambiente ad alta concorrenza solitamente usano dati versionati per 
                assicurare l'isolamento delle transazioni.) Questo approccio richiede un modello
                programmativo leggermente differente rispetto a quello descritto nell'ultima sezione. 
                Hibernate supporta questo modello fornendo il metodo
                <tt class="literal">Session.update()</tt>.
            </p><pre class="programlisting">// nella prima sessione
Cat cat = (Cat) firstSession.load(Cat.class, catId);
Cat potentialMate = new Cat();
firstSession.save(potentialMate);

// in uno strato pi&ugrave; elevato dell'applicazione
cat.setMate(potentialMate);

// pi&ugrave; tardi, in un'altra sessione
secondSession.update(cat);  // aggiornamento del gatto (cat)
secondSession.update(mate); // aggiornamento dell'amichetto (mate)</pre><p>
                Se l'oggetto <tt class="literal">Cat</tt> con identificatore <tt class="literal">catId</tt> fosse gi&agrave; stato 
                caricato da <tt class="literal">secondSession</tt> quando l'applicazione tenta di aggiornarlo, 
                verrebbe lanciata un'eccezione.
            </p><p>
                L'applicazione dovrebbe aggiornare (<tt class="literal">update()</tt>) istanze transienti 
                raggiungibili dall'istanza transiente data se e <span class="emphasis"><em>solo</em></span> se vuole 
                che anche il loro stato venga aggiornato. (Eccetto per gli oggetti a ciclo di vita, 
                discussi pi&ugrave; avanti).
            </p><p>
                Gli utenti di Hibernate hanno chiesto un metodo di scopo generale che salvi un'istanza
                transiente generando un nuovo identificatore o aggiorni lo stato persistente associato
                con il suo identificatore corrente. Il metodo <tt class="literal">saveOrUpdate()</tt> adesso
                implementa questa funzionalit&agrave;.
            </p><p>
                Hibernate distingue istanze "nuove" (non salvate) da istanze "esistenti" (salvate o 
                caricate in una sessione precedente) tramiet il valore della loro propriet&agrave; 
                identificatore (o versione, o marca di tempo). L'attributo <tt class="literal">unsaved-value</tt>
                degli elementi <tt class="literal">&lt;id&gt;</tt> (o <tt class="literal">&lt;version&gt;</tt>,
                o <tt class="literal">&lt;timestamp&gt;</tt>) nel mappaggio specifica quali valori dovrebbero 
                venire interpretati come rappresentanti di una "nuova" istanza.
            </p><pre class="programlisting">&lt;id name="id" type="long" column="uid" unsaved-value="null"&gt;
    &lt;generator class="hilo"/&gt;
&lt;/id&gt;</pre><p>
                I valori consentiti di <tt class="literal">unsaved-value</tt> sono:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">any</tt> - salvare sempre
                    </p></li><li><p>
                    <tt class="literal">none</tt> - aggiornare sempre
                    </p></li><li><p>
                    <tt class="literal">null</tt> - salvare quando l'identificatore &egrave; nullo (questa &egrave; l'opzione predefinita)
                    </p></li><li><p>
                    valid identifier value - salvare quando l'identificatore &egrave; nullo o il valore dato
                    </p></li><li><p>
                    <tt class="literal">undefined</tt> - il valore predefinito per <tt class="literal">version</tt> o
                        <tt class="literal">timestamp</tt>, viene usato un controllo sull'identificatore
                    </p></li></ul></div><pre class="programlisting">// nella prima sessione
Cat cat = (Cat) firstSession.load(Cat.class, catID);

// in uno strato pi&ugrave; elevato dell'applicazione
Cat mate = new Cat();
cat.setMate(mate);

// pi&ugrave; avanti, in un'altra sessione
secondSession.saveOrUpdate(cat);   // aggiorna lo stato esistente (cat ha un id non nullo)
secondSession.saveOrUpdate(mate);  // salva la nuova istanza (mate ha un id nullo)</pre><p>
                L'utilizzo e la semantica di <tt class="literal">saveOrUpdate()</tt> sembra confondere i nuovi
                utenti. In primo luogo, finch&eacute; non stiate cercando di usare istanze di una sessione in 
                un'altra sessione, non dovreste aver bisogno di usare <tt class="literal">update()</tt> o
                <tt class="literal">saveOrUpdate()</tt>. Alcune applicazioni non avranno mai bisogno di 
                nessuno di questi due metodi.
            </p><p>
                Di solito <tt class="literal">update()</tt> o <tt class="literal">saveOrUpdate()</tt> vengono usati 
                nello scenario seguente:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        l'applicazione carica un oggetto nella prima sessione
                    </p></li><li><p>
                        l'oggetto viene passato allo strato di interfaccia
                    </p></li><li><p>
                        vengono fatte alcune modifiche all'oggetto
                    </p></li><li><p>
                        l'oggetto viene ripassato allo strato della logica di business
                    </p></li><li><p>
                        l'applicazione rende persistenti queste modifiche chiamando 
                        <tt class="literal">update()</tt> in una seconda sessione
                    </p></li></ul></div><p>
                <tt class="literal">saveOrUpdate()</tt> fa quanto segue:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        se l'oggetto &egrave; gi&agrave; persistente in questa sessione, non fare nulla
                    </p></li><li><p>
                        se l'oggetto non ha propriet&agrave; identificatore, lo salva (<tt class="literal">save()</tt>)
                    </p></li><li><p>
                        se il valore dell'identificatore salva i criteri specificati da 
                        <tt class="literal">unsaved-value</tt>, lo salva (<tt class="literal">save()</tt>)
                    </p></li><li><p>
                        se l'oggetto &egrave; con versioni (<tt class="literal">version</tt> o
                        <tt class="literal">timestamp</tt>), allora la versione avr&agrave; precedenza sul controllo
                        dell'identificatore, a meno che la versione non sia 
                        <tt class="literal">unsaved-value="undefined"</tt> (valore di default)
                    </p></li><li><p>
                        se un altro oggetto associato con la sessione ha lo stesso identificatore, lancia
                        un'eccezione
                    </p></li></ul></div></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-update-lock"></a>9.4.3.&nbsp;Riaggancio di oggetti sganciati</h3></div></div><div></div></div><p>
                Il metodo <tt class="literal">lock()</tt> consente all'applicazione di riassociare un oggetto
                non modificato con una nuova sessione.
            </p><pre class="programlisting">//riassocia semplicemente:
sess.lock(fritz, LockMode.NONE);
//fa un controllo di versione, poi riassocia:
sess.lock(izi, LockMode.READ);
//fa un controllo di versione usando SELECT ... FOR UPDATE, quindi riassocia:
sess.lock(pk, LockMode.UPGRADE);</pre></div></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-deleting"></a>9.5.&nbsp;Cancellazione di oggetti persistenti</h2></div></div><div></div></div><p>
            <tt class="literal">Session.delete()</tt> rimuover&agrave; lo stato di un oggetto dal database. Naturalmente,
            la vostra applicazione potesse ancora mantenere un riferimento ad esso. Per questo, &egrave; preferibile
            pensare a <tt class="literal">delete()</tt> come un modo per rendere transiente un'istanza persistente.
        </p><pre class="programlisting">sess.delete(cat);</pre><p>
            Potete anche cancellare molti oggetti allo stesso tempo, passando una stringa di interrogazione a
            <tt class="literal">delete()</tt>.
        </p><p>
            Ora &egrave; poi possibile cancellare oggetti in qualsiasi ordine, senza il rischio di violazioni di 
            chiave. Naturalmente, &egrave; sempre possibile violare un vincolo <tt class="literal">NOT NULL</tt> su 
            una chiave esterna cancellando oggetti nell'ordine sbagliato.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-flushing"></a>9.6.&nbsp;Scaricamento (flush)</h2></div></div><div></div></div><p>
            Di tanto in tanto, la <tt class="literal">Session</tt> eseguir&agrave; le istruzioni SQL necessarie per
            sincronizzare lo stato della connessione JDBC con lo stato degli oggetti mantenuti in memoria.
            Questo processo, il <span class="emphasis"><em>flush</em></span>, avviene come comportamento standard nei seguenti 
            punti
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    per effetto di alcune invocazioni di <tt class="literal">find()</tt> o <tt class="literal">iterate()</tt>
                </p></li><li><p>
                    in seguito a  <tt class="literal">net.sf.hibernate.Transaction.commit()</tt>
                </p></li><li><p>
                    in seguito a <tt class="literal">Session.flush()</tt>
                </p></li></ul></div><p>
            Le istruzioni SQL vengono emesse nell'ordine seguente
        </p><div class="orderedlist"><ol type="1" compact><li><p>
                    tutti gli inserimenti di entit&agrave;, nello stesso ordine con cui gli oggetti corrispondenti erano 
                    stati salvati usando <tt class="literal">Session.save()</tt>
                </p></li><li><p>
                    tutti gli aggiornamenti di entit&agrave;
                </p></li><li><p>
                    tutte le cancellazioni di collezione
                </p></li><li><p>
                    tutte le cancellazioni, gli aggiornamenti e inserimenti di elementi di collezioni
                </p></li><li><p>
                    tutti gli inserimenti di collezione
                </p></li><li><p>
                    tutte le cancellazioni di entit&agrave;, nello stesso ordine con cui gli oggetti corrispondenti
                    erano stati cancellati usando <tt class="literal">Session.delete()</tt>
                </p></li></ol></div><p>
            (Una eccezione &egrave; che gli oggetti che usando meccanismi di generazione di identificator
            <tt class="literal">native</tt> vengono inseriti nel momento stesso in cui sono salvati.)
        </p><p>
            Eccettuato quando chiamate <tt class="literal">flush()</tt> esplicitamente, non ci sono assolutamente
            garanzie riguardo a <span class="emphasis"><em>quando</em></span> la <tt class="literal">Session</tt> eseguir&agrave; le chiamate
            JDBC, solo l'<span class="emphasis"><em>ordine</em></span> con cui verranno eseguite. In ogni caso, Hibernate 
            garantisce che i metodi <tt class="literal">Session.find(..)</tt> non restituiranno mai dati obsoleti o 
            che restituiranno dati sbagliati.
        </p><p>
            &Egrave; possibile cambiare il comportamento predefinito in modo che lo scaricamento avvenga meno 
            frequentemente. La classe <tt class="literal">FlushMode</tt> definisce tre modi differenti. Questo non 
            &egrave; utile nel caso di transazioni "a sola lettura", in cui potrebbe solo essere usato per ottenere
            un (molto) leggero incremento di performance.
        </p><pre class="programlisting">sess = sf.openSession();
Transaction tx = sess.beginTransaction();
//consente alle interrogazioni di restituire stato obsoleto
sess.setFlushMode(FlushMode.COMMIT); 
Cat izi = (Cat) sess.load(Cat.class, id);
izi.setName(iznizi);
// esegue alcune interrogazioni....
sess.find("from Cat as cat left outer join cat.kittens kitten");
//il cambiamento su izi non viene scaricato!
...
tx.commit(); //avviene lo scaricamento</pre></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-endingsession"></a>9.7.&nbsp;Fine di una sessione</h2></div></div><div></div></div><p>
            La conclusione di una sessione implica quattro fasi distinte:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    scaricamento della sessione
                </p></li><li><p>
                    commit della transazione
                </p></li><li><p>
                    chiusura della sessione
                </p></li><li><p>
                    gestione delle eccezioni
                </p></li></ul></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-endingsession-flushing"></a>9.7.1.&nbsp;Scaricamento della sessione</h3></div></div><div></div></div><p>
                Se state usando l'API <tt class="literal">Transaction</tt>, non avete bisogno di 
                preoccuparvi di questo passo. Verr&agrave; effettuato implicitamente quando la transazione
                verr&agrave; committata. In caso contrario dovreste chiamare <tt class="literal">Session.flush()</tt> 
                per assicurarvi che tutti i cambiamenti siano sincronizzati con il database.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-endingsession-commit"></a>9.7.2.&nbsp;Commit della transazione sul database</h3></div></div><div></div></div><p>
                Se state usando l'API <tt class="literal">Transaction</tt> di Hibernate, questo apparir&agrave; come:
            </p><pre class="programlisting">tx.commit(); // scaricamento della Session e commit della transazione</pre><p>
                Se state gestendo autonomamente le transazioni JDBC, dovreste chiamare manualmente 
                <tt class="literal">commit()</tt> sulla connessione JDBC.
            </p><pre class="programlisting">sess.flush();
sess.connection().commit();  // non necessario per un datasource JTA</pre><p>
                Se decidete di <span class="emphasis"><em>non</em></span> fare il commit dei cambiamenti:
            </p><pre class="programlisting">tx.rollback();  // rollback della transazione</pre><p>
                or:
            </p><pre class="programlisting">// non necessario per un datasource JTA, importante altrimenti
sess.connection().rollback();</pre><p>
                Se fate il rollback della transazione dovreste immediatamente chiudere e scartare
                la sessione corrente, per assicurarvi che lo stato interno di Hibernate sia coerente.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-endingsession-close"></a>9.7.3.&nbsp;Chiusura della sessione</h3></div></div><div></div></div><p>
                Una chiamata a <tt class="literal">Session.close()</tt> segna la fine di una sessione. L'implicazione principale
                di <tt class="literal">close()</tt> &egrave; che la connessione JDBC verr&agrave; liberata dalla session.
            </p><pre class="programlisting">tx.commit();
sess.close();</pre><pre class="programlisting">sess.flush();
sess.connection().commit();  // non necessario per un datasource JTA
sess.close();</pre><p>
                Se avete fornito le vostre connessioni, <tt class="literal">close()</tt> restituisce un riferimento ad esse, 
                in modo tale che possiate chiuderle o restituirle al lotto (pool) manualmente. In caso contrario 
                <tt class="literal">close()</tt> le restituisce al lotto.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-endingsession-exceptions"></a>9.7.4.&nbsp;Gestione delle eccezioni</h3></div></div><div></div></div><p>
                Se la <tt class="literal">Session</tt> lancia un'eccezione (compresa una qualsiasi
                <tt class="literal">SQLException</tt>), dovreste immediatamente fare il rollback della
                transazione, chiamare <tt class="literal">Session.close()</tt> e scartare l'istanza di
                <tt class="literal">Session</tt>. Alcuni metodi di <tt class="literal">Session</tt> <span class="emphasis"><em>non</em></span>
                lasceranno la sessione in uno stato coerente.
            </p><p>
                Raccomandiamo il seguente idioma di gestione delle eccezioni:
            </p><pre class="programlisting">Session sess = factory.openSession();
Transaction tx = null;
try {
    tx = sess.beginTransaction();
    // fa del lavoro
    ...
    tx.commit();
}
catch (Exception e) {
    if (tx!=null) tx.rollback();
    throw e;
}
finally {
    sess.close();
}</pre><p>
                O, quando si gestiscono manualmente le transazioni JDBC:
            </p><pre class="programlisting">Session sess = factory.openSession();
try {
    // fa del lavoro
    ...
    sess.flush();
    sess.connection().commit();
}
catch (Exception e) {
    sess.connection().rollback();
    throw e;
}
finally {
    sess.close();
}</pre><p>
                O, quando si usa un datasource iscritto con il JTA:
            </p><pre class="programlisting">UserTransaction ut = .... ;
Session sess = factory.openSession();
try {
    // fa del lavoro
    ...
    sess.flush();
}
catch (Exception e) {
    ut.setRollbackOnly();
    throw e;
}
finally {
    sess.close();
}</pre></div></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-graphs"></a>9.8.&nbsp;Cicli di vita e grafi di oggetti</h2></div></div><div></div></div><p>
            Per salvare o aggiornare tutti gli oggetti in un grafo di oggetti associati dovete
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    chiamare <tt class="literal">save()</tt>, <tt class="literal">saveOrUpdate()</tt> o
                    <tt class="literal">update()</tt> su ogni oggetto individuale O
                </p></li><li><p>
                    mappare gli oggetti associati con <tt class="literal">cascade="all"</tt> o
                    <tt class="literal">cascade="save-update"</tt>.
                </p></li></ul></div><p>
            Nello stesso modo, per cancellare tutti gli oggetti un grafo
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    chiamate <tt class="literal">delete()</tt> su ogni oggetto individuale O
                </p></li><li><p>
                    mappate gli oggetti associati usando <tt class="literal">cascade="all"</tt>,
                    <tt class="literal">cascade="all-delete-orphan"</tt> o
                    <tt class="literal">cascade="delete"</tt>.
                </p></li></ul></div><p>
            Raccomandazione:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Se il periodo di esistenza dell'oggetto figlio &egrave; incluso in quello del genitore fate 
                    in modo che diventi un oggetto del ciclo di vita <span class="emphasis"><em>(lifecycle object)</em></span>, specificando
                    <tt class="literal">cascade="all"</tt>.
                </p></li><li><p>
                    In caso contrario, chiamate esplicitamente <tt class="literal">save()</tt> e <tt class="literal">delete()</tt>
                    su di esso dal codice applicativo. Se volete davvero risparmiarvi della digitazione extra, usate
                    <tt class="literal">cascade="save-update"</tt> e chiamate esplicitamente <tt class="literal">delete()</tt>.
                </p></li></ul></div><p>
            Il mappaggio di un'associazione (molti-a-uno, o collezione) con <tt class="literal">cascade="all"</tt>
            marchia l'associazione come una relazione di stile <span class="emphasis"><em>genitore/figlio</em></span> in cui 
            il salvataggio/aggiornamento/cancellazione del genitore risulta in operazioni analoghe dei figli.
            Inoltre, il semplice fatto di avere un riferimento ad un figlio in un genitore persistente 
            risulter&agrave; in salvataggio / aggiornamento del figlio. La metafora &egrave; tuttavia incompleta. Un figlio
            che diventi non pi&ugrave; referenziato dal padre <span class="emphasis"><em>non</em></span> viene automaticamente 
            cancellato, eccetto nel caso di una associazione <tt class="literal">&lt;one-to-many&gt;</tt> mappata
            con <tt class="literal">cascade="all-delete-orphan"</tt>. La semantica precisa delle operazioni di 
            cascata sono come segue:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Se un parente viene salvato, tutti i figli vengono passati a <tt class="literal">saveOrUpdate()</tt>
                </p></li><li><p>
                    Se un parente viene passato a <tt class="literal">update()</tt> o <tt class="literal">saveOrUpdate()</tt>,
                    tutti i figli vengono passati a <tt class="literal">saveOrUpdate()</tt>
                </p></li><li><p>
                    Se un figlio transiente diventa referenziato da un padre persistente, viene passato a 
                    <tt class="literal">saveOrUpdate()</tt>
                </p></li><li><p>
                    Se un parente viene cancellato, tutti i figli vengono passati a <tt class="literal">delete()</tt>
                </p></li><li><p>
                    Se un figlio transiente viene de-referenziato da un padre persistente, <span class="emphasis"><em>non succede
                    niente di speciale</em></span> (l'applicazione dovrebbe cancellare esplicitamente il figlio 
                    se necessario) a meno che la relazione non sia mappata come come <tt class="literal">cascade="all-delete-orphan"</tt>, 
                    nel qual caso il figlio "orfano" viene cancellato.
                </p></li></ul></div><p>
            Hibernate non implementa completamente il concetto di "persistenza per raggiungibilit&agrave;", che implicherebbe
            una (inefficiente) raccolta dei rifiuti (garbage collection) persistenti. In ogni caso, in seguito alle 
            richieste di molta gente, Hibernate supporta la nozione di entit&agrave; che diventano persistenti quando vengono
            referenziate da un altro oggetto persistente. Le associazioni marchiate <tt class="literal">cascade="save-update"</tt> 
            si comportano cos&igrave;. Se volete usare questo approccio in tutta l'applicazione, &egrave; pi&ugrave; comodo specificare 
            l'attributo <tt class="literal">default-cascade</tt> nell'elemento <tt class="literal">&lt;hibernate-mapping&gt;</tt>.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-interceptors"></a>9.9.&nbsp;Intercettatori (interceptors)</h2></div></div><div></div></div><p>
            L'interfaccia <tt class="literal">Interceptor</tt> fornisce dei punti di richiamo (callback) dalla sessione
            verso l'applicazione, consentendole di ispezionare e/o manipolare propriet&agrave; di un oggetto persistente
            prima che venga salvato, aggiornato, cancellato o caricato. Un utilizzo possibile per questo &egrave; di
            tracciare delle informazioni di auditing. Per esempio, l'<tt class="literal">Interceptor</tt> seguente
            imposta automaticamente il <tt class="literal">createTimestamp</tt> quando viene creato un oggetto 
            <tt class="literal">Auditable</tt> e aggiorna la propriet&agrave; <tt class="literal">lastUpdateTimestamp</tt> 
            quando un <tt class="literal">Auditable</tt> viene aggiornato.
        </p><pre class="programlisting">package net.sf.hibernate.test;

import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;

import net.sf.hibernate.Interceptor;
import net.sf.hibernate.type.Type;

public class AuditInterceptor implements Interceptor, Serializable {

    private int updates;
    private int creates;

    public void onDelete(Object entity,
                         Serializable id,
                         Object[] state,
                         String[] propertyNames,
                         Type[] types) {
        // non fare nulla
    }

    public boolean onFlushDirty(Object entity, 
                                Serializable id, 
                                Object[] currentState,
                                Object[] previousState,
                                String[] propertyNames,
                                Type[] types) {

        if ( entity instanceof Auditable ) {
            updates++;
            for ( int i=0; i &lt; propertyNames.length; i++ ) {
                if ( "lastUpdateTimestamp".equals( propertyNames[i] ) ) {
                    currentState[i] = new Date();
                    return true;
                }
            }
        }
        return false;
    }

    public boolean onLoad(Object entity, 
                          Serializable id,
                          Object[] state,
                          String[] propertyNames,
                          Type[] types) {
        return false;
    }

    public boolean onSave(Object entity,
                          Serializable id,
                          Object[] state,
                          String[] propertyNames,
                          Type[] types) {
        
        if ( entity instanceof Auditable ) {
            creates++;
            for ( int i=0; i&lt;propertyNames.length; i++ ) {
                if ( "createTimestamp".equals( propertyNames[i] ) ) {
                    state[i] = new Date();
                    return true;
                }
            }
        }
        return false;
    }

    public void postFlush(Iterator entities) {
        System.out.println("Creazioni: " + creates + ", Aggiornamenti: " + updates);
    }

    public void preFlush(Iterator entities) {
        updates=0;
        creates=0;
    }
    
    ......
    ......
    
}</pre><p>
            L'interceptor dovrebbe essere specificato alla creazione di una sessione.
        </p><pre class="programlisting">Session session = sf.openSession( new AuditInterceptor() );</pre></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-metadata"></a>9.10.&nbsp;API dei metadati</h2></div></div><div></div></div><p>
            Hibernate richiede un modello di meta-livello molto ricco di tutte le entit&agrave; e dei tipi di valori.
            Di tanto in tanto, questo modello &egrave; molto utile alla stessa applicazione. Ad esempio, l'applicazione
            potrebbe usare i metadati di Hibernate per implementare un algoritmo "intelligente" di copia "profonda"
            che capisca quali oggetti dovrebbero venire copiati (ad esempio i tipi di valore mutabili) e quali
            non dovrebbero (ad esempio i tipi di valore immutabili e, magari, le entit&agrave; associate).
        </p><p>
            Hibernate espone metadati tramite le interfacce <tt class="literal">ClassMetadata</tt> e
            <tt class="literal">CollectionMetadata</tt> e la gerarchia <tt class="literal">Type</tt>. 
            Le istanze delle interfacce dei metadati possono venire ottenute dalla 
            <tt class="literal">SessionFactory</tt>.
        </p><pre class="programlisting">Cat fritz = ......;
Long id = (Long) catMeta.getIdentifier(fritz);
ClassMetadata catMeta = sessionfactory.getClassMetadata(Cat.class);
Object[] propertyValues = catMeta.getPropertyValues(fritz);
String[] propertyNames = catMeta.getPropertyNames();
Type[] propertyTypes = catMeta.getPropertyTypes();
// ottiene una mappa di tutte le propriet&agrave; che non sono collezioni o associazioni
// TODO: e i componenti?
Map namedValues = new HashMap();
for ( int i=0; i&lt;propertyNames.length; i++ ) {
    if ( !propertyTypes[i].isEntityType() &amp;&amp; !propertyTypes[i].isCollectionType() ) {
        namedValues.put( propertyNames[i], propertyValues[i] );
    }
}</pre></div></div><div class="chapter" lang="it"><div class="titlepage"><div><div><h2 class="title"><a name="transactions"></a>Capitolo&nbsp;10.&nbsp;Transazioni e concorrenza</h2></div></div><div></div></div><p>
        Hibernate non &egrave; in se stesso un database. &Egrave; uno strumento leggero di mappaggio 
        oggetto-relazione. La gestione delle transazioni viene delegata alla sottostante
        connessione con il database. Se la connessione &egrave; iscritta con il JTA, le operazioni
        effettuate dalla <tt class="literal">Session</tt> sono atomicamente parte della transazione
        JTA pi&ugrave; esterna. Hibernate pu&ograve; essere considerato un sottile strato di adattamento
        sul JDBC che aggiunge la semantica orientata agli oggetti.
    </p><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-basics"></a>10.1.&nbsp;Configurazioni, sessioni e "factory"</h2></div></div><div></div></div><p>
            Una <tt class="literal">SessionFactory</tt> &egrave; un oggetto che supporta l'utilizzo concorrente (threadsafe), 
            costoso da creare, che &egrave; pensato per essere condiviso da tutti i thread dell'applicazione. 
            Una <tt class="literal">Session</tt>  &egrave; invece un oggetto non costoso da crearsi, non utilizzabile in 
            maniera concorrente, che dovrebbe essere usato una volta sola per un singolo processo di business
            e poi scartato. Ad esempio, quando si usa Hibernate in un applicazione basata sui servlet, i servlet
            possono ottenere una <tt class="literal">SessionFactory</tt> usando
        </p><pre class="programlisting">SessionFactory sf = (SessionFactory)getServletContext().getAttribute("my.session.factory");</pre><p>
            Ogni chiamata ad un metodo di servizio potrebbe creare una nuova <tt class="literal">Session</tt>,
            farci sopra il <tt class="literal">flush()</tt> (scaricamento su db) , mandare un <tt class="literal">commit()</tt> 
            sulla sua connesione, chiuderla (<tt class="literal">close()</tt>) ed infine eliminarla. (La <tt class="literal">SessionFactory</tt>
            pu&ograve; anche essere memorizzata nel JNDI o in una variabile di utilit&agrave; <span class="emphasis"><em>Singleton</em></span>.)
        </p><p>
            In un "session bean" senza stato si pu&ograve; usare un approccio simile. Il bean dovrebbe
            ottenere una <tt class="literal">SessionFactory</tt> con il metodo <tt class="literal">setSessionContext()</tt>. 
            A questo punto, ogni metodo di business dovrebbe creare una <tt class="literal">Session</tt>,
            fare il <tt class="literal">flush()</tt> e chiuderla (<tt class="literal">close()</tt>). Naturalmente, 
            l'applicazione non dovrebbe chiamare <tt class="literal">commit()</tt> sulla connessione. (Va lasciata
            al JTA, perch&eacute; la connessione al database partecipa automaticamente nelle transazioni gestite 
            dal contenitore.)
        </p><p>
            Usiamo l'API <tt class="literal">Transaction</tt> di Hibernate come discusso in precedenza,
            una singola <tt class="literal">commit()</tt> di una <tt class="literal">Transaction</tt> di 
            Hibernate scarica lo stato e fa il commit di ogni connessione di database sottostante
            (con una gesione particolare delle transazioni JTA).
        </p><p>
            Assicuratevi di capire la semantica del <tt class="literal">flush()</tt>.
            Lo scaricamento (flushing) sincronizza il contenitore persistente con 
            i cambiameti in memoria, ma <span class="emphasis"><em>non</em></span> vice-versa. Notate che 
            per tutte le connessioni/transazioni JDBC di Hibernate, il livello di 
            isolamento transazionale si applica a tutte le operazioni che vengono
            eseguite da Hibernate stesso!
        </p><p>
            Le prossime sezioni discuteranno gli approcci alternativi che usano il versionamento
            per assicurare l'atomicit&agrave; delle transazioni. Sono approcci che vengono considerati
            "avanzati" e vanno usati con attenzione.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-threads"></a>10.2.&nbsp;Thread e connessioni</h2></div></div><div></div></div><p>
            Dovreste osservare le indicazioni seguenti quando create Session di Hibernate:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Non creare pi&ugrave; di una istanza di <tt class="literal">Session</tt> o
                    <tt class="literal">Transaction</tt> concorrenti per connessione di database.
                </p></li><li><p>
                    Siate estremamente attenti quando create pi&ugrave; di una <tt class="literal">Session</tt>
                    per database per transazione. La <tt class="literal">Session</tt> mantiene traccia di 
                    aggiornamenti fatti agli oggetti caricati, e quindi una <tt class="literal">Session</tt>
                    differente potrebbe vedere dati non pi&ugrave; validi.
                </p></li><li><p>
                    La <tt class="literal">Session</tt> <span class="emphasis"><em>non</em></span> &egrave; threadsafe (non 
                    consente pi&ugrave; utilizzi concorrenti)! Non accedete alla stessa 
                    <tt class="literal">Session</tt> in due thread di esecuzione concorrenti.
                    Una <tt class="literal">Session</tt> di solito &egrave; una singola unit&agrave; di lavoro!
                </p></li></ul></div></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-identity"></a>10.3.&nbsp;Considerazioni sull'identit&agrave; degli oggetti</h2></div></div><div></div></div><p>
            L'applicazione pu&ograve; accedere concorrentemente allo stesso stato persistente
            in due differenti unit&agrave; di lavoro. Per&ograve;, un'istanza di una classe persistente
            non viene mai condivisa tra due istanze di <tt class="literal">Session</tt>. Da qui, 
            discendono due differenti nozioni di identit&agrave;:
        </p><div class="variablelist"><dl><dt><span class="term">Identit&agrave; per il database</span></dt><dd><p>
                        <tt class="literal">foo.getId().equals( bar.getId() )</tt>
                    </p></dd><dt><span class="term">Identit&agrave; per la JVM (java virtual machine)</span></dt><dd><p>
                        <tt class="literal">foo==bar</tt>
                    </p></dd></dl></div><p>
            Per due oggetti appartenenti ad una <span class="emphasis"><em>particulare</em></span> <tt class="literal">Session</tt>,
            le due nozioni sono equivalenti. Per&ograve;, mentre l'applicazione potrebbe accedere in maniera 
            concorrente lo "stesso" (secondo l'identit&agrave; persistente) oggetto di business in due sessioni
            differenti, le due istanze sono in realt&agrave; "differenti" (secondo l'identit&agrave; della virtual machine).
        </p><p>
            Questo approccio fa s&igrave; che siano Hibernate e il database, a preoccuparsi della concorrenza.
            L'applicazione non deve mai sincronizzare l'accesso ad un oggetto di business, finch&eacute; 
            rispetta il fatto che l'accesso alla <tt class="literal">Session</tt> venga fatto da un singolo
            thread o le regole sull'identit&agrave; degli oggetti (all'interno di una <tt class="literal">Session</tt> 
            l'applicazione pu&ograve; tranquillamente utilizzare <tt class="literal">==</tt> per confrontare gli oggetti).
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-optimistic"></a>10.4.&nbsp;Controllo di concorrenza ottimistico</h2></div></div><div></div></div><p>
            Molti processi di business richiedono una serie di interazioni con l'utente 
            inframmezzate da accessi al database. Nelle applicazioni web e aziendali non
            &egrave; accettabile che una transazione sul database si estenda lungo una serie di 
            interazioni con l'utente.
        </p><p>
            Mantenere l'isolamento dei processi di business in questi casi diventa una 
            responsabilit&agrave; parziale dello strato applicativo, ed in questo caso si dice
            che questo processo &egrave; una <span class="emphasis"><em>transazione applicativa</em></span> di 
            lunga durata. Una singola transazione applicativa di solito si estende su
            diverse transazioni sul database: essa sar&agrave; atomica se una sola di queste
            transazioni sul database (l'ultima) memorizza i dati aggiornati, e le 
            altre semplicemente li leggono.
        </p><p>
            L'unico approccio che &egrave; consistente con alta concorrenza e alta scalabilit&agrave;
            &egrave; il controllo di concorrenza ottimistico con versionamento. Hibernate fornisce
            tre possibili approcci alla produzione di codice applicativo che utilizzi la
            concorrenza ottimistica.
        </p><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-longsession"></a>10.4.1.&nbsp;Sessione lunga con versionamento automatico</h3></div></div><div></div></div><p>
                Una singola istanza di <tt class="literal">Session</tt> e gli oggetti persistenti che gestisce sono 
                utilizzate per tutta la transazione applicativa.
            </p><p>
                La <tt class="literal">Session</tt> utilizza il locking ottimistico con versionamento
                per assicurarsi che molte transazioni sul database appaiano all'applicazione 
                come una singola transazione applicativa logica. La <tt class="literal">Session</tt> 
                &egrave; disconnessa dalla connessione JDBC mentre aspetta l'interazione con l'utente.
                Questo approccio &egrave; il pi&ugrave; efficiente in termini di accesso al database.
                L'applicazione non deve preoccuparsi con il controllo delle versioni o con 
                il riaggancio alla sessione delle istanze sganciate.
            </p><pre class="programlisting">// foo &egrave; un'istanza caricata precedentemente dalla Session
session.reconnect();
foo.setProperty("bar");
session.flush();
session.connection().commit();
session.disconnect();</pre><p>
                L'oggetto <tt class="literal">foo</tt> sa ancora da quale <tt class="literal">Session</tt>
                era stata caricato. Non appena la <tt class="literal">Session</tt> avr&agrave; una connessione 
                JDBC verr&agrave; fatto il commit dei cambiamenti sull'oggetto.
            </p><p>
                Questo pattern &egrave; problematico se la <tt class="literal">Session</tt> &egrave; troppo grande
                per essere memorizzata durante il tempo di ragionamento dell'utente, ad esempio
                una <tt class="literal">HttpSession</tt> dovrebbe essere mantenuta il pi&ugrave; ridotta 
                possibile. Poich&eacute; la <tt class="literal">Session</tt> &egrave; anche la cache di primo livello
                (obbligatoria) e contiene tutti gli oggetti che ha caricato, possiamo probabilmente
                utilizzare questa strategia solo per pochi cicli di richiesta e risposta. Questo 
                &egrave; in realt&agrave; raccomandato anche perch&eacute; la <tt class="literal">Session</tt> avrebbe presto
                dati scaduti, in caso contrario.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-detached"></a>10.4.2.&nbsp;Sessioni multiple con versionamento automatico</h3></div></div><div></div></div><p>
                Ogni interazione con il contenitore persistente dei dati avviene in una nuova 
                <tt class="literal">Session</tt>. Per&ograve;, le stesse istanze persistenti vengono riutilizzate per 
                ogni interazione con il database. L'applicazione manipola lo stato delle istanze sganciate
                originariamente caricate in un'altra <tt class="literal">Session</tt> e quindi le "riassocia"
                usando <tt class="literal">Session.update()</tt> o <tt class="literal">Session.saveOrUpdate()</tt>.
            </p><pre class="programlisting">// foo &egrave; una istanza caricata da una Session precedente
foo.setProperty("bar");
session = factory.openSession();
session.saveOrUpdate(foo);
session.flush();
session.connection().commit();
session.close();</pre><p>
                &Egrave; anche possibile chiamare <tt class="literal">lock()</tt> invece di <tt class="literal">update()</tt>
                e usare <tt class="literal">LockMode.READ</tt> (effettua un controllo di versione e aggira
                tutte le cache) se si &egrave; sicuri che l'oggetto non &egrave; stato modificato.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-manual"></a>10.4.3.&nbsp;Controllo delle versioni da parte dell'applicazione</h3></div></div><div></div></div><p>
                Ogni interazione con il database avviene in una nuova <tt class="literal">Session</tt>
                che ricarica tutte le istanze persistenti prima di manipolarle. Questo approccio
                obbliga l'applicazione a gestire in proprio il controllo delle versioni per 
                assicurarsi che le transazioni applicative siano isolate. (Naturalmente Hibernate
                <span class="emphasis"><em>aggiorner&agrave;</em></span> ancora i numeri di versione per voi). Questo approccio
                &egrave; il meno efficiente in termini di accesso al database, ed &egrave; il pi&ugrave; simile a quello degli
                EJB di entit&agrave;.
            </p><pre class="programlisting">// foo &egrave; un'istanza caricata da una Session precedente
session = factory.openSession();
int oldVersion = foo.getVersion();
session.load( foo, foo.getKey() );
if ( oldVersion!=foo.getVersion ) throw new StaleObjectStateException();
foo.setProperty("bar");
session.flush();
session.connection().commit();
session.close();</pre><p>
                Naturalmente, se state lavorando in un ambiente a bassa concorrenza dei dati 
                e non avete bisogno di controllo delle versioni, potete adottare questo approccio 
                e semplicemente evitare il controllo di versione.
            </p></div></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-disconnection"></a>10.5.&nbsp;Disconnessione della sessione</h2></div></div><div></div></div><p>
            Il primo approccio descritto sopra &egrave; di mantenere una singola <tt class="literal">Session</tt> 
            che si estende per un intero processo di business durante il periodo di ragionamento 
            dell'utente. (Ad esempio, un servlet potrebbe mantenere una <tt class="literal">Session</tt> 
            nella <tt class="literal">HttpSession</tt> dell'utente.) Per ragioni di performance si dovrebbe
        </p><div class="orderedlist"><ol type="1" compact><li><p>
                    fare il commit della <tt class="literal">Transaction</tt> (o della connessione JDBC) e poi 
                </p></li><li><p>
                    sconnettere la <tt class="literal">Session</tt> dalla connessione JDBC
                </p></li></ol></div><p>
            prima di aspettare un'azione da parte dell'utente. Il metodo <tt class="literal">Session.disconnect()</tt> 
            sconnetter&agrave; la sessione dalla connessione JDBC e restituir&agrave; la connessione al lotto di connessioni
            disponibili per l'uso (a meno che non siate stati voi a fornirla direttamente).
        </p><p>
            <tt class="literal">Session.reconnect()</tt> ottiene una nuova connessione (o potete fornirne una voi)
            e fa ripartire la sessione. Dopo la riconnessione, &egrave; possibile chiamare <tt class="literal">Session.lock()</tt> 
            per forzare un controllo di versione sui dati che non sono stati modificati ma che potrebbero essere stati 
            aggiornati da un'altra transazione. Non avete bisogno di porre dei "lock" su dati che 
            <span class="emphasis"><em>state</em></span> modificando.
        </p><p>
            Ecco un esempio:
        </p><pre class="programlisting">SessionFactory sessions;
List fooList;
Bar bar;
....
Session s = sessions.openSession();

Transaction tx = null;
try {
    tx = s.beginTransaction();

    fooList = s.find(
    	"select foo from eg.Foo foo where foo.Date = current date"
        // uses db2 date function
    );
    bar = (Bar) s.create(Bar.class);

    tx.commit();
}
catch (Exception e) {
    if (tx!=null) tx.rollback();
    s.close();
    throw e;
}
s.disconnect();</pre><p>
            In seguito:
        </p><pre class="programlisting">s.reconnect();

try {
    tx = s.beginTransaction();

    bar.setFooTable( new HashMap() );
    Iterator iter = fooList.iterator();
    while ( iter.hasNext() ) {
        Foo foo = (Foo) iter.next();
        s.lock(foo, LockMode.READ);    //controlliamo che foo non sia scaduto
        bar.getFooTable().put( foo.getName(), foo );
    }

    tx.commit();
}
catch (Exception e) {
    if (tx!=null) tx.rollback();
    throw e;
}
finally {
    s.close();
}</pre><p>
            Potete vedere da quanto precede che la relazione tra <tt class="literal">Transaction</tt>i e 
            <tt class="literal">Session</tt>i &egrave; molti-a-uno. Una <tt class="literal">Session</tt> rappresenta
            una conversazione tra l'applicazione e il database. La
            <tt class="literal">Transaction</tt> spezza quella conversazione in unit&agrave; di lavoro atomiche
            al livello del database.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-locking"></a>10.6.&nbsp;Locking Pessimistico</h2></div></div><div></div></div><p>
            Gli utenti non devono spendere molto tempo preoccupandosi delle strategie di locking. 
            Solitamente &egrave; sufficiente specificare un livello di isolamento per le connessioni JDBC
            e poi semplicemente fare in modo che il database faccia tutto il lavoro. Per&ograve;, gli utenti
            avanzati possono desiderare a volte di ottenere lock pessimistici esclusivi, o riottenere
            dei lock all'inizio di una nuova transazione.
        </p><p>
            Hibernate user&agrave; sempre il meccanismo di lock del database, e non porr&agrave; mai dei lock
            sugli oggetti in memoria!
        </p><p>
            La classe <tt class="literal">LockMode</tt> definisce i differenti livelli di lock che possono 
            essere acquisiti da Hibernate. Un lock si pu&ograve; ottenere con i meccanismi seguenti:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">LockMode.WRITE</tt> viene assunto automaticamente quando Hibernate modifica
                    o inserisce una riga. 
                </p></li><li><p>
                    <tt class="literal">LockMode.UPGRADE</tt> pu&ograve; essere acquisito in seguito ad una richiesta
                    esplicita dell'utente utilizzando <tt class="literal">SELECT ... FOR UPDATE</tt> su dei database
                    che supportino questa sintassi.
                </p></li><li><p>
                    <tt class="literal">LockMode.UPGRADE_NOWAIT</tt> pu&ograve; essere acquisito in seguito ad una richiesta
                    esplicita dell'utente usando <tt class="literal">SELECT ... FOR UPDATE NOWAIT</tt> in Oracle.
                </p></li><li><p>
                    <tt class="literal">LockMode.READ</tt> viene acquisito automaticamente quando Hibernate legge
                    dati a livello di isolamento pari a "Repeatable Read" (letture ripetibili) o "Serializable". 
                    Pu&ograve; essere acquisito anche per esplicita richiesta dell'utente.
                </p></li><li><p>
            <tt class="literal">LockMode.NONE</tt> rappresenta una situazione di assenza di lock. Tutti gli oggetti
            si portano in questa modalit&agrave; di lock alla fine di una <tt class="literal">Transaction</tt>. Gli 
            oggetti associati con la session tramite una chiamata a <tt class="literal">update()</tt> o 
            <tt class="literal">saveOrUpdate()</tt> vengono avviati in questa modalit&agrave;.
        </p></li></ul></div><p>
            La "richiesta esplicita dell'utente" viene espressa in una delle modalit&agrave; seguenti:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Una chiamata a <tt class="literal">Session.load()</tt>, specificando un <tt class="literal">LockMode</tt>.
                </p></li><li><p>
                    Una chiamata a <tt class="literal">Session.lock()</tt>.
                </p></li><li><p>
                    Una chiamata a <tt class="literal">Query.setLockMode()</tt>.
                </p></li></ul></div><p>
            Se si chiama <tt class="literal">Session.load()</tt> con <tt class="literal">UPGRADE</tt> o
            <tt class="literal">UPGRADE_NOWAIT</tt>, e l'oggetto richiesto non era ancora stato
            caricato dalla sessione, l'oggetto viene caricato usando 
            <tt class="literal">SELECT ... FOR UPDATE</tt>.
            Se si chiama <tt class="literal">load()</tt> per un oggetto che &egrave; gi&agrave; stato caricato con 
            un lock meno restrittivo di quello che &egrave; stato richiesto, Hibernate chiama
            <tt class="literal">lock()</tt> per quell'oggetto.
        </p><p>
            <tt class="literal">Session.lock()</tt> effettua un controllo del numero di versione se
            la modalit&agrave; di lock &egrave; <tt class="literal">READ</tt>, <tt class="literal">UPGRADE</tt> o
            <tt class="literal">UPGRADE_NOWAIT</tt>. (Nel caso di <tt class="literal">UPGRADE</tt> o
            <tt class="literal">UPGRADE_NOWAIT</tt>, viene usato <tt class="literal">SELECT ... FOR UPDATE</tt>.)
        </p><p>
            Se il database non supporta la modalit&agrave; di lock richiesta, Hibernate user&agrave; la modalit&agrave;
            alternativa pi&ugrave; appropriata (invece di lanciare un'eccezione). Questo fa s&igrave; che le 
            applicazioni risultino portabili.
        </p></div></div><div class="chapter" lang="it"><div class="titlepage"><div><div><h2 class="title"><a name="queryhql"></a>Capitolo&nbsp;11.&nbsp;HQL: Il linguaggio di interrogazione di Hibernate (Hibernate Query Language)</h2></div></div><div></div></div><p>
        Hibernate &egrave; dotato di un linguaggio di interrogazione estremamente potente che (del tutto
        intenzionalmente) assomiglia molto all'SQL. Ma la sintassi non deve ingannare: l'HQL &egrave; 
        pienamente orientato agli oggetti, e comprende nozioni come l'ereditariet&agrave;, il polimorfismo
        e l'associazione.
    </p><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-casesensitivity"></a>11.1.&nbsp;Dipendenza da maiuscole e minuscole</h2></div></div><div></div></div><p>
            Le interrogazioni non distinguono tra maiuscole e minuscole, eccetto per i nomi delle
            classi java e delle propriet&agrave;.
            Quindi <tt class="literal">SeLeCT</tt> &egrave; la stessa cosa di
            <tt class="literal">sELEct</tt> che &egrave; la stessa cosa di 
            <tt class="literal">SELECT</tt> ma
            <tt class="literal">net.sf.hibernate.eg.FOO</tt> non &egrave;
            <tt class="literal">net.sf.hibernate.eg.Foo</tt> e
            <tt class="literal">foo.barSet</tt> non &egrave;
            <tt class="literal">foo.BARSET</tt>.
        </p><p>
            Questo manuale fa uso di parole chiave HQL in lettere minuscole. Alcuni utenti trovano
            che le interrogazioni con parole chiave in maiuscolo siano pi&ugrave; leggibili, ma troviamo
            che questa convenzione sia brutta, quando utilizzata in interrogazioni annidate in codice
            java.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-from"></a>11.2.&nbsp;La clausola from</h2></div></div><div></div></div><p>
            L'interrogazione pi&ugrave; semplice possibile in Hibernate ha la forma:
        </p><pre class="programlisting">from eg.Cat</pre><p>
            che restituisce semplicemente tutte le istanze della classe <tt class="literal">eg.Cat</tt>. 
        </p><p>
            La maggior parte delle volte, avrete bisogno di assegnare un <span class="emphasis"><em>sinonimo</em></span>, 
            poich&eacute; vorrete fare riferimento al <tt class="literal">Cat</tt> in altre parti dell'interrogazione.
        </p><pre class="programlisting">from eg.Cat as cat</pre><p>
            Questa query assegna il sinonimo <tt class="literal">cat</tt> alle istanze di <tt class="literal">Cat</tt>, 
            in modo da poter usare quel sinonimo pi&ugrave; avanti nell'interrogazione. La parola chiave <tt class="literal">as</tt>
            &egrave; opzionale, potremmo anche scrivere:
        </p><pre class="programlisting">from eg.Cat cat</pre><p>
            Possono apparire anche classi multiple, il che risulta in un prodotto cartesiano o join "incrociato".
        </p><pre class="programlisting">from Formula, Parameter</pre><pre class="programlisting">from Formula as form, Parameter as param</pre><p>
            Viene considerata una buona abitudine dare ai sinonimi delle interrogazioni nomi
            che comincino con lettere minuscole, in maniera coerente con gli standard di 
            denominazione di Java per le variabili locali (ad esempio 
            <tt class="literal">domesticCat</tt>).
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-joins"></a>11.3.&nbsp;Associazioni e join</h2></div></div><div></div></div><p>
            Possiamo anche assegnare sinonimi ad entit&agrave; associate, o anche ad elementi di una
            collezione di valori, usando un <tt class="literal">join</tt>.
        </p><pre class="programlisting">from eg.Cat as cat 
    inner join cat.mate as mate
    left outer join cat.kittens as kitten

from eg.Cat as cat left join cat.mate.kittens as kittens

from Formula form full join form.parameter param</pre><p>
            I tipi di join supportati sono presi in prestito dall'SQL ANSI
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">inner join</tt>
                </p></li><li><p>
                    <tt class="literal">left outer join</tt>
                </p></li><li><p>
                    <tt class="literal">right outer join</tt>
                </p></li><li><p>
                    <tt class="literal">full join</tt> (di solito inutile)
                </p></li></ul></div><p>
            I costrutti <tt class="literal">inner join</tt>, <tt class="literal">left outer join</tt> e 
            <tt class="literal">right outer join</tt> possono venire abbreviati.
        </p><pre class="programlisting">from eg.Cat as cat 
    join cat.mate as mate
    left join cat.kittens as kitten</pre><p>
            In aggiunta, un join di tipo "fetch" (raccolta) consente di inizializzare le 
            associazioni o le collezioni insieme agli oggetti genitori, usando una singola
            select. Questo &egrave; particolarmente utile nel caso di una collezione. Sovrascrive
            in maniera efficace le dichiarazioni dei join esterni (outer join) e della
            raccolta differita (lazy) del file di mappaggio per le associazioni e le 
            collezioni.
        </p><pre class="programlisting">from eg.Cat as cat 
    inner join fetch cat.mate
    left join fetch cat.kittens</pre><p>
            Un "fetch join" (join con raccolta) non ha solitamente bisogno di assegnare un sinonimo,
            perch&eacute; gli oggetti associati non dovrebbero venire usati nella clausola 
            <tt class="literal">where</tt> (n&eacute; in un'altra clausola qualsiasi). Nello stesso modo, gli 
            oggetti associati non vengono restituiti direttamente nei risultati della query. Possono,
            invece, essere raggiunti tramite l'oggetto genitore
        </p><p>
            Notate che, nell'implementazione corrente, solo un ruolo di collezione pu&ograve; essere
            concretizzato ("fetched") in una interrogazione (qualsiasi altra cosa non sarebbe
            performante). Notate anche che il costrutto <tt class="literal">fetch</tt> non pu&ograve; essere
            usato in interrogazioni chiamate usando <tt class="literal">scroll()</tt> o 
            <tt class="literal">iterate()</tt>. Notate infine che <tt class="literal">full join fetch</tt> e 
            <tt class="literal">right join fetch</tt> non hanno senso.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-select"></a>11.4.&nbsp;La clausola select</h2></div></div><div></div></div><p>
            La clausola <tt class="literal">select</tt> sceglie quali oggetti e propriet&agrave; vanno restituiti
            nel set dei risultati della query. Considerate che:
        </p><pre class="programlisting">select mate 
from eg.Cat as cat 
    inner join cat.mate as mate</pre><p>
            La query selezioner&agrave; gli amici (<tt class="literal">mate</tt>s) dei gatti (<tt class="literal">Cat</tt>s).
            In realt&agrave; &egrave; possibile esprimere la stessa interrogazione in maniera pi&ugrave; compatta come:
        </p><pre class="programlisting">select cat.mate from eg.Cat cat</pre><p>
            Potete anche selezionare elementi di una collezione, usando la funzione speciale
            <tt class="literal">elements</tt>. L'interrogazione seguente restituisce tutti i gattini
            (kittens) di ogni gatto (cat).
        </p><pre class="programlisting">select elements(cat.kittens) from eg.Cat cat</pre><p>
            Le interrogazioni possono restituire propriet&agrave; di qualsiasi tipo di valore, comprese 
            le propriet&agrave; di tipo componente:
        </p><pre class="programlisting">select cat.name from eg.DomesticCat cat
where cat.name like 'fri%'

select cust.name.firstName from Customer as cust</pre><p>
            Le interrogazioni possono restituire oggetti multipli e/o propriet&agrave; come un array di 
            tipo <tt class="literal">Object[]</tt>
        </p><pre class="programlisting">select mother, offspr, mate.name 
from eg.DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><p>
            o come un oggetto java tipizzato
        </p><pre class="programlisting">select new Family(mother, mate, offspr)
from eg.DomesticCat as mother
    join mother.mate as mate
    left join mother.kittens as offspr</pre><p>
            purch&eacute; ovviamente <tt class="literal">Family</tt> abbia un costruttore appropriato.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-aggregation"></a>11.5.&nbsp;Funzioni aggregate</h2></div></div><div></div></div><p>
            Le query HQL possono anche restituire i risultati di funzioni aggregate sulle propriet&agrave;:
        </p><pre class="programlisting">select avg(cat.weight), sum(cat.weight), max(cat.weight), count(cat)
from eg.Cat cat</pre><p>
            Le collezioni possono anche apparire all'interno di funzioni aggregate nella clausola 
            <tt class="literal">select</tt>.
        </p><pre class="programlisting">select cat, count( elements(cat.kittens) ) 
from eg.Cat cat group by cat</pre><p>
            Le funzioni aggregate supportate sono
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">avg(...), sum(...), min(...), max(...)</tt>
                </p></li><li><p>
                    <tt class="literal">count(*)</tt>
                </p></li><li><p>
                    <tt class="literal">count(...), count(distinct ...), count(all...)</tt>
                </p></li></ul></div><p>
            Le parole chiave <tt class="literal">distinct</tt> e <tt class="literal">all</tt> possono essere usate
            con la stessa semantica dell'SQL.
        </p><pre class="programlisting">select distinct cat.name from eg.Cat cat

select count(distinct cat.name), count(cat) from eg.Cat cat</pre></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-polymorphism"></a>11.6.&nbsp;Interrogazioni polimorfiche</h2></div></div><div></div></div><p>
            Una interrogazione come:
        </p><pre class="programlisting">from eg.Cat as cat</pre><p>
            non restituisce solo istanze di <tt class="literal">Cat</tt>, ma anche delle sottoclassi come
            <tt class="literal">DomesticCat</tt>. Le interrogazioni di Hibernate possono indicare 
            <span class="emphasis"><em>qualsiasi</em></span> classe o interfaccia Java nella clausola 
            <tt class="literal">from</tt>. L'interrogazione restituir&agrave; istanze di tutte le classi persistenti
            che estendono quella classe o implementano l'interfaccia. La prossima interrogazione
            restituisce tutti gli oggetti persistenti:
        </p><pre class="programlisting">from java.lang.Object o</pre><p>
            L'interfaccia <tt class="literal">Named</tt> potrebbe essere implementata da diverse classi 
            persistenti: 
        </p><pre class="programlisting">from eg.Named n, eg.Named m where n.name = m.name</pre><p>
            Notate che queste ultime due interrogazioni richiederanno pi&ugrave; di una <tt class="literal">SELECT</tt>
            SQL. Questo significa che la clausola <tt class="literal">order by</tt> non ordiner&agrave; correttamente
            l'intero insieme dei risultati. (e significa anche che non potete chiamare le query usando 
            <tt class="literal">Query.scroll()</tt>.)
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-where"></a>11.7.&nbsp;La clausola where</h2></div></div><div></div></div><p>
            La clausola <tt class="literal">where</tt> consente di limitare la lista di istanze rese da una 
            interrogazione.
        </p><pre class="programlisting">from eg.Cat as cat where cat.name='Fritz'</pre><p>
            restituisce le istanze di <tt class="literal">Cat</tt> il cui nome (name) &egrave; 'Fritz'.
        </p><pre class="programlisting">select foo 
from eg.Foo foo, eg.Bar bar
where foo.startDate = bar.date</pre><p>
            restituir&agrave; tutte le istanze di <tt class="literal">Foo</tt> per le quali
            esiste una istanza di <tt class="literal">bar</tt> con una propriet&agrave;
            <tt class="literal">date</tt> uguale alla propriet&agrave; <tt class="literal">startDate</tt> 
            del <tt class="literal">Foo</tt>. Le espressioni a percorso composto fanno s&igrave; che
            la clausola <tt class="literal">where</tt> sia estremamente potente. Considerate:
        </p><pre class="programlisting">from eg.Cat cat where cat.mate.name is not null</pre><p>
            Questa interrogazione si traduce in una query SQL con un join di tabella (interno)
            Se doveste scrivere una cosa come
        </p><pre class="programlisting">from eg.Foo foo  
where foo.bar.baz.customer.address.city is not null</pre><p>
            otterreste una query che richiederebbe quattro join di tabella in SQL.
        </p><p>
            L'operatore <tt class="literal">=</tt> pu&ograve; essere usato per confrontare non solo propriet&agrave;, ma
            anche istanze:
        </p><pre class="programlisting">from eg.Cat cat, eg.Cat rival where cat.mate = rival.mate

select cat, mate 
from eg.Cat cat, eg.Cat mate
where cat.mate = mate</pre><p>
            La propriet&agrave; speciale (in minuscolo) <tt class="literal">id</tt> pu&ograve; essere usata per
            fare riferimento all'identificatore univoco di un oggetto. (potete anche usare il 
            suo nome di propriet&agrave;)
        </p><pre class="programlisting">from eg.Cat as cat where cat.id = 123

from eg.Cat as cat where cat.mate.id = 69</pre><p>
            La seconda query &egrave; efficiente. Non &egrave; richiesto un join di tabella!
        </p><p>
            Possono anche essere usate le propriet&agrave; di identificatori compositi. Supponete che
            <tt class="literal">Person</tt> abbia un identificatore composto che consiste in 
            <tt class="literal">country</tt> e <tt class="literal">medicareNumber</tt>.
        </p><pre class="programlisting">from bank.Person person
where person.id.country = 'AU' 
    and person.id.medicareNumber = 123456

from bank.Account account
where account.owner.id.country = 'AU' 
    and account.owner.id.medicareNumber = 123456</pre><p>
            Ancora una volta, la seconda interrogazione non richiede join di tabella.
        </p><p>
            Nello stesso modo, la propriet&agrave; speciale <tt class="literal">class</tt> accede al valore del 
            discriminatore di una istanza nel caso della persistenza polimorfica. Un nome di classe
            java annidato nella clausola where verr&agrave; tradotto nel suo valore di discriminazione.
        </p><pre class="programlisting">from eg.Cat cat where cat.class = eg.DomesticCat</pre><p>
            Potete anche specificare propriet&agrave; o componenti o tipi utente compositi (e di componenti di 
            componenti, ecc.). Non tentate di utilizzare una espressione di percorso che finisca in una 
            propriet&agrave; di tipo di componente (in opposizione ad una propriet&agrave; di un componente). Ad esempio,
            se <tt class="literal">store.owner</tt> &egrave; una entit&agrave; con un componente indirizzo 
            <tt class="literal">(address)</tt>
        </p><pre class="programlisting">store.owner.address.city    // okay
store.owner.address         // error!</pre><p>
            Un tipo "any" ha le propriet&agrave; speciali <tt class="literal">id</tt> e <tt class="literal">class</tt>,
            che consentono di esprimere un join nel modo seguente (in cui <tt class="literal">AuditLog.item</tt>
            &egrave; una propriet&agrave; mappata con <tt class="literal">&lt;any&gt;</tt>).
        </p><pre class="programlisting">from eg.AuditLog log, eg.Payment payment 
where log.item.class = 'eg.Payment' and log.item.id = payment.id</pre><p>
            Notate che <tt class="literal">log.item.class</tt> e <tt class="literal">payment.class</tt>
            possono fare riferimento ai valori di colonne di database completamente diverse
            nella query precedente.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-expressions"></a>11.8.&nbsp;Espressioni</h2></div></div><div></div></div><p>
            Le espressioni consentite nella clausola <tt class="literal">where</tt> includono
            la maggior parte delle cose che si scriverebbero in SQL:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    operatori matematici <tt class="literal">+, -, *, /</tt>
                </p></li><li><p>
                    operatori di confronto binario <tt class="literal">=, &gt;=, &lt;=, &lt;&gt;, !=, like</tt>
                </p></li><li><p>
                    operazioni logiche <tt class="literal">and, or, not</tt>
                </p></li><li><p>
                    concatenamento di stringhe ||
                </p></li><li><p>
                    funzioni scalari SQL come <tt class="literal">upper()</tt> e
                    <tt class="literal">lower()</tt>
                </p></li><li><p>
                    le parentesi <tt class="literal">( )</tt> indicano i raggruppamenti
                </p></li><li><p>
                    <tt class="literal">in</tt>,
                    <tt class="literal">between</tt>,
                    <tt class="literal">is null</tt>
                </p></li><li><p>
                    parametri di ingresso JDBC <tt class="literal">?</tt>
                </p></li><li><p>
                    parametri con nome <tt class="literal">:name</tt>, <tt class="literal">:start_date</tt>, <tt class="literal">:x1</tt>
                </p></li><li><p>
                    letterali SQL <tt class="literal">'foo'</tt>, <tt class="literal">69</tt>, <tt class="literal">'1970-01-01 10:00:01.0'</tt>
                </p></li><li><p>
                    costanti Java <tt class="literal">public static final</tt> come <tt class="literal">eg.Color.TABBY</tt>
                </p></li></ul></div><p>
            <tt class="literal">in</tt> e <tt class="literal">between</tt> possono essere usati cos&igrave;:
        </p><pre class="programlisting">from eg.DomesticCat cat where cat.name between 'A' and 'B'

from eg.DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )</pre><p>
            e le corrispondenti forme negative possono essere scritte
        </p><pre class="programlisting">from eg.DomesticCat cat where cat.name not between 'A' and 'B'

from eg.DomesticCat cat where cat.name not in ( 'Foo', 'Bar', 'Baz' )</pre><p>
            Nello stesso modo, <tt class="literal">is null</tt> e <tt class="literal">is not null</tt> possono essere usati
            per testare i valori null.
        </p><p>
            I booleani possono essere utilizzati facilmente nelle espressioni dichiarando delle sostituzioni HQL
            nella configurazione di hibernate:
        </p><pre class="programlisting">&lt;property name="hibernate.query.substitutions"&gt;true 1, false 0&lt;/property&gt;</pre><p>
            Questo sostituir&agrave; le parole chiave <tt class="literal">true</tt> e <tt class="literal">false</tt> con i
            letterali <tt class="literal">1</tt> and <tt class="literal">0</tt> nell'SQL tradotto da questo HQL:
        </p><pre class="programlisting">from eg.Cat cat where cat.alive = true</pre><p>
            Potete controllare la dimensione di una collezione con la propriet&agrave; speciale <tt class="literal">size</tt>, o
            la funzione speciale <tt class="literal">size()</tt>.
        </p><pre class="programlisting">from eg.Cat cat where cat.kittens.size &gt; 0

from eg.Cat cat where size(cat.kittens) &gt; 0</pre><p>
            Per le collezioni indicizzate, potete fare riferimento agli indici minimo e massimo usando 
            <tt class="literal">minIndex</tt> e <tt class="literal">maxIndex</tt>. Nello stesso modo, potete fare riferimento
            agli elementi minimo e massimo di una collezione di un tipo di base usando <tt class="literal">minElement</tt> 
            e <tt class="literal">maxElement</tt>.
        </p><pre class="programlisting">from Calendar cal where cal.holidays.maxElement &gt; current date</pre><p>
            Ci sono anche le forme funzionali (le quali, a differenza dei costrutti qui sopra, non sono sensibili a 
            maiuscole e minuscole):
        </p><pre class="programlisting">from Order order where maxindex(order.items) &gt; 100

from Order order where minelement(order.items) &gt; 10000</pre><p>
            Le funzioni SQL <tt class="literal">any, some, all, exists, in</tt> sono supportate quando viene loro 
            passato l'insieme degli elementi o degli indici di una collezione (con le funzioni 
            <tt class="literal">elements</tt> e <tt class="literal">indices</tt>) o il risultato di una sotto-interrogazione
            (vedete oltre).
        </p><pre class="programlisting">select mother from eg.Cat as mother, eg.Cat as kit
where kit in elements(foo.kittens)

select p from eg.NameList list, eg.Person p
where p.name = some elements(list.names)

from eg.Cat cat where exists elements(cat.kittens)

from eg.Player p where 3 &gt; all elements(p.scores)

from eg.Show show where 'fizard' in indices(show.acts)</pre><p>
            Notate che questi costrutti - <tt class="literal">size</tt>, <tt class="literal">elements</tt>,
            <tt class="literal">indices</tt>, <tt class="literal">minIndex</tt>, <tt class="literal">maxIndex</tt>,
            <tt class="literal">minElement</tt>, <tt class="literal">maxElement</tt> - hanno alcune restrizioni
            di utilizzo:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    in una clausola <tt class="literal">where</tt>: solo per database con subselect
                </p></li><li><p>
                    in una clausola <tt class="literal">select</tt>: solo <tt class="literal">elements</tt> e
                    <tt class="literal">indices</tt> hanno senso
                </p></li></ul></div><p>
            Gli elementi delle collezioni indicizzate (array, liste, mappe) possono essere 
            reperiti tramite il loro indice (solo in una clausola where):
        </p><pre class="programlisting">from Order order where order.items[0].id = 1234

select person from Person person, Calendar calendar
where calendar.holidays['national day'] = person.birthDay
    and person.nationality.calendar = calendar

select item from Item item, Order order
where order.items[ order.deliveredItemIndices[0] ] = item and order.id = 11

select item from Item item, Order order
where order.items[ maxindex(order.items) ] = item and order.id = 11</pre><p>
            Le espressioni all'interno di <tt class="literal">[]</tt> possono anche essere espressioni
            matematiche.
        </p><pre class="programlisting">select item from Item item, Order order
where order.items[ size(order.items) - 1 ] = item</pre><p>
            L'HQL fornisce anche la funzione predefinita <tt class="literal">index()</tt>, per gli elementi 
            di una associazione uno-a-molti o una collezione di valori.
        </p><pre class="programlisting">select item, index(item) from Order order 
    join order.items item
where index(item) &lt; 5</pre><p>
            Possono essere usate le funzioni scalari SQL supportate dal database sottostante
        </p><pre class="programlisting">from eg.DomesticCat cat where upper(cat.name) like 'FRI%'</pre><p>
            Se non siete ancora convinti da tutto questo, pensate a quanto pi&ugrave; lunga e meno leggibile sarebbe la 
            query seguente se dovesse essere espressa in SQL:
        </p><pre class="programlisting">select cust
from Product prod,
    Store store
    inner join store.customers cust
where prod.name = 'widget'
    and store.location.name in ( 'Melbourne', 'Sydney' )
    and prod = all elements(cust.currentOrder.lineItems)</pre><p>
            <span class="emphasis"><em>Suggerimento:</em></span> qualcosa come
        </p><pre class="programlisting">SELECT cust.name, cust.address, cust.phone, cust.id, cust.current_order
FROM customers cust,
    stores store,
    locations loc,
    store_customers sc,
    product prod
WHERE prod.name = 'widget'
    AND store.loc_id = loc.id
    AND loc.name IN ( 'Melbourne', 'Sydney' )
    AND sc.store_id = store.id
    AND sc.cust_id = cust.id
    AND prod.id = ALL(
        SELECT item.prod_id
        FROM line_items item, orders o
        WHERE item.order_id = o.id
            AND cust.current_order = o.id
    )</pre></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-ordering"></a>11.9.&nbsp;La clausola order by</h2></div></div><div></div></div><p>
            La lista restituita da una query pu&ograve; essere ordinata secondo una qualsiasi propriet&agrave; di 
            una delle classi restituite o dei componenti:
        </p><pre class="programlisting">from eg.DomesticCat cat
order by cat.name asc, cat.weight desc, cat.birthdate</pre><p>
            Gli elementi opzionali <tt class="literal">asc</tt> o <tt class="literal">desc</tt> indicano rispettivamente ordine 
            ascendente o discendente.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-grouping"></a>11.10.&nbsp;La clausola group by</h2></div></div><div></div></div><p>
            Una interrogazione che renda valori aggregati pu&ograve; essere raggruppata in base a una propriet&agrave; qualunque
            di una delle classi rese o dei componenti:
        </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat) 
from eg.Cat cat
group by cat.color

select foo.id, avg( elements(foo.names) ), max( indices(foo.names) ) 
from eg.Foo foo
group by foo.id</pre><p>
            Nota: potete usare i costrutti <tt class="literal">elements</tt> e <tt class="literal">indices</tt> in
            una clausola select, anche su database senza sub-select.
        </p><p>
            &Egrave; consentita anche la clausola <tt class="literal">having</tt>.
        </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat) 
from eg.Cat cat
group by cat.color 
having cat.color in (eg.Color.TABBY, eg.Color.BLACK)</pre><p>
            Le funzioni SQL e le funzioni aggregate sono consentite nelle clausole <tt class="literal">having</tt>
            e <tt class="literal">order by</tt>, se supportate dal database sottostante (ad esempio non in MySQL).
        </p><pre class="programlisting">select cat
from eg.Cat cat
    join cat.kittens kitten
group by cat
having avg(kitten.weight) &gt; 100
order by count(kitten) asc, sum(kitten.weight) desc</pre><p>
            Notate che n&eacute; la clausola <tt class="literal">group by</tt> n&eacute; la 
            <tt class="literal">order by</tt> possono contenere espressioni aritmetiche.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-subqueries"></a>11.11.&nbsp;Sottointerrogazioni</h2></div></div><div></div></div><p>
            Per i database che supportano i sub-select, Hibernate supporta le sottointerrogazioni all'interno
            delle interrogazioni. Una sottointerrogazione deve essere circondata da parentesi (spesso da una 
            chiamata di funzione aggregata SQL). Sono permesse anche le sottointerrogazioni correlate (ovvero
            quelle che fanno riferimento ad un sinonimo nella interrogazione esterna).
        </p><pre class="programlisting">from eg.Cat as fatcat 
where fatcat.weight &gt; ( 
    select avg(cat.weight) from eg.DomesticCat cat 
)

from eg.DomesticCat as cat 
where cat.name = some ( 
    select name.nickName from eg.Name as name 
)
    
from eg.Cat as cat 
where not exists ( 
    from eg.Cat as mate where mate.mate = cat 
)

from eg.DomesticCat as cat 
where cat.name not in ( 
    select name.nickName from eg.Name as name 
)</pre></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-examples"></a>11.12.&nbsp;Esempi HQL</h2></div></div><div></div></div><p>
            Le interrogazioni di Hibernate possono essere abbastanza potenti e complesse. In effetti, il potere
            del linguaggio di interrogazione &egrave; uno dei principali punti di forza di Hibernate. Qui presentiamo
            alcuni esempi di interrogazioni molto simili a query che sono state usate in un recente procetto. 
            Notate che molte delle interrogazioni che scriverete sono molto pi&ugrave; semplici di queste!
        </p><p>
            La prossima interrogazione restituisce l'id dell'ordine, il numero di oggetti e il valore totale
            dell'ordine per tutti gli ordini non pagati per un cliente particolare e un valore totale minimo,
            ordinando i risultati per valore totale. Nella determinazione dei prezzi, utilizza il catalogo 
            corrente. La query SQL risultante, ha quattro join interni e una subselect non correlata che 
            insistono sulle tabelle <tt class="literal">ORDER</tt>, <tt class="literal">ORDER_LINE</tt>, <tt class="literal">PRODUCT</tt>,
            <tt class="literal">CATALOG</tt> e <tt class="literal">PRICE</tt>.
        </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog.effectiveDate &lt; sysdate
    and catalog.effectiveDate &gt;= all (
        select cat.effectiveDate 
        from Catalog as cat
        where cat.effectiveDate &lt; sysdate
    )
group by order
having sum(price.amount) &gt; :minAmount
order by sum(price.amount) desc</pre><p>
            Che mostro! A dire il vero, nella vita reale non ho molta passione per le sottointerrogazioni, 
            quindi la mia era pi&ugrave; come la seguente:
        </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog = :currentCatalog
group by order
having sum(price.amount) &gt; :minAmount
order by sum(price.amount) desc</pre><p>
            La prossima interrogazione conta il numero di pagamenti in ogni stato, escludendo tutti i 
            pagamenti nello stato <tt class="literal">AWAITING_APPROVAL</tt> quando il cambiamento 
            di stato pi&ugrave; recente era stato fatto dall'utente corrente. Si traduce in una query SLQ con 
            due join interni e una subselect correlata sulle tabelle <tt class="literal">PAYMENT</tt>, 
            <tt class="literal">PAYMENT_STATUS</tt> e <tt class="literal">PAYMENT_STATUS_CHANGE</tt>.
        </p><pre class="programlisting">select count(payment), status.name 
from Payment as payment 
    join payment.currentStatus as status
    join payment.statusChanges as statusChange
where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL
    or (
        statusChange.timeStamp = ( 
            select max(change.timeStamp) 
            from PaymentStatusChange change 
            where change.payment = payment
        )
        and statusChange.user &lt;&gt; :currentUser
    )
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>
            Se avessi mappato la collezione <tt class="literal">statusChanges</tt> come una lista invece di un set, 
            l'interrogazione sarebbe stata molto pi&ugrave; semplice da scrivere.
        </p><pre class="programlisting">select count(payment), status.name 
from Payment as payment
    join payment.currentStatus as status
where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL
    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user &lt;&gt; :currentUser
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>
            La prossima interrogazione usa la funzione <tt class="literal">isNull()</tt> di MS SQL Server 
            per restituire tutti i conti e i pagamenti non effettuati per l'organizzazione a cui 
            l'utente corrente appartiene. Si traduce in una query SQL con tre join interni, un join 
            esterno e una subselect sulle tabelle <tt class="literal">ACCOUNT</tt>, <tt class="literal">PAYMENT</tt>, 
            <tt class="literal">PAYMENT_STATUS</tt>, <tt class="literal">ACCOUNT_TYPE</tt>, <tt class="literal">ORGANIZATION</tt> e
            <tt class="literal">ORG_USER</tt>.
        </p><pre class="programlisting">select account, payment
from Account as account
    left outer join account.payments as payment
where :currentUser in elements(account.holder.users)
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre><p>
            Per alcuni database, avremmo bisogno di fare a meno della subselect correlata.
        </p><pre class="programlisting">select account, payment
from Account as account
    join account.holder.users as user
    left outer join account.payments as payment
where :currentUser = user
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-tipstricks"></a>11.13.&nbsp;Suggerimenti</h2></div></div><div></div></div><p>
            Potete contare il numero dei risultati di una interrogazione senza restituirli veramente:
        </p><pre class="programlisting">( (Integer) session.iterate("select count(*) from ....").next() ).intValue()</pre><p>
            Per ordinare un risultato per dimensione di una collezione, usate l'interrogazione seguente:
        </p><pre class="programlisting">select usr.id, usr.name
from User as usr 
    left join usr.messages as msg
group by usr.id, usr.name
order by count(msg)</pre><p>
            Se il vostro database supporta le sottointerrogazioni, potete mettere una condizione sulla
            dimensione della selezione nella clausola where della vostra query:
        </p><pre class="programlisting">from User usr where size(usr.messages) &gt;= 1</pre><p>
            Mentre se il database non supporta i subselect potete usare la query seguente:
        </p><pre class="programlisting">select usr.id, usr.name
from User usr.name
    join usr.messages msg
group by usr.id, usr.name
having count(msg) &gt;= 1</pre><p>
            Poich&eacute; questa soluzione non pu&ograve; restituire uno <tt class="literal">User</tt> con zero messaggi
            a causa del join interno, &egrave; anche utile la forma seguente:
        </p><pre class="programlisting">select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
having count(msg) = 0</pre><p>
            Le propriet&agrave; di un javabean possono essere assegnate a parametri della query con nome:
        </p><pre class="programlisting">Query q = s.createQuery("from foo in class Foo where foo.name=:name and foo.size=:size");
q.setProperties(fooBean); // fooBean has getName() and getSize()
List foos = q.list();</pre><p>
            Le collezioni sono paginabili usando l'interfaccia <tt class="literal">Query</tt> con un filtro:
        </p><pre class="programlisting">Query q = s.createFilter( collection, "" ); // the trivial filter
q.setMaxResults(PAGE_SIZE);
q.setFirstResult(PAGE_SIZE * pageNumber);
List page = q.list();</pre><p>
            Gli elementi delle collezioni possono essere ordinati o raggruppati usando un filtro di 
            interrogazione:
        </p><pre class="programlisting">Collection orderedCollection = s.filter( collection, "order by this.amount" );
Collection counts = s.filter( collection, "select this.type, count(this) group by this.type" );</pre><p>
            Potete individuare la dimensione di una collezione senza inizializzarla:
        </p><pre class="programlisting">( (Integer) session.iterate("select count(*) from ....").next() ).intValue();</pre></div></div><div class="chapter" lang="it"><div class="titlepage"><div><div><h2 class="title"><a name="querycriteria"></a>Capitolo&nbsp;12.&nbsp;Interrogazioni per criteri</h2></div></div><div></div></div><p>
        Hibernate ora offre una API di interrogazione per criteri intuitiva ed estensibile. Per
        ora quest'API &egrave; meno potente delle pi&ugrave; mature funzionalit&agrave; di interrogazione HQL. In 
        particolare, le interrogazioni per criteri non supportano la proiezione o l'aggregazione.
    </p><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-creating"></a>12.1.&nbsp;Creazione di un'istanza di <tt class="literal">Criteria</tt></h2></div></div><div></div></div><p>
            L'interfaccia <tt class="literal">net.sf.hibernate.Criteria</tt> rappresenta un'interrogazione
            nei confronti di una particolare classe persistente. La <tt class="literal">Session</tt> &egrave; un
            produttore di istanze di <tt class="literal">Criteria</tt>.
        </p><pre class="programlisting">Criteria crit = sess.createCriteria(Cat.class);
crit.setMaxResults(50);
List cats = crit.list();</pre></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-narrowing"></a>12.2.&nbsp;Riduzione dell'insieme dei risultati</h2></div></div><div></div></div><p>
            Un criterio individuale di interrogazione &egrave; un'istanza dell'interfaccia
            <tt class="literal">net.sf.hibernate.expression.Criterion</tt>. La classe
            <tt class="literal">net.sf.hibernate.expression.Expression</tt> definisce 
            metodi "factory" (produttori) per otteere alcuni tipi predefiniti di 
            <tt class="literal">Criterion</tt>.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Expression.like("name", "Fritz%") )
    .add( Expression.between("weight", minWeight, maxWeight) )
    .list();</pre><p>
            Le espressioni possono essere raggruppate logicamente.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Expression.like("name", "Fritz%") )
    .add( Expression.or(
        Expression.eq( "age", new Integer(0) ),
        Expression.isNull("age")
    ) )
    .list();</pre><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Expression.in( "name", new String[] { "Fritz", "Izi", "Pk" } ) )
    .add( Expression.disjunction()
        .add( Expression.isNull("age") )
    	.add( Expression.eq("age", new Integer(0) ) )
    	.add( Expression.eq("age", new Integer(1) ) )
    	.add( Expression.eq("age", new Integer(2) ) )
    ) )
    .list();</pre><p>
            C'&egrave; un certo numero di tipi di criterio predefiniti (sottoclassi di <tt class="literal">Expression</tt>
            ), ma uno di essi &egrave; particolarmente utile, perch&eacute; consente di specificare direttamente dell'SQL.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Expression.sql("lower({alias}.name) like lower(?)", "Fritz%", Hibernate.STRING) )
    .list();</pre><p>
            il segnaposto <tt class="literal">{alias}</tt> verr&agrave; sostituito dall'alias di riga della 
            entit&agrave; su cui si sta facendo l'interrogazione.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-ordering"></a>12.3.&nbsp;Ordinamento dei risultati</h2></div></div><div></div></div><p>
            &Egrave; possibile ordinare i risultati utilizzando 
            <tt class="literal">net.sf.hibernate.expression.Order</tt>.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Expression.like("name", "F%")
    .addOrder( Order.asc("name") )
    .addOrder( Order.desc("age") )
    .setMaxResults(50)
    .list();</pre></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-associations"></a>12.4.&nbsp;Associazioni</h2></div></div><div></div></div><p>
            Potete specificare semplicemente vincoli su entit&agrave; correlate navigando
            le associazioni utilizzando <tt class="literal">createCriteria()</tt>.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Expression.like("name", "F%")
    .createCriteria("kittens")
        .add( Expression.like("name", "F%")
    .list();</pre><p>
            notate che il secondo <tt class="literal">createCriteria()</tt> restituisce 
            una nuova istanza di <tt class="literal">Criteria</tt> che si riferisce agli elementi
            della collezione <tt class="literal">kittens</tt>.
        </p><p>
            La forma alternativa seguente &egrave; utile in alcune circostanze.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .createAlias("kittens", "kt")
    .createAlias("mate", "mt")
    .add( Expression.eqProperty("kt.name", "mt.name") )
    .list();</pre><p>
            (<tt class="literal">createAlias()</tt> non crea una nuova istanza di 
            <tt class="literal">Criteria</tt>.)
        </p><p>
            Notate che le collezioni kittens che appartengono alle istanze di <tt class="literal">Cat</tt> 
            restituita dalle due interrogazioni precedenti <span class="emphasis"><em>non sono</em></span> pre-filtrate
            dal criterio! Se volete recuperare solo i gattini che corrispondano al criterio, dovete 
            utilizzare <tt class="literal">returnMaps()</tt>.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .createCriteria("kittens", "kt")
        .add( Expression.eq("name", "F%") )
    .returnMaps()
    .list();
Iterator iter = cats.iterator();
while ( iter.hasNext() ) {
    Map map = (Map) iter.next();
    Cat cat = (Cat) map.get(Criteria.ROOT_ALIAS);
    Cat kitten = (Cat) map.get("kt");
}</pre></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-dynamicfetching"></a>12.5.&nbsp;Caricamento dinamico delle associazioni</h2></div></div><div></div></div><p>
            Usando il metodo <tt class="literal">setFetchMode()</tt> &egrave; possibile specificare la semantica di 
            caricamento delle associazioni in fase di esecuzione.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Expression.like("name", "Fritz%") )
    .setFetchMode("mate", FetchMode.EAGER)
    .setFetchMode("kittens", FetchMode.EAGER)
    .list();</pre><p>
            Questa interrogazione caricher sia <tt class="literal">mate</tt> sia <tt class="literal">kittens</tt>
            tramite join esterni.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-examples"></a>12.6.&nbsp;Interrogazioni per esempi</h2></div></div><div></div></div><p>
            La classe <tt class="literal">net.sf.hibernate.expression.Example</tt> 
            permette di costruire un criterio di interrogazione a partire 
            da una data istanza.
        </p><pre class="programlisting">Cat cat = new Cat();
cat.setSex('F');
cat.setColor(Color.BLACK);
List results = session.createCriteria(Cat.class)
    .add( Example.create(cat) )
    .list();</pre><p>
           Le propriet&agrave; di versione, gli identificatori e le associazioni vengono
           ignorati. Il comportamento predefinito &egrave; di escludere le propriet&agrave; di 
           valore null.
        </p><p>
           Potete impostare come l'<tt class="literal">Example</tt> venga applicato.
        </p><pre class="programlisting">Example example = Example.create(cat)
    .excludeZeroes()           //exclude zero valued properties
    .excludeProperty("color")  //exclude the property named "color"
    .ignoreCase()              //perform case insensitive string comparisons
    .enableLike();             //use like for string comparisons
List results = session.createCriteria(Cat.class)
    .add(example)
    .list();</pre><p>
            Potete anche usare gli esempi per impostare criteri sugli oggetti
            associati.
        </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .add( Example.create(cat) )
    .createCriteria("mate")
        .add( Example.create( cat.getMate() ) )
    .list();</pre></div></div><div class="chapter" lang="it"><div class="titlepage"><div><div><h2 class="title"><a name="querysql"></a>Capitolo&nbsp;13.&nbsp;Interrogazioni SQL native</h2></div></div><div></div></div><p>
        Potete anche esprimere interrogazioni nel dialetto SQL nativo del vostro database. &Egrave; una
        cosa particolarmente utile se volete utilizzare funzionalit&agrave; specifiche del database come 
        la parola chiave CONNECT in Oracle. Ci&ograve; consente anche di seguire un percorso di migrazione
        pi&ugrave; pulito da una applicazione direttamente basata su SQL/JDBC ad una che si appoggi ad
        Hibernate.
    </p><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-creating"></a>13.1.&nbsp;Creazione di una <tt class="literal">Query</tt> basaa su SQL</h2></div></div><div></div></div><p>
            Le interrogazioni SQL sono esposte tramite l'interfaccia <tt class="literal">Query</tt>, proprio come
            le normali interrogazioni HQL. La sola differenza &egrave; nell'uso del metodo <tt class="literal">Session.createSQLQuery()</tt>.
        </p><pre class="programlisting">Query sqlQuery = sess.createSQLQuery("select {cat.*} from cats {cat}", "cat", Cat.class);
sqlQuery.setMaxResults(50);
List cats = sqlQuery.list();</pre><p>
            I tre parametri forniti al metodo <tt class="literal">createSQLQuery()</tt> sono:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
            la stringa con l'interrogazione SQL
        </p></li><li><p>
            il nome di un alias di tabella
        </p></li><li><p>
            la classe persistente restituita dall'interrogazione
        </p></li></ul></div><p>
            Il nome dell'alias viene usato nella stringa sql per riferirsi alle propriet&agrave; della classe
            mappata (in questo caso <tt class="literal">Cat</tt>). Potete recuperare oggetti multipli per
            riga fornendo un array di <tt class="literal">String</tt> con i nomi degli alias e un array di 
            <tt class="literal">Class</tt> per le classi corrispondenti.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-aliasreferences"></a>13.2.&nbsp;Alias e riferimenti alle propriet&agrave;</h2></div></div><div></div></div><p>
            La notazione <tt class="literal">{cat.*}</tt> usata sopra &egrave; un'abbreviazione per "tutte le propriet&agrave;".
            Potete anche elencare esplicitamente le propriet&agrave;, ma dovete lasciare che Hibernate fornisca
            alias di colonna per ogni propriet&agrave;. Le etichette per gli alias di queste colonne sono il nome
            della propriet&agrave; preceduto dall'alias di tabella. 
            Nell'esempio seguente, recuperiamo oggetti <tt class="literal">Cat</tt> da una tabella diversa 
            (<tt class="literal">cat_log</tt>) rispetto a quella dichiarata nei metadati di mappaggio. Notate
             che possiamo anche usare gli alias di propriet&agrave; nelle clausole "where".
        </p><pre class="programlisting">String sql = "select cat.originalId as {cat.id}, "
    + "  cat.mateid as {cat.mate}, cat.sex as {cat.sex}, "
    + "  cat.weight*10 as {cat.weight}, cat.name as {cat.name}"
    + "     from cat_log cat where {cat.mate} = :catId"
List loggedCats = sess.createSQLQuery(sql, "cat", Cat.class)
    .setLong("catId", catId)
    .list();
</pre><p>
            <span class="emphasis"><em>Nota:</em></span> se elencate esplicitamente ogni propriet&agrave;, dovete includere tutte le 
            propriet&agrave; della classe <span class="emphasis"><em>e delle sue sottoclassi</em></span>!
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-namedqueries"></a>13.3.&nbsp;Interrogazioni SQL con nome</h2></div></div><div></div></div><p>
            Le interrogazioni SQL con nome possono venire definite nel documento di mappaggio e chiamate
            esattamente nello stesso modo in cui viene chiamata una interrogazione HQL con nome.
        </p><pre class="programlisting">List people = sess.getNamedQuery("mySqlQuery")
    .setMaxResults(50)
    .list();</pre><pre class="programlisting">&lt;sql-query name="mySqlQuery"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    SELECT {person}.NAME AS {person.name},
           {person}.AGE AS {person.age},
           {person}.SEX AS {person.sex}
    FROM PERSON {person} WHERE {person}.NAME LIKE 'Hiber%'
&lt;/sql-query&gt;</pre></div></div><div class="chapter" lang="it"><div class="titlepage"><div><div><h2 class="title"><a name="performance"></a>Capitolo&nbsp;14.&nbsp;Ottimizzare le prestazioni di Hibernate</h2></div></div><div></div></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-collections"></a>14.1.&nbsp;Capire gli aspetti legati alle prestazioni delle collezioni</h2></div></div><div></div></div><p>
            Abbiamo gi&agrave; parlato delle collezioni da un punto di vista funzionale. 
            In questa sezione mettiamo in evidenza alcune questioni legate a come le
            collezioni si comportano durante l'esecuzione
        </p><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-taxonomy"></a>14.1.1.&nbsp;Tassonomia</h3></div></div><div></div></div><p>Hibernate definisce tre tipi fondamentali di collezioni:</p><div class="itemizedlist"><ul type="disc"><li><p>collezioni di valori</p></li><li><p>associazioni uno-a-molti</p></li><li><p>associazioni molti-a-molti</p></li></ul></div><p>
                Questa classificazione distingue le varie relazioni tra tabelle e chiavi
                esterne, ma non ci dice abbastanza di quello che ci interessa sul modello
                relazionale. Per capire completamente la struttura relazionale e le
                caratteristiche di performance, dobbiamo anche prendere in cosiderazione
                la struttura della chiave primaria che viene usata da Hibernate per 
                modificare o cancellare le righe corrispondenti alla collezione. Questo
                suggerisce la classificazione seguente:
            </p><div class="itemizedlist"><ul type="disc"><li><p>collezioni con indice (indexed collection)</p></li><li><p>insiemi (set)</p></li><li><p>"sacchi" (bags)</p></li></ul></div><p>
                Tutte le collezioni indicizzate (mappe, liste, array) hanno una chiave primaria
                che consiste nelle colonne <tt class="literal">&lt;key&gt;</tt> (chiave) e <tt class="literal">&lt;index&gt;</tt>
                (indice). Solitamente in questi casi gli aggiornamenti delle collezioni sono molto performanti, poich&eacute; la
                chiave primaria pu&ograve; essere indicizzata in modo efficiente e una riga particolare pu&ograve; quindi essere 
                localizzata rapidamente quando Hibernate cerca di modificarla o cancellarla.
            </p><p>
                Gli insiemi hanno una chiave primaria che consiste delle colonne <tt class="literal">&lt;key&gt;</tt> 
                ed <tt class="literal">&lt;element&gt;</tt>. Questo pu&ograve; essere meno efficiente per alcuni tipi di 
                elemento della collezione, in particolare per elementi composti o campi molto lunghi di testo o 
                dati binari; il database pu&ograve; non essere in grado di indicizzare una chiave primaria complessa in 
                maniera altrettanto efficiente che nel caso precedente. Da un altro punto di vista, per associazioni
                uno-a-molti o molti-a-molti, in particolare nel caso di identificatori sintetici, &egrave; probabile che sia
                efficiente nello stesso modo. (annotazione: se volete che <tt class="literal">SchemaExport</tt> crei davvero
                la chiave primaria di un <tt class="literal">&lt;set&gt;</tt> per voi, dovete dichiarare tutte le colonne come
                <tt class="literal">not-null="true"</tt>.)
            </p><p>
                I "sacchi" (bags) sono il caso peggiore. Poich&eacute; un bag consente elementi duplicati e non ha 
                una colonna indice, non pu&ograve; essere definita una chiave primaria. Hibernate non ha modo di 
                distinguere tra righe duplicate, e quindi risolve il problema rimuovendo completamente (con
                una singola <tt class="literal">DELETE</tt>) e ricreando la collezione ogni volta che cambia. 
                Questo tuttavia pu&ograve; essere molto inefficiente.
            </p><p>
                Notate che per una collezione uno-a-molti, la "chiave primaria" pu&ograve; non essere la
                chiave primaria fisica della tabella del database - ma anche in questo caso la
                classificazione qui sopra &egrave; comunque utile, poich&eacute; riflette come Hibernate recupera
                righe specifiche della collezione.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-mostefficientupdate"></a>14.1.2.&nbsp;Liste, mappe e insiemi sono le collezioni pi&ugrave; efficienti da modificare</h3></div></div><div></div></div><p>
                Dalla discussione di cui sopra, dovrebbe essere chiaro che le collezioni indicizzate 
                e (di solito) gli insiemi consentono le operazioni pi&ugrave; efficienti in termini di 
                aggiunta, rimozione e modifica di elementi.
            </p><p>
                C'&egrave; un vantaggio ulteriore che le collezioni indicizzate hanno rispetto agli insiemi
                per le associazioni molti-a-molti o le collezioni di valori. Per come &egrave; fatta la struttura 
                di un <tt class="literal">Set</tt>, Hibernate non aggiorna neppure (<tt class="literal">UPDATE</tt>) 
                una riga, quando un elemento &egrave; "cambiato". I cambiamenti ad un <tt class="literal">Set</tt> 
                funzionano semper via <tt class="literal">INSERT</tt> e <tt class="literal">DELETE</tt> (di righe individuali). 
                Ancora una volta, ripetiamo che questa considerazione non si applica alle associazioni uno-a-molti.
            </p><p>
                Poich&eacute; ricordiamo che gli array non possono essere caricati a richiesta (lazy), concludiamo quindi
                che le liste, le mappe e gli insiemi sono i tipi di collezione pi&ugrave; performanti. (Con l'avvertimento,
                ancora una volta, che un set pu&ograve; essere meno efficiente per alcune collezioni di valori)
            </p><p>
                Gli insiemi sono probabilmente il genere di collezione pi&ugrave; comune nelle applicazioni basate su Hibernate.
            </p><p>
                <span class="emphasis"><em>C'&egrave; una funzionalit&agrave; non documentata in questa versione di Hibernate. Il mappaggio
                <tt class="literal">&lt;idbag&gt;</tt> implementa una semantica a "bag" per una collezione 
                di valori o una associazione molti-a-molti ed &egrave; pi&ugrave; efficiente di qualsiasi altro stile 
                di collezione, in questo caso!</em></span>
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-mostefficentinverse"></a>14.1.3.&nbsp;I bag e le liste sono le collezioni inverse pi&ugrave; efficienti</h3></div></div><div></div></div><p>
                Prima che buttiate via i "bag" per sempre, c'&egrave; un caso particolare in cui essi (e le liste)
                sono molto pi&ugrave; performanti degli insiemi. Per una collezione con <tt class="literal">inverse="true"</tt>
                (l'idioma standard per una relazione uno-a-molti, ad esempio) possiamo aggiungere elementi ad 
                un bag o una lista senza bisogno di inizializzare (fetch) gli elementi del bag stesso! Questo 
                perch&eacute; <tt class="literal">Collection.add()</tt> o <tt class="literal">Collection.addAll()</tt> devono 
                sempre ritornare "true" per un bag o una <tt class="literal">List</tt> (a differenza di un 
                <tt class="literal">Set</tt>). Questo pu&ograve; rendere il codice seguente molto pi&ugrave; veloce:
            </p><pre class="programlisting">Parent p = (Parent) sess.load(Parent.class, id);
    Child c = new Child();
    c.setParent(p);
    p.getChildren().add(c);  //no need to fetch the collection!
    sess.flush();</pre></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-oneshotdelete"></a>14.1.4.&nbsp;Cancellazione in un colpo solo</h3></div></div><div></div></div><p>
                Di tanto in tanto, cancellare elementi di una collezione ad uno ad uno pu&ograve; essere estremamente 
                inefficiente. Hibernate non &egrave; completamente stupido, per cui sa che non deve farlo nel caso in cui
                una collezione sia stata appena svuotata (tramite <tt class="literal">list.clear()</tt>, ad esempio).
                In questo caso, Hibernate utilizzer&agrave; una singola <tt class="literal">DELETE</tt> ed &egrave; tutto!
            </p><p>
                Supponiamo di aggiungere un elemento singolo ad una collezione di dimensione venti, e poi rimuovere
                due elementi. Hibernate lancer&agrave; una <tt class="literal">INSERT</tt> e due <tt class="literal">DELETE</tt>
                (a meno che la collezione sia un bag). Questo &egrave; certamente auspicabile.
            </p><p>
                Per&ograve;, supponiamo di rimuovere diciotto elementi, lasciandone due, e poi di aggiungere tre elementi
                nuovi. Ci sono due modi possibili di procedere.
            </p><div class="itemizedlist"><ul type="disc"><li><p>cancellare le diciotto righe una ad una e poi inserire le tre</p></li><li><p>rimuovere tutta la collezione in un solo comando <tt class="literal">DELETE</tt> e inserire tutti i 
                cinque elementi rimanenti uno ad uno</p></li></ul></div><p>
                Hibernate non &egrave; abbastanza furbo da sapere che la seconda opzione &egrave; probabilmente pi&ugrave; veloce, 
                in questo caso. (e probabilmente non sarebbe auspicabile che Hibernate lo fosse, perch&eacute; un
                comportamento del genere pu&ograve; confondere dei trigger, ecc.)
            </p><p>
                Fortunatamente, potete imporre questo comportamento (cio&egrave; la seconda strategia) in ogni momento
                scartando (cio&egrave; dereferenziando) la collezione originale ed impostando una nuova collezione con 
                tutti gli elementi che devono rimanere. Questo pu&ograve; essere molto utile e potente, in certi casi.
            </p></div></div><p>
        Abbiamo gi&agrave; mostrato come si pu&ograve; usare l'inizializzazione a richiesta (lazy) per le collezioni 
        persistenti nel capitolo sui mappaggi delle collezioni. Un effetto simile si pu&ograve; ottenere per
        i riferimenti agli oggetti comuni, usando i mediatori (proxy) CGLIB. Abbiamo anche detto
        che Hibernate fa il caching degli oggetti persistenti al livello della <tt class="literal">Session</tt>. 
        &Egrave; comunque possibile impostare strategie di caching pi&ugrave; aggressive per classi specifiche. 
    </p><p>
        Nella prossima sezione, vi mostriamo come usare queste funzionalit&agrave;, e quindi raggiungere
        prestazioni pi&ugrave; elevate quando necessario.
    </p><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-proxies"></a>14.2.&nbsp;Mediatori (proxy) per l'inizializzazione a richiesta (lazy)</h2></div></div><div></div></div><p>
            Hibernate implementa un sistema per l'inizializzazione ritardata (lazy) degli oggetti
            persistenti tramite dei mediatori (proxy) creati in fase di esecuzione tramite una tecnica
            di arricchimento del codice binario (byte-code) che sfrutta le funzionalit&agrave; fornite 
            dall'eccellente libreria CGLIB.        </p><p>
            Il file di mappaggio dichiara una classe o un'interfaccia che va usata come
            interfaccia del proxy per quella classe. L'approccio raccomandato &egrave; specificare
            la classe stessa:
        </p><pre class="programlisting">&lt;class name="eg.Order" proxy="eg.Order"&gt;</pre><p>
            Il tipo dei proxy in fase di esecuzione sar&agrave; una sottoclasse di <tt class="literal">Order</tt>. Notate
            che la classe "mediata" (proxied) deve implementare un costruttore di default per lo meno con 
            visibilit&agrave; a livello di package.
        </p><p>
            Ci sono alcune peculiarit&agrave; di cui essere a conoscenza, quando si estende questo
            approccio alle classi polimorfiche, ad esempio:
        </p><pre class="programlisting">&lt;class name="eg.Cat" proxy="eg.Cat"&gt;
    ......
    &lt;subclass name="eg.DomesticCat" proxy="eg.DomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
            Prima di tutto, le istanze di <tt class="literal">Cat</tt> non potranno essere oggetto 
            di "cast" a <tt class="literal">DomesticCat</tt>, anche se l'istanza sottostante &egrave; 
            effettivamente un <tt class="literal">DomesticCat</tt>.
        </p><pre class="programlisting">Cat cat = (Cat) session.load(Cat.class, id);  // instantiate a proxy (does not hit the db)
if ( cat.isDomesticCat() ) {                  // hit the db to initialize the proxy
    DomesticCat dc = (DomesticCat) cat;       // Error!
    ....
}</pre><p>
            In secondo luogo, &egrave; possibile che la semantica di <tt class="literal">==</tt> non valga per il proxy.
        </p><pre class="programlisting">
Cat cat = (Cat) session.load(Cat.class, id);            // instantiate a Cat proxy
DomesticCat dc = 
    (DomesticCat) session.load(DomesticCat.class, id);  // required new DomesticCat proxy!
System.out.println(cat==dc);                            // false</pre><p>
            Comunque, queste situazioni non sono poi cos&igrave; male come sembra. Anche se ora abbiamo due 
            riferimenti diversi ad oggetti proxy, l'istanza sottostante &egrave; comunque la stessa:
        </p><pre class="programlisting">cat.setWeight(11.0);  // hit the db to initialize the proxy
System.out.println( dc.getWeight() );  // 11.0</pre><p>
            Terzo, non &egrave; possibile usare un mediatore CGLIB per una classe <tt class="literal">final</tt> 
            o per una classe con metodi <tt class="literal">final</tt>.
        </p><p>
            Infine, se il vostro oggetto persistente acquisisce delle risorse in fase di istanziazione
            (ad esempio negli inizializzatori o nel costruttore di default), quelle risorse saranno 
            acquisite anche dal proxy, poich&eacute; la classe del proxy &egrave; effettivamente 
            una sottoclasse della classe persistente.
        </p><p>
            Questi problemi sono tutti derivanti da limitazioni di base nel modello a ereditariet&agrave; 
            singola di Java. Se volete evitarli, le vostre classi persistenti devono implementare 
            un'interfaccia che dichiari i loro metodi di business. Dovete poi specificare queste interfacce
            nel file di mapping, ad esempio cos&igrave;:
        </p><pre class="programlisting">&lt;class name="eg.Cat" proxy="eg.ICat"&gt;
    ......
    &lt;subclass name="eg.DomesticCat" proxy="eg.IDomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
            laddove <tt class="literal">Cat</tt> implementa l'interfaccia <tt class="literal">ICat</tt> e
            <tt class="literal">DomesticCat</tt> implementa l'interfaccia <tt class="literal">IDomesticCat</tt>. 
            A questo punto, <tt class="literal">load()</tt> o <tt class="literal">iterate()</tt> possono restituire 
            direttamente istanze di <tt class="literal">Cat</tt> e <tt class="literal">DomesticCat</tt> . (Notate che
            <tt class="literal">find()</tt> non restituisce mediatori.)
        </p><pre class="programlisting">ICat cat = (ICat) session.load(Cat.class, catid);
Iterator iter = session.iterate("from cat in class eg.Cat where cat.name='fritz'");
ICat fritz = (ICat) iter.next();</pre><p>
            Anche le relazioni sono inizializzate in maniera ritardata. Questo significa che dovete dichiarare
            le propriet&agrave; di tipo <tt class="literal">ICat</tt>, e non <tt class="literal">Cat</tt>.
        </p><p>
            Alcune operazioni <span class="emphasis"><em>non</em></span> richiedono inizializzazione del proxy
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">equals()</tt>, se la classe persistente non sovrascrive
                    <tt class="literal">equals()</tt>
                </p></li><li><p>
                    <tt class="literal">hashCode()</tt>, se la classe persistente non sovrascrive
                    <tt class="literal">hashCode()</tt>
                </p></li><li><p>
                    Il metodo "getter" per l'identificatore.
                </p></li></ul></div><p>
            Hibernate individuer&agrave; le classi persistenti che sovrascrivono <tt class="literal">equals()</tt> o
            <tt class="literal">hashCode()</tt>.
        </p><p>
            Le eccezioni che capitano quando si inizializza un proxy vengono 
            racchiuse in una <tt class="literal">LazyInitializationException</tt>.
        </p><p>
            In alcuni casi, dobbiamo assicuarci che un mediatore o una collezione vengano inizializzati
            prima di chiudere la <tt class="literal">Session</tt>. Naturalmente, possiamo sempre forzare l'inizializzazione
            chiamando <tt class="literal">cat.getSex()</tt> o <tt class="literal">cat.getKittens().size()</tt>, ad esempio.
            Ma questo confonde chi legge il codice e non &egrave; pratico per del codice generico. I metodi statici 
            <tt class="literal">Hibernate.initialize()</tt> e <tt class="literal">Hibernate.isInitialized()</tt>
            forniscono all'applicazione un modo comodo per lavorare con collezioni inizializzate a richiesta
            o con i mediatori. <tt class="literal">Hibernate.initialize(cat)</tt> imporr&agrave; l'inizializzazione di un mediatore
            <tt class="literal">cat</tt>, a condizione che la sua <tt class="literal">Session</tt> sia ancora aperta.
            <tt class="literal">Hibernate.initialize( cat.getKittens() )</tt> ha un effetto simile per la collezione dei gattini
            (kitten ;) ). 
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-cache"></a>14.3.&nbsp;La cache di secondo livello</h2></div></div><div></div></div><p>
            Una <tt class="literal">Session</tt> di Hibernate &egrave; una cache di dati persistenti durante la transazione.
            &Egrave; possibile configurare una cache a livello di cluster o a livello di macchina virtuale (JVM-level o 
            <tt class="literal">SessionFactory</tt>-level) per classi o collezioni specifiche. &Egrave; anche possibile 
            agganciare (plug-in) una cache in cluster. Fate attenzione, tuttavia: le cache non sono mai coscienti
            di cambiamenti fatti ai dati sul contentitore fisico da un'altra applicazione (bench&eacute; possano essere
            configurate in modo tale da fare scadere i dati conservati in memoria).
        </p><p>
            L'impostazione predefinita di Hibernate &egrave; di usare la libreria EHCache per il caching a livello di JVM 
            (Il supporto di JCS &egrave; deprecato e verr&agrave; rimosso in una versione futura di Hibernate). &Egrave; possibile
            scegliere una implementazione diversa speficicando il nome di una classe che implementi
            <tt class="literal">net.sf.hibernate.cache.CacheProvider</tt> usando la propriet&agrave;
            <tt class="literal">hibernate.cache.provider_class</tt>.
        </p><div class="table"><a name="d0e8628"></a><p class="title"><b>Tabella&nbsp;14.1.&nbsp;Fornitori di cache</b></p><table summary="Fornitori di cache" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Cache</th><th align="left">Classe fornitore</th><th align="left">Tipo</th><th align="left">Funziona in cluster</th><th align="left">Supporta interrogazione della cache</th></tr></thead><tbody><tr><td align="left">Hashtable (non adatta per un uso in produzione)</td><td align="left"><tt class="literal">net.sf.hibernate.cache.HashtableCacheProvider</tt></td><td align="left">memoria</td><td align="left">&nbsp;</td><td align="left">s&igrave;</td></tr><tr><td align="left">EHCache</td><td align="left"><tt class="literal">net.sf.ehcache.hibernate.Provider</tt></td><td align="left">memoria, disco</td><td align="left">&nbsp;</td><td align="left">s&igrave;</td></tr><tr><td align="left">OSCache</td><td align="left"><tt class="literal">net.sf.hibernate.cache.OSCacheProvider</tt></td><td align="left">memoria, disco</td><td align="left">&nbsp;</td><td align="left">s&igrave;</td></tr><tr><td align="left">SwarmCache</td><td align="left"><tt class="literal">net.sf.hibernate.cache.SwarmCacheProvider</tt></td><td align="left">cluster (via ip multicast)</td><td align="left">s&igrave; (invalidazione sul cluster)</td><td align="left">&nbsp;</td></tr><tr><td align="left">JBoss TreeCache</td><td align="left"><tt class="literal">net.sf.hibernate.cache.TreeCacheProvider</tt></td><td align="left">cluster (via ip multicast), transazionale</td><td align="left">s&igrave; (replicazione)</td><td align="left">&nbsp;</td></tr></tbody></table></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-mapping"></a>14.3.1.&nbsp;Mappaggi e cache</h3></div></div><div></div></div><p>
                L'elemento <tt class="literal">&lt;cache&gt;</tt> per il mappaggio di una classe o di una collezione
                ha la forma seguente:
            </p><div class="programlistingco"><pre class="programlisting">&lt;cache 
    usage="transactional|read-write|nonstrict-read-write|read-only"  <span class="co">(1)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">usage</tt> specifica la strategia di caching:
                            <tt class="literal">transactional</tt>,
                            <tt class="literal">read-write</tt>,
                            <tt class="literal">nonstrict-read-write</tt> or
                            <tt class="literal">read-only</tt>
                        </p></td></tr></table></div></div><p>
                In alternativa (preferibilmente), si possono specificare gli elementi <tt class="literal">&lt;class-cache&gt;</tt> e 
                <tt class="literal">&lt;collection-cache&gt;</tt> in <tt class="literal">hibernate.cfg.xml</tt>.
            </p><p>
                L'attributo <tt class="literal">usage</tt> speficica una <span class="emphasis"><em>strategia di concorrenza per la cache</em></span>.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-readonly"></a>14.3.2.&nbsp;Strategia: sola lettura</h3></div></div><div></div></div><p>
                Se la vostra applicazione ha bisogno di leggere ma non modifica mai istanze di una classe
                persistente, si pu&ograve; usare una cache <tt class="literal">read-only</tt> (sola lettura). Si tratta della 
                strategia pi&ugrave; semplice e pi&ugrave; performante. Funziona anche perfettamente in un cluster.
            </p><pre class="programlisting">&lt;class name="eg.Immutable" mutable="false"&gt;
    &lt;cache usage="read-only"/&gt;
    ....
&lt;/class&gt;</pre></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-readwrite"></a>14.3.3.&nbsp;Strategia: lettura/scrittura</h3></div></div><div></div></div><p>
                Se l'applicazione deve modificare i dati, una cache <tt class="literal">read-write</tt> (lettura/scrittura)
                potrebbe essere appropriata. Questa strategia di caching non dovrebbe essere mai usata se &egrave; richiesto
                un livello di isolamento serializzabile delle transazioni. Se la cache &egrave; usata in un ambiente JTA,
                dovete specificare la propriet&agrave; <tt class="literal">hibernate.transaction.manager_lookup_class</tt>, 
                indicando una strategia per ottenere il <tt class="literal">TransactionManager</tt> JTA. In altri ambienti,
                dovete assicurarvi che la transazione venga completata quando vengono chiamati <tt class="literal">Session.close()</tt> 
                o <tt class="literal">Session.disconnect()</tt>. Se volete usare questa strategia in un cluster, dovete assicurarvi
                che l'implementazione della cache sottostante supporti il locking. La cache fornita con Hibernate 
                <span class="emphasis"><em>non</em></span> lo fa.
            </p><pre class="programlisting">&lt;class name="eg.Cat" .... &gt;
    &lt;cache usage="read-write"/&gt;
    ....
    &lt;set name="kittens" ... &gt;
        &lt;cache usage="read-write"/&gt;
        ....
    &lt;/set&gt;
&lt;/class&gt;</pre></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-nonstrict"></a>14.3.4.&nbsp;Strategia: lettura/scrittura non stretta</h3></div></div><div></div></div><p>
                Se l'applicazione ha bisogno di modificare dati solo occasionalmente (cio&egrave; se &egrave; molto improbabile
                che due transazioni tentino di modificare lo stesso oggetto simultaneamente) e l'isolamento stretto
                delle transazioni non &egrave; richiesto, potrebbe essere appropriata una cache <tt class="literal">nonstrict-read-write</tt> 
                (lettura/scrittura non stretta). 
                Se la cache &egrave; usata in un ambiente JTA, dovete specificare <tt class="literal">hibernate.transaction.manager_lookup_class</tt>.
                In altri ambienti, dovete assicurare che la transazione sia completa quando vengono chiamati
                <tt class="literal">Session.close()</tt> o <tt class="literal">Session.disconnect()</tt>.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-transactional"></a>14.3.5.&nbsp;Strategia: transazionale</h3></div></div><div></div></div><p>
                La strategia di caching <tt class="literal">transazionale</tt> fornisce supporto per cache completamente transazionali come
                la JBoss TreeCache. Una cache di questo tipo pu&ograve; essere usata solo in un contesto JTA e dovete specificare la propriet&agrave; 
                <tt class="literal">hibernate.transaction.manager_lookup_class</tt>. 
            </p></div><p>
            Nessuno dei fornitori di cache supporta tutte le strategie di concorrenza. La tabella seguente mostra
            quali fornitori sono compatibili con quali strategie di concorrenza.
        </p><div class="table"><a name="d0e8821"></a><p class="title"><b>Tabella&nbsp;14.2.&nbsp;Supporto alle strategie di concorrenza delle cache</b></p><table summary="Supporto alle strategie di concorrenza delle cache" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Cache</th><th align="left">read-only</th><th align="left">nonstrict-read-write</th><th align="left">read-write</th><th align="left">transactional</th></tr></thead><tbody><tr><td align="left">Hashtable (non adatta per un uso in produzione)</td><td align="left">S&igrave;</td><td align="left">S&igrave;</td><td align="left">S&igrave;</td><td align="left">&nbsp;</td></tr><tr><td align="left">EHCache</td><td align="left">S&igrave;</td><td align="left">S&igrave;</td><td align="left">S&igrave;</td><td align="left">&nbsp;</td></tr><tr><td align="left">OSCache</td><td align="left">S&igrave;</td><td align="left">S&igrave;</td><td align="left">S&igrave;</td><td align="left">&nbsp;</td></tr><tr><td align="left">SwarmCache</td><td align="left">S&igrave;</td><td align="left">S&igrave;</td><td align="left">&nbsp;</td><td align="left">&nbsp;</td></tr><tr><td align="left">JBoss TreeCache</td><td align="left">S&igrave;</td><td align="left">&nbsp;</td><td align="left">&nbsp;</td><td align="left">S&igrave;</td></tr></tbody></table></div></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-sessioncache"></a>14.4.&nbsp;Gestione della cache di <tt class="literal">Session</tt></h2></div></div><div></div></div><p>
            Ogni volta che passate un oggetto ai metodi<tt class="literal">save()</tt>, <tt class="literal">update()</tt>
            o <tt class="literal">saveOrUpdate()</tt> e ogni volta che ne recuperate uno usando  
            <tt class="literal">load()</tt>, <tt class="literal">find()</tt>, <tt class="literal">iterate()</tt>,
            o <tt class="literal">filter()</tt>, quell'oggetto viene aggiunto alla cache interna della 
            <tt class="literal">Session</tt>. Quando poi viene chiamato <tt class="literal">flush()</tt>,
            lo stato di quell'oggetto sar&agrave; sincronizzato con il database. Se non volete che
            questa sincronizzazione avvenga, o se state elaborando un grande numero di oggetti
            e volete gestire la memoria efficentemente, potete usare il metodo <tt class="literal">evict()</tt>
            per rimuovere l'oggetto e le sue collezioni dalla cache.
        </p><pre class="programlisting">Iterator cats = sess.iterate("from eg.Cat as cat"); //a huge result set
while ( cats.hasNext() ) {
    Cat cat = (Cat) iter.next();
    doSomethingWithACat(cat);
    sess.evict(cat);
}</pre><p>
            La <tt class="literal">Session</tt> fornisce anche un metodo <tt class="literal">contains()</tt> 
            per determinare se un'istanza appartiene alla cache di sessione.
        </p><p>
            Per rimuovere completamente tutti gli oggetti dalla cache si sessione, esiste il metodo
            <tt class="literal">Session.clear()</tt>
        </p><p>
            Per la cache di secfondo livello, ci sono dei metodi definiti su <tt class="literal">SessionFactory</tt> 
            e che hanno lo scopo di rimuovere lo stato di un'istanza dalla cache, una intera classe, una istanza 
            di collezione o un intero ruolo di collezione.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-querycache"></a>14.5.&nbsp;La cache delle query</h2></div></div><div></div></div><p>
            Gli insiemi di risultati (result set) delle query possono anche venire messi in cache. Questo &egrave; utile solo per 
            quelle query che vengono lanciate frequentemente con gli stessi parametri. Per usare la
            cache delle query dovete prima attivarla settando la propriet&agrave;
            <tt class="literal">hibernate.cache.use_query_cache=true</tt>. Questo causa la creazione di 
            due regioni nella cache, una che mantiene i set di risultati delle query,  
            (<tt class="literal">net.sf.hibernate.cache.QueryCache</tt>), l'altra che mantiene le etichette di tempo (timestamp)
            degli aggiornamenti pi&ugrave; recenti alle tabelle interrogate.
            (<tt class="literal">net.sf.hibernate.cache.UpdateTimestampsCache</tt>). Notate che la cache 
            delle query non memorizza lo stato delle entit&agrave; nel result set; quello che mette in cache sono solo
            i valori dei risultati e i valori dei tipi. Per questo, la cache delle query viene solitamente usata 
            insieme alla cache di secondo livello.
        </p><p>
            La maggior parte delle interrogazione non traggono particolari benefici dal caching, 
            per questo l'impostazione predefinita non lo prevede. Per attivarlo, chiamate
            <tt class="literal">Query.setCacheable(true)</tt>. Questo metodo consente alla query di 
            cercare risultati nella cache o di aggiungere i suoi risultati quando viene eseguita.
        </p><p>
            Se avete bisogno di controllo pi&ugrave; raffinato sulle politiche di scadenza delle cache, 
            potete specificare una regione della cache per nome e per una particolare interrogazione 
            chiamando il metodo <tt class="literal">Query.setCacheRegion()</tt>.
        </p><pre class="programlisting">List blogs = sess.createQuery("from Blog blog where blog.blogger = :blogger")
    .setEntity("blogger", blogger)
    .setMaxResults(15)
    .setCacheable(true)
    .setCacheRegion("frontpages")
    .list();</pre></div></div><div class="chapter" lang="it"><div class="titlepage"><div><div><h2 class="title"><a name="toolsetguide"></a>Capitolo&nbsp;15.&nbsp;Guida degli strumenti</h2></div></div><div></div></div><p>
        La cosiddetta "ingegnerizzazione circolare" ("roundtrip engineering") con Hibernate &egrave; possibile o utilizzando un 
        insieme di strumenti a linea di comando manutenuti come parte del progetto Hibernate stesso, o
        sfruttando il supporto ad Hibernate fornito da progetti come XDoclet, Middlegen e AndroMDA.
    </p><p>
        La distribuzione principale di Hibernate include lo strumento pi&ugrave; importante (che pu&ograve; essere usato anche 
        direttamente dall'interno di Hibernate):
    </p><div class="itemizedlist"><ul type="disc"><li><p>
            Generazione di uno schema DDL da un file di mappaggio
            (cio&egrave; <tt class="literal">SchemaExport</tt>, <tt class="literal">hbm2ddl</tt>)
        </p></li></ul></div><p>
        Altri strumenti forniti direttamente dal progetto Hibernate vengono rilasciati in un pacchetto separato, 
        detto delle <span class="emphasis"><em>Hibernate Extensions</em></span>. Il pacchetto include strumenti per i compiti
        seguenti:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
            Generazione di sorgenti Java da un file di mappaggio (cio&egrave; <tt class="literal">CodeGenerator</tt>,
            <tt class="literal">hbm2java</tt>)
        </p></li><li><p>
            generazione di file di mappaggio da classi Java compilate o da sorgenti Java con indicazioni
            di contrassegno ("markup") di XDoclet markup (ovvero <tt class="literal">MapGenerator</tt>,
            <tt class="literal">class2hbm</tt>)
        </p></li></ul></div><p>
        In realt&agrave; c'&egrave; un altro programma di utilit&agrave; che sopravvive tra le estensioni di Hibernate: 
        <tt class="literal">ddl2hbm</tt>. Viene considerato deprecato e non viene pi&ugrave; manutenuto: Middlegen 
        svolge lo stesso compito facendo un lavoro migliore.
    </p><p>
        Strumenti di terze parti con supporto per Hibernate sono:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
            Middlegen (generazione di file di mappaggio da uno schema di database esistente)
        </p></li><li><p>
            AndroMDA (MDA (Model-Driven Architecture o architettura guidata dal modello) &egrave; un approccio
            alla generazione di codice per classi persistenti a partire da diagrammi UML e dalla loro
            rappresentazione XML/XMI
        </p></li></ul></div><p>
        Questi strumenti di terze parti non sono documentati in questo manuale. Fate riferimento al sito
        di hibernate per informazioni aggiornate al riguardo (una istantanea del sito &egrave; disponibile
        nel pacchetto di distribuzione).
    </p><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="toolsetguide-s1"></a>15.1.&nbsp;Generazione dello schema</h2></div></div><div></div></div><p>
            Il DDL pu&ograve; venire generato dai file di mappaggio tramite una utilit&agrave; a riga di comando. 
            Un file di comandi ("batch") si trova nella cartella <tt class="literal">hibernate-x.x.x/bin</tt> 
            dell'archivio principale di Hibernate.
        </p><p>
            Lo schema generato include vincoli di integrit&agrave; referenziale (chiavi primarie ed esterne)
            per le entit&agrave; e le tabelle di collezione. Vengono anche create le tabelle e le sequenze
            per i generatori di identificatori mappati nei file hbm.
        </p><p>
            <span class="emphasis"><em>Dovete</em></span> specificare un <tt class="literal">dialetto</tt> SQL tramite
            la propriet&agrave; <tt class="literal">hibernate.dialect</tt> quando si usa questo strumento.
        </p><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-2"></a>15.1.1.&nbsp;Personalizzazione dello schema</h3></div></div><div></div></div><p>
                Molti elementi di mappaggio in Hibernate definiscono un attributo opzionale che si chiama
                <tt class="literal">length</tt>. Con esso potete impostare la lunghezza di una colonna.
            </p><p>
                Alcuni tag accettano anche un attributo <tt class="literal">not-null</tt> (che genera un vincolo 
                <tt class="literal">NOT NULL</tt> sulle colonne della tabella) e un attributo <tt class="literal">unique</tt> 
                (per generare vincoli <tt class="literal">UNIQUE</tt>).
            </p><p>
                Alcuni tag accettano un attributo <tt class="literal">index</tt> per specificare il nome
                di un indice per la colonna. Un attributo <tt class="literal">unique-key</tt> pu&ograve; essere
                usato per raggruppare colonne in un vincolo di chiave a singola unit&agrave;. Attualmente il valore 
                specificato dell'attributo <tt class="literal">unique-key</tt> <span class="emphasis"><em>non</em></span> 
                viene usato per denominare il vincolo, ma solo per raggruppare le colonne nel file di 
                mappaggio.
            </p><p>
                Esempi:
            </p><pre class="programlisting">&lt;property name="foo" type="string" length="64" not-null="true"/&gt;

&lt;many-to-one name="bar" foreign-key="fk_foo_bar" not-null="true"/&gt;

&lt;element column="serial_number" type="long" not-null="true" unique="true"/&gt;</pre><p>
                In alternativa, questi elementi accettano anche un elemento figlio <tt class="literal">&lt;column&gt;</tt>, che
                &egrave; particolarmente utile per i tipi multi-colonna:
            </p><pre class="programlisting">&lt;property name="foo" type="string"&gt;
    &lt;column name="foo" length="64" not-null="true" sql-type="text"/&gt;
&lt;/property&gt;

&lt;property name="bar" type="my.customtypes.MultiColumnType"/&gt;
    &lt;column name="fee" not-null="true" index="bar_idx"/&gt;
    &lt;column name="fi" not-null="true" index="bar_idx"/&gt;
    &lt;column name="fo" not-null="true" index="bar_idx"/&gt;
&lt;/property&gt;</pre><p>
                L'attributo <tt class="literal">sql-type</tt> consente all'utente di sovrascrivere il mappaggio 
                predefinito dal tipo di Hibernate al tipo di dati SQL.
            </p><p>
                L'attributo <tt class="literal">check</tt> vi consente di specificare un vincolo di controllo.
            </p><pre class="programlisting">&lt;property name="foo" type="integer"&gt;
    &lt;column name="foo" check="foo &gt; 10"/&gt;
&lt;/property&gt;

&lt;class name="Foo" table="foos" check="bar &lt; 100.0"&gt;
    ...
    &lt;property name="bar" type="float"/&gt;
&lt;/class&gt;</pre><div class="table"><a name="d0e9111"></a><p class="title"><b>Tabella&nbsp;15.1.&nbsp;Summary</b></p><table summary="Summary" border="1"><colgroup><col><col></colgroup><thead><tr><th>Attributi</th><th>Valori</th><th>Interpretazione</th></tr></thead><tbody><tr><td><tt class="literal">length</tt></td><td><tt class="literal">true|false</tt></td><td>lunghezza della colonna</td></tr><tr><td><tt class="literal">not-null</tt></td><td><tt class="literal">true|false</tt></td><td>specifica che la colonna dovrebbe essere non annullabile</td></tr><tr><td><tt class="literal">unique</tt></td><td><tt class="literal">true|false</tt></td><td>specifica che la colonna dovrebbe avere un vincolo di unicit&agrave;</td></tr><tr><td><tt class="literal">index</tt></td><td><tt class="literal">nome_indice</tt></td><td>specifica il nome di un indice (multicolonna)</td></tr><tr><td><tt class="literal">unique-key</tt></td><td><tt class="literal">nome_chiave_univoca</tt></td><td>specifica il nome di un vincolo di unicit&agrave; multi-colonna</td></tr><tr><td><tt class="literal">foreign-key</tt></td><td><tt class="literal">nome_chiave_esterna</tt></td><td>
                                specifica il nome di un vincolo di chiave esterna generato per un'associazione
                            </td></tr><tr><td><tt class="literal">sql-type</tt></td><td><tt class="literal">tipo_colonna</tt></td><td>
                                sovrascrive il tipo di colonna predefinito (solo attributo dell'elemento <tt class="literal">&lt;column&gt;</tt>)
                            </td></tr><tr><td><tt class="literal">check</tt></td><td>espressione SQL</td><td>
                                crea un vincolo di controllo SQL su una colonna o una tabella
                            </td></tr></tbody></table></div></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-3"></a>15.1.2.&nbsp;Esecuzione del programma</h3></div></div><div></div></div><p>
                Lo strumento <tt class="literal">SchemaExport</tt> scrive uno script DDL sull'uscita standard (stdout)
                e/o esegue le istruzioni DDL.
            </p><p>
                <tt class="literal">java -cp </tt><span class="emphasis"><em>classpath_di_hibernate</em></span>
                <tt class="literal">net.sf.hibernate.tool.hbm2ddl.SchemaExport</tt> <span class="emphasis"><em>opzioni file_di_mappaggio</em></span>
            </p><div class="table"><a name="d0e9221"></a><p class="title"><b>Tabella&nbsp;15.2.&nbsp;Opzioni della linea di comando di <tt class="literal">SchemaExport</tt></b></p><table summary="Opzioni della linea di comando di SchemaExport" border="1"><colgroup><col><col></colgroup><thead><tr><th>Opzione</th><th>Descrizione</th></tr></thead><tbody><tr><td><tt class="literal">--quiet</tt></td><td>non scrive lo script sull'uscita standard (stdout)</td></tr><tr><td><tt class="literal">--drop</tt></td><td>elimina solo le tabelle</td></tr><tr><td><tt class="literal">--text</tt></td><td>non esporta sul database</td></tr><tr><td><tt class="literal">--output=my_schema.ddl</tt></td><td>emette lo script ddl su un file</td></tr><tr><td><tt class="literal">--config=hibernate.cfg.xml</tt></td><td>legge la configurazione di Hibernate da un file XML particolare</td></tr><tr><td><tt class="literal">--properties=hibernate.properties</tt></td><td>legge le propriet&agrave; del database da un file</td></tr><tr><td><tt class="literal">--format</tt></td><td>nello script l'SQL generato viene formattato in una maniera "carina"</td></tr><tr><td><tt class="literal">--delimiter=x</tt></td><td>imposta un delimitatore di fine linea per lo script</td></tr></tbody></table></div><p>
                Potete anche annidare <tt class="literal">SchemaExport</tt> nella vostra applicazione:
            </p><pre class="programlisting">Configuration cfg = ....;
new SchemaExport(cfg).create(false, true);</pre></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-4"></a>15.1.3.&nbsp;Propriet&agrave;</h3></div></div><div></div></div><p>
                Le propriet&agrave; del database possono essere specificate
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>come propriet&agrave; di sistema con <tt class="literal">-D</tt><span class="emphasis"><em>&lt;property&gt;</em></span></p></li><li><p>in un file <tt class="literal">hibernate.properties</tt></p></li><li><p>in un file di propriet&agrave; con un nome diverso con <tt class="literal">--properties</tt></p></li></ul></div><p>
                Le propriet&agrave; richieste sono:
            </p><div class="table"><a name="d0e9316"></a><p class="title"><b>Tabella&nbsp;15.3.&nbsp;Propriet&agrave; di connessione di SchemaExport</b></p><table summary="Propriet&agrave; di connessione di SchemaExport" border="1"><colgroup><col><col></colgroup><thead><tr><th>Nome propriet&agrave;</th><th>Descrizione</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.connection.driver_class</tt></td><td>classe del driver jdbc</td></tr><tr><td><tt class="literal">hibernate.connection.url</tt></td><td>url jdbc</td></tr><tr><td><tt class="literal">hibernate.connection.username</tt></td><td>nome utente database</td></tr><tr><td><tt class="literal">hibernate.connection.password</tt></td><td>parola chiave database</td></tr><tr><td><tt class="literal">hibernate.dialect</tt></td><td>dialetto</td></tr></tbody></table></div></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-5"></a>15.1.4.&nbsp;Utilizzo di Ant</h3></div></div><div></div></div><p>
                &Egrave; possibile chiamare lo <tt class="literal">SchemaExport</tt> dal vostro script di Ant:
            </p><pre class="programlisting">&lt;target name="schemaexport"&gt;
    &lt;taskdef name="schemaexport"
        classname="net.sf.hibernate.tool.hbm2ddl.SchemaExportTask"
        classpathref="class.path"/&gt;
    
    &lt;schemaexport
        properties="hibernate.properties"
        quiet="no"
        text="no"
        drop="no"
        delimiter=";"
        output="schema-export.sql"&gt;
        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.hbm.xml"/&gt;
        &lt;/fileset&gt;
    &lt;/schemaexport&gt;
&lt;/target&gt;</pre></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-6"></a>15.1.5.&nbsp;Aggiornamenti incrementali dello schema</h3></div></div><div></div></div><p>
                Lo strumento <tt class="literal">SchemaUpdate</tt> &egrave; in grado di aggiornare uno schema esistente con cambiamenti 
                "incrementali". Notate che <tt class="literal">SchemaUpdate</tt> dipende in maniera massiccia dall'API dei 
                metadati JDBC, e per questo non funziona con tutti i driver JDBC.
            </p><p>
                <tt class="literal">java -cp </tt><span class="emphasis"><em>classpath_di_hibernate</em></span>
                <tt class="literal">net.sf.hibernate.tool.hbm2ddl.SchemaUpdate</tt> <span class="emphasis"><em>opzioni file_di_mappaggio</em></span>
            </p><div class="table"><a name="d0e9393"></a><p class="title"><b>Tabella&nbsp;15.4.&nbsp;Opzioni da linea di comando per <tt class="literal">SchemaUpdate</tt></b></p><table summary="Opzioni da linea di comando per SchemaUpdate" border="1"><colgroup><col><col></colgroup><thead><tr><th>Opzione</th><th>Descrizione</th></tr></thead><tbody><tr><td><tt class="literal">--quiet</tt></td><td>non scrive lo script su stdout</td></tr><tr><td><tt class="literal">--properties=hibernate.properties</tt></td><td>legge le propriet&agrave; del database da un file</td></tr></tbody></table></div><p>
                Potete annidare <tt class="literal">SchemaUpdate</tt> nella vostra applicazione:
            </p><pre class="programlisting">Configuration cfg = ....;
new SchemaUpdate(cfg).execute(false);</pre></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-7"></a>15.1.6.&nbsp;Utilizzo di Ant per gli aggiornamenti incrementali dello schema</h3></div></div><div></div></div><p>
                Potete chiamare <tt class="literal">SchemaUpdate</tt> da uno script di Ant:
            </p><pre class="programlisting">&lt;target name="schemaupdate"&gt;
    &lt;taskdef name="schemaupdate"
        classname="net.sf.hibernate.tool.hbm2ddl.SchemaUpdateTask"
        classpathref="class.path"/&gt;
    
    &lt;schemaupdate
        properties="hibernate.properties"
        quiet="no"&gt;
        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.hbm.xml"/&gt;
        &lt;/fileset&gt;
    &lt;/schemaupdate&gt;
&lt;/target&gt;</pre></div></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="toolsetguide-s2"></a>15.2.&nbsp;Generazione di codice</h2></div></div><div></div></div><p>
            Il generatore di codice di Hibernate pu&ograve; essere usato per generare l'implementazione della
            struttura delle classi java da un file di mappaggio di Hibernate. Lo strumento &egrave; incluso nel
            pacchetto delle estensioni di Hibernate (Hibernate Extensions), scaricabile separatamente 
            dal pacchetto principale.
        </p><p>
            <tt class="literal">hbm2java</tt> interpreta i file di mappaggio e a partire da questi genera classi java 
            complete. In questo modo, usando <tt class="literal">hbm2java</tt> &egrave; possibile "solo" fornire i file 
            <tt class="literal">.hbm</tt> e non preoccuparsi della produzione manuale delle classi Java.
        </p><p>
            <tt class="literal">java -cp</tt> <span class="emphasis"><em>classpath_di_hibernate</em></span>
            <tt class="literal">net.sf.hibernate.tool.hbm2java.CodeGenerator</tt> <span class="emphasis"><em> opzioni
            file_di_mappaggio</em></span>
        </p><div class="table"><a name="d0e9467"></a><p class="title"><b>Tabella&nbsp;15.5.&nbsp;Opzioni da linea di comando del generatore di codice</b></p><table summary="Opzioni da linea di comando del generatore di codice" border="1"><colgroup><col><col></colgroup><thead><tr><th>Opzione</th><th>Descrizione</th></tr></thead><tbody><tr><td><tt class="literal">--output=</tt><span class="emphasis"><em>cartella_di_output</em></span></td><td>cartella radice per il codice generato</td></tr><tr><td><tt class="literal">--config=</tt><span class="emphasis"><em>file_di_configurazione</em></span></td><td>file opzionale per configurare hbm2java</td></tr></tbody></table></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s2-1"></a>15.2.1.&nbsp;Il file di configurazione (opzionale)</h3></div></div><div></div></div><p>
                Il file di configurazione fornisce una maniera per specificare dei "produttori" multipli per
                il codice sorgente e per dichiarare attributi <tt class="literal">&lt;meta&gt;</tt> che sono "globali" per 
                visibilit&agrave;. Leggete di pi&ugrave; al riguardo nella sezione sull'attributo <tt class="literal">&lt;meta&gt;</tt>.
            </p><pre class="programlisting">&lt;codegen&gt;
    &lt;meta attribute="implements"&gt;codegen.test.IAuditable&lt;/meta&gt;
    &lt;generate renderer="net.sf.hibernate.tool.hbm2java.BasicRenderer"/&gt;
    &lt;generate
        package="autofinders.only"
        suffix="Finder"
        renderer="net.sf.hibernate.tool.hbm2java.FinderRenderer"/&gt;
&lt;/codegen&gt;</pre><p>
                Questo file di configurazione dichiara un attributo meta globale "implements" e specifica due produttori
                (renderers), quello predefinito (BasicRenderer) e un produttore che genera dei "Finder"
                (vedete anche in "generazione basica dei finder" pi&ugrave; sotto).
            </p><p>
                Il secondo produttore viene fornito con attributi "package" e "suffix".
            </p><p>
                L'attributo "package" specifica che i file di codice sorgente generati da questo renderer
                dovrebbero essere posti in questo package invece che in quello specificato nei file
                <tt class="literal">.hbm</tt>.
            </p><p>
                L'attributo "suffix" specifica il suffisso per i file generati. Nel caso dell'esempio, un file 
                chiamato <tt class="literal">Foo.java</tt> diventerebbe invece <tt class="literal">FooFinder.java</tt>.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s2-2"></a>15.2.2.&nbsp;L'attributo <tt class="literal">meta</tt></h3></div></div><div></div></div><p>
                L'etichetta <tt class="literal">&lt;meta&gt;</tt> &egrave; una maniera semplice di annotare il file <tt class="literal">hbm.xml</tt>, 
                e dare agli strumenti un posto naturale per memorizzare o leggere informazioni che non siano direttamente 
                correlate con il nucleo di Hibernate.
            </p><p>
                Potete usare l'etichetta <tt class="literal">&lt;meta&gt;</tt> per indicare ad <tt class="literal">hbm2java</tt> 
                di generare solo metodi "setter" protetti, fare in modo tale che le classi implementino sempre un 
                certo insieme di interfacce, fare in modo tale che estendano una certa classe di base, o 
                altro.
            </p><p>
                L'esempio seguente:
            </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;meta attribute="class-description"&gt;
        Javadoc per la classe Person
        @author Frodo
    &lt;/meta&gt;
    &lt;meta attribute="implements"&gt;IAuditable&lt;/meta&gt;
    &lt;id name="id" type="long"&gt;
        &lt;meta attribute="scope-set"&gt;protected&lt;/meta&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" type="string"&gt;
        &lt;meta attribute="field-description"&gt;Il nome della persona&lt;/meta&gt;
    &lt;/property&gt;
&lt;/class&gt;</pre><p>
                produrr&agrave; qualcosa come ci&ograve; che segue (il codice &egrave; stato accorciato per renderlo pi&ugrave; 
                comprensibile). Notate il commento Javadoc e il metodo set protetto:
            </p><pre class="programlisting">// package di default

import java.io.Serializable;
import org.apache.commons.lang.builder.EqualsBuilder;
import org.apache.commons.lang.builder.HashCodeBuilder;
import org.apache.commons.lang.builder.ToStringBuilder;

/** 
 *         Javadoc per la classe Person
 *         @author Frodo
 *     
 */
public class Person implements Serializable, IAuditable {

    /** identifier field */
    public Long id;

    /** nullable persistent field */
    public String name;

    /** full constructor */
    public Person(java.lang.String name) {
        this.name = name;
    }

    /** default constructor */
    public Person() {
    }

    public java.lang.Long getId() {
        return this.id;
    }

    protected void setId(java.lang.Long id) {
        this.id = id;
    }

    /** 
     * Il nome della persona
     */
    public java.lang.String getName() {
        return this.name;
    }

    public void setName(java.lang.String name) {
        this.name = name;
    }

}</pre><div class="table"><a name="d0e9555"></a><p class="title"><b>Tabella&nbsp;15.6.&nbsp;Meta tag supportati</b></p><table summary="Meta tag supportati" border="1"><colgroup><col><col></colgroup><thead><tr><th>Attributo</th><th>Descrizione</th></tr></thead><tbody><tr><td><tt class="literal">class-description</tt></td><td>inserito nel javadoc per le classi</td></tr><tr><td><tt class="literal">field-description</tt></td><td>inserito nel javadoc per i campi/propriet&agrave;</td></tr><tr><td><tt class="literal">interface</tt></td><td>Se &egrave; vero viene generata un'interfaccia invece di una classe.</td></tr><tr><td><tt class="literal">implements</tt></td><td>l'interfaccia che la classe deve implementare</td></tr><tr><td><tt class="literal">extends</tt></td><td>classe che dovrebbe essere estesa da questa classe (ignorata per le sottoclassi)</td></tr><tr><td><tt class="literal">generated-class</tt></td><td>sovrascrive il nome della vera classe generata</td></tr><tr><td><tt class="literal">scope-class</tt></td><td>visibilit&agrave; per la classe</td></tr><tr><td><tt class="literal">scope-set</tt></td><td>visibilit&agrave; per un metodo setter</td></tr><tr><td><tt class="literal">scope-get</tt></td><td>visibilit&agrave; per un metodo getter</td></tr><tr><td><tt class="literal">scope-field</tt></td><td>visibilit&agrave; per il campo vero e proprio</td></tr><tr><td><tt class="literal">use-in-tostring</tt></td><td>include la propriet&agrave; nel <tt class="literal">toString()</tt></td></tr><tr><td><tt class="literal">implement-equals</tt></td><td>include un metodo <tt class="literal">equals()</tt> e un <tt class="literal">hashCode()</tt> in questa classe.</td></tr><tr><td><tt class="literal">use-in-equals</tt></td><td>include la propriet&agrave; nei metodi <tt class="literal">equals()</tt> e <tt class="literal">hashCode()</tt>.</td></tr><tr><td><tt class="literal">bound</tt></td><td>aggiunge il supporto di un propertyChangeListener per la propriet&agrave;</td></tr><tr><td><tt class="literal">constrained</tt></td><td>come bound + il supporto di un vetoChangeListener per una propriet&agrave;</td></tr><tr><td><tt class="literal">gen-property</tt></td><td>la propriet&agrave; non verr&agrave; generata se &egrave; falsa (usare con cautela)</td></tr><tr><td><tt class="literal">property-type</tt></td><td>Sovrascrive il tipo di default della propriet&agrave;. Da usare con l'etichetta
                        "any" per specificare il tipo concreto invece di avere solo Object.</td></tr><tr><td><tt class="literal">class-code</tt></td><td>Codice extra che verr&agrave; inserito alla fine della classe</td></tr><tr><td><tt class="literal">extra-import</tt></td><td>Clausola di importazione extra che verr&agrave; inserita alla fine di tutte le altre</td></tr><tr><td><tt class="literal">finder-method</tt></td><td>vedere "generatore elementare di metodi individuatori" pi&ugrave; sotto</td></tr><tr><td><tt class="literal">session-method</tt></td><td>vedere "generatore elementare di metodi individuatori" pi&ugrave; sotto</td></tr></tbody></table></div><p>
                All'interno di un file <tt class="literal">hbm.xml</tt>, gli attributi dichiarati tramite l'elemento 
                <tt class="literal">&lt;meta&gt;</tt> come comportamento predefinito vengono "ereditati".
            </p><p>
                Cosa significa? Significa che se ad esempio volete fare s&igrave; che tutte le vostre classi 
                implementino l'interfaccia <tt class="literal">IAuditable</tt> dovete solo aggiungere un 
                <tt class="literal">&lt;meta attribute="implements"&gt;IAuditable&lt;/meta&gt;</tt> all'inizio 
                del file <tt class="literal">hbm.xml</tt>, proprio dopo <tt class="literal">&lt;hibernate-mapping&gt;</tt>. 
                Ora tutte le classi definite in quel file <tt class="literal">hbm.xml</tt> implementeranno 
                <tt class="literal">IAuditable</tt>! (Eccetto se una classe ha anche un attributo meta 
                "implements", perch&eacute; le etichette meta specificate localmente sovrascrivono/rimpiazzano
                sempre quelle ereditate).
            </p><p>
                Nota: questo si applica a <span class="emphasis"><em>tutti</em></span> i <tt class="literal">&lt;meta&gt;</tt>-tag.
                Cos&igrave; pu&ograve; anche essere usato ad esempio per specificare che tutti i campi dovrebbero essere
                dichiarati protetti, invece che privati come &egrave; il comportamento predefinito. Questo si 
                imposta aggiungendo <tt class="literal">&lt;meta attribute="scope-field"&gt;protected&lt;/meta&gt;</tt> 
                ad esempio proprio sotto l'elemento <tt class="literal">&lt;class&gt;</tt>, e tutti i campi della
                classe saranno generati come protetti.
            </p><p>
                Per evitare che un <tt class="literal">&lt;meta&gt;</tt>-tag venga ereditato potete 
                semplicemente specificare <tt class="literal">inherit="false"</tt> per l'attributo, ad esempio 
                <tt class="literal">&lt;meta attribute="scope-class" inherit="false"&gt;public abstract&lt;/meta&gt;</tt>
                restringer&agrave; la visibilit&agrave; di classe alla classe corrente, e non alle sottoclassi.
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s2-3"></a>15.2.3.&nbsp;Generatore elementare di metodi individuatori ("finder")</h3></div></div><div></div></div><p>
                Ora &egrave; possibile fare in modo tale che <tt class="literal">hbm2java</tt> generi dei metodi 
                individuatori elementari per le propriet&agrave; di Hibernate. Questo richiede che due cose
                vengano impostate nel file <tt class="literal">hbm.xml</tt>.
            </p><p>
                La prima &egrave; l'indicazione di quale sia il campo per cui si vogliono generare gli 
                individuatori. Si indica con un blocco meta all'interno di un elemento "property",
                come in:
            </p><pre class="programlisting">&lt;property name="name" column="name" type="string"&gt;
     &lt;meta attribute="finder-method"&gt;findByName&lt;/meta&gt;
&lt;/property&gt;</pre><p>
                Il nome del metodo individuatore sar&agrave; il testo racchiuso nelle etichette meta.
            </p><p>
                Il secondo &egrave; la creazione di un file di configurazione per hbm2java nella forma:
            </p><pre class="programlisting">&lt;codegen&gt;
    &lt;generate renderer="net.sf.hibernate.tool.hbm2java.BasicRenderer"/&gt;
    &lt;generate suffix="Finder" renderer="net.sf.hibernate.tool.hbm2java.FinderRenderer"/&gt;
&lt;/codegen&gt;</pre><p>
                 A questo punto si deve usare il parametro per <tt class="literal">hbm2java --config=xxx.xml</tt> laddove
                 <tt class="literal">xxx.xml</tt> &egrave; il file di configurazione che &egrave; appena stato creato.
            </p><p>
                 Un parametro opzionale &egrave; l'etichetta meta al livello di classe nel formato:
            </p><pre class="programlisting">&lt;meta attribute="session-method"&gt;
    com.whatever.SessionTable.getSessionTable().getSession();
&lt;/meta&gt;</pre><p>
                 Che sarebbe il modo in cui si reperiscono le sessioni se usate il pattern
                 <span class="emphasis"><em>Thread Local Session</em></span> (documentato nell'area "Design Patterns" 
                 del sito web di Hibernate).
            </p></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s2-4"></a>15.2.4.&nbsp;Generatore basato su Velocity</h3></div></div><div></div></div><p>Ora &egrave; possibile usare Velocity come strumento alternativo di resa/generazione.
      Il seguente file config.xml mostra come configurare hbm2java per usare il generatore basato su velocity.
      </p><pre class="programlisting">
    &lt;codegen&gt;
     &lt;generate renderer="net.sf.hibernate.tool.hbm2java.VelocityRenderer"&gt;
      &lt;param name="template"&gt;pojo.vm&lt;/param&gt;
     &lt;/generate&gt;
    &lt;/codegen&gt;</pre><p>
        Il parametro <tt class="literal">template</tt> &egrave; un percorso di risorsa che punta al file delle macro velocity macro 
        che volete usare. Il file deve essere raggiungibile sul classpath di hbm2java: per questo ricordate di 
        aggiungere al vostro task di ant o script di shell la directory in cui si trova pojo.vm (la posizione 
        predefinita &egrave; <tt class="literal">./tools/src/velocity</tt>)
      </p><p>
        Ricordatevi che la versione attuale di <tt class="literal">pojo.vm</tt> genera solo le parti pi&ugrave; elementari dei 
        bean java. Non &egrave; tanto completa e ricca di funzionalit&agrave; quanto il generatore nativo di Hibernate - in particolare 
        non sono supportati la maggior parte dei tag <tt class="literal">meta</tt>.
      </p></div></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="toolsetguide-s3"></a>15.3.&nbsp;Generazione dei file di mappaggio</h2></div></div><div></div></div><p>
            &Egrave; possibile generare uno scheletro di file di mappaggio a partire da classi persistenti
            compilate usando una utilit&agrave; a linea di comando chiamata <tt class="literal">MapGenerator</tt>, 
            parte del pacchetto delle estensioni di Hibernate (Hibernate Extensions).
        </p><p>
            Il generatore di mappaggio fornisce un meccanismo per produrre mappaggi dalle
            classi compilate. Usa il meccanismo della "reflection" java per trovare le 
            <span class="emphasis"><em>propriet&agrave;</em></span> e usa dei metodi euristici per indovinare un mappaggio
            appropriato per il tipo di propriet&agrave;. Il mappaggio generato &egrave; inteso solo come un 
            punto di partenza: non c'&egrave; modo di produrre un mappaggio completo senza informazioni
            extra fornite dall'utente. In ogni modo, questo strumento libera da una parte del 
            lavoro ripetitivo e bruto coinvolto nella produzione di un mappaggio.
        </p><p>
            Le classi vengono aggiunte al mappaggio una alla volta. Lo strumento rigetter&agrave; le classi
            che a suo giudizio non siano <span class="emphasis"><em>persistibili tramite Hibernate</em></span>.
        </p><p>
            Per essere <span class="emphasis"><em>persistibile tramite Hibernate</em></span> una classe
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>non deve essere un tipo primitivo</p></li><li><p>non dev'essere un array</p></li><li><p>non deve essere un'interfaccia</p></li><li><p>non deve essere una classe annidata</p></li><li><p>deve avere un costruttore di default (senza argomenti).</p></li></ul></div><p>
            Notate che le interfacce e le classi annidate in realt&agrave; sono persistibili da Hibernate, ma
            questo non &egrave; solitamente ci&ograve; che l'utente vuole.
        </p><p>
            <tt class="literal">MapGenerator</tt> risalir&agrave; la catena delle superclassi di tutte le classi 
            aggiunte tentando di aggiungere quante pi&ugrave; superclassi possibile (persistibili da Hibernate) 
            alla stessa tabella di database.
            La ricerca si ferma non appena viene trovata una propriet&agrave; che ha un nome che appare in una
            lista di <span class="emphasis"><em>nomi candidati come UID</em></span>.
        </p><p>
            La lista predefinita di nomi di propriet&agrave; candidati come UID &egrave;: <tt class="literal">uid</tt>, <tt class="literal">UID</tt>,
            <tt class="literal">id</tt>, <tt class="literal">ID</tt>, <tt class="literal">key</tt>, <tt class="literal">KEY</tt>,
            <tt class="literal">pk</tt>, <tt class="literal">PK</tt>.
        </p><p>
            Le propriet&agrave; vengono reperite quando ci sono due metodi nella classe, un "setter" (impostatore) e un 
            "getter" (recuperatore), laddove il tipo del singolo argomento dell'impostatore &egrave; lo stesso del tipo
            di ritorno del recuperatore (che non deve avere argomenti), mentre l'impostatore restituisce 
            <tt class="literal">void</tt>. Inoltre, il nome dell'impostatore deve cominciare con la stringa  
            <tt class="literal">set</tt> e deve essere vero o che il nome del recuperatore comincia con 
            <tt class="literal">get</tt> o che comincia con <tt class="literal">is</tt> e il tipo della propriet&agrave; &egrave; boolean. 
            In entrambi i casi, il resto dei nomi deve conocordare. Questa porzione corrispondente &egrave; il nome
            della propriet&agrave;, eccettuato il fatto che il carattere iniziale del nome della propriet&agrave; &egrave; reso 
            minuscolo se la seconda lettera &egrave; minuscola.
        </p><p>
            Le regole per determinare il tipo (sul database) di ogni propriet&agrave; sono:
        </p><div class="orderedlist"><ol type="1" compact><li><p>
                    Se il tipo java &egrave; <tt class="literal">Hibernate.basic()</tt>, la propriet&agrave; &egrave; una colonna di quel tipo.
                </p></li><li><p>
                    Per i tipi personalizzati <tt class="literal">hibernate.type.Type</tt> e <tt class="literal">PersistentEnum</tt>
                    viene usata una colonna semplice, nello stesso modo.
                </p></li><li><p>
                    Se il tipo della propriet&agrave; &egrave; un array, viene usato un array di Hibernate, e <tt class="literal">MapGenerator</tt>
                    tenta di riflettere (ovvero agire via "reflection") sul tipo di elemento dell'array.
                </p></li><li><p>
                    Se la propriet&agrave; ha tipo <tt class="literal">java.util.List</tt>, <tt class="literal">java.util.Map</tt>, o
                    <tt class="literal">java.util.Set</tt>, vengono usati i corrispondenti tipi di Hibernate, ma
                    <tt class="literal">MapGenerator</tt> non pu&ograve; procedere oltre nel lavorare sull'interno di questi tipi.
                </p></li><li><p>
                    Se il tipo della propriet&agrave; &egrave; qualsiasi altra classe, <tt class="literal">MapGenerator</tt> rimanda la
                    decisione sulla rappresentazione sul database finch&eacute; tutte le classi non sono state processate. 
                    A questo punto, se la classe era stata reperita tramite la ricerca per superclassi descritta 
                    sopra, allora la propriet&agrave; &egrave; una associazione <tt class="literal">many-to-one</tt>. Se la classe 
                    ha delle propriet&agrave;, allora &egrave; un <tt class="literal">component</tt>. In caso contrario &egrave; serializzabile,
                    o non persistibile.
                </p></li></ol></div><div class="sect2" lang="it"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s3-1"></a>15.3.1.&nbsp;Esecuzione dello strumento</h3></div></div><div></div></div><p>
                Lo strumento scrive mappaggi XML sull'uscita standard e/o su un file.
            </p><p>
                Quando invocate lo strumento, dovete mettere sul classpath le vostre classi compilate.
            </p><p>
                <tt class="literal">java -cp </tt><span class="emphasis"><em>classpath_di_hibernate_e_delle_vostre_classi</em></span>
                <tt class="literal">net.sf.hibernate.tool.class2hbm.MapGenerator</tt> <span class="emphasis"><em>opzioni e nomi delle
                classi</em></span>
            </p><p>
                Ci sono due modi di funzionamento: a linea di comando o interattivo.
            </p><p>
                La modalit&agrave; interattiva viene selezionata fornendo sulla linea di comando il parametro
                <tt class="literal">--interact</tt>. Questa modalit&agrave; fornisce una console con un "prompt" (cursore di
                inserimento comandi). Usandola potete settare il nome della propriet&agrave; UID per ogni classe usando
                il comando <tt class="literal">uid=XXX</tt> in cui <tt class="literal">XXX</tt> &egrave; il nome della propriet&agrave; UID. 
                Altre alternative di comandi sono semplicemente un nome di classe completamente qualificato (cio&egrave;
                con la parte relativa ai package, come in java.lang.String), o il comando "done" che emette l'XML 
                &egrave; termina.
            </p><p>
                In modalit&agrave; a linea di comando i parametri sono le opzioni che seguono, inframmezzate dai
                nomi completamente qualificati delle classi che vanno processate. La maggior parte delle
                opzioni sono intese come utilizzabili pi&ugrave; volte; ogni uso coinvolge le classi che vengono
                aggiunte conseguentemente.
            </p><div class="table"><a name="d0e9997"></a><p class="title"><b>Tabella&nbsp;15.7.&nbsp;Opzioni da linea di comando del MapGenerator</b></p><table summary="Opzioni da linea di comando del MapGenerator" border="1"><colgroup><col><col></colgroup><thead><tr><th>Opzione</th><th>Descrizione</th></tr></thead><tbody><tr><td><tt class="literal">--quiet</tt></td><td>non scrive il mappaggio O-R sullo standard output</td></tr><tr><td><tt class="literal">--setUID=uid</tt></td><td>imposta la lista di UID candidati all'uid singolo</td></tr><tr><td><tt class="literal">--addUID=uid</tt></td><td>aggiunge uid in cima alla lista di UID candidati</td></tr><tr><td><tt class="literal">--select=</tt><span class="emphasis"><em>modalit&agrave;</em></span></td><td>usa la modalit&agrave; di selezione <span class="emphasis"><em>modalit&agrave;</em></span>(e.g.,
                            <span class="emphasis"><em>distinct</em></span> o <span class="emphasis"><em>all</em></span>) per le classi 
                            aggiunte in seguito</td></tr><tr><td><tt class="literal">--depth=&lt;piccolo-valore-intero&gt;</tt></td><td>limita la profondit&agrave; della ricorsione dei dati dei componenti 
                            per le classi aggiunte in seguito</td></tr><tr><td><tt class="literal">--output=mio_file.xml</tt></td><td>scrive il mappaggio OR su un file</td></tr><tr><td><span class="emphasis"><em>nome.completo.di.Classe</em></span></td><td>aggiunge la classe al mappaggio</td></tr><tr><td><tt class="literal">--abstract=</tt><span class="emphasis"><em>nome.completo.di.Classe</em></span></td><td>vedi sotto</td></tr></tbody></table></div><p>
                Il parametro "abstract" istruisce lo strumento di generazione del mappaggio in modo tale da ignorare
                superclassi specifiche in modo che classi con ereditariet&agrave; comune non vengano mappate su una sola grande 
                tabella. Ad esempio, considerate queste gerarchie di classe:
            </p><p>
                <tt class="literal">Animale--&gt;Mammifero--&gt;Umano</tt>
            </p><p>
                <tt class="literal">Animale--&gt;Mammifero--&gt;Marsupiale--&gt;Canguro</tt>
            </p><p>
                Se il parametro <tt class="literal">--abstract</tt> <span class="emphasis"><em>non</em></span> viene usato, tutte le 
                classi verranno mappate come sottoclassi di <tt class="literal">Animale</tt>, il che risulter&agrave; 
                in una grande tabella che contiene tutte le propriet&agrave; di tutte le classi pi&ugrave; una colonna
                discriminatore che indicher&agrave; quale sottoclasse &egrave; realmente memorizzata in una riga.
                Se <tt class="literal">Mammifero</tt> &egrave; marcata come <tt class="literal">abstract</tt>,
                <tt class="literal">Umano</tt> e <tt class="literal">Marsupiale</tt> verranno mappate in dichiarazioni
                <tt class="literal">&lt;class&gt;</tt> separate e memorizzate in tabelle separate.
                <tt class="literal">Canguro</tt> sar&agrave; ancora una sottoclasse di <tt class="literal">Marsupiale</tt>
                a meno che anche <tt class="literal">Marsupiale</tt> sia marchiata come <tt class="literal">abstract</tt>.
            </p></div></div></div><div class="chapter" lang="it"><div class="titlepage"><div><div><h2 class="title"><a name="example-parentchild"></a>Capitolo&nbsp;16.&nbsp;Esempio: Genitore/Figlio (Parent/Child)</h2></div></div><div></div></div><p>
        Una delle primissime cose che i nuovi utenti tentano di fare con Hibernate &egrave; modellare una relazione
        di tipo genitore / figlio. Ci sono due approcci differenti, per farlo. Per varie ragioni, l'approccio
        pi&ugrave; conveniente, soprattutto per i neofiti, &egrave; modellare sia <tt class="literal">Parent</tt> sia <tt class="literal">Child</tt> 
        come classi di entit&agrave; con una associazione <tt class="literal">&lt;one-to-many&gt;</tt> da <tt class="literal">Parent</tt> 
        a <tt class="literal">Child</tt>. (L'approccio alternativo &egrave; dichiarare il <tt class="literal">Child</tt> come un
        <tt class="literal">&lt;composite-element&gt;</tt>.) Ora, la semantica predefinita di una associazione uno-a-molti in 
        Hibernate &egrave; molto meno affine alla semantica usuale di una relazione genitore - figlio di quanto non lo sia 
        quella di un mappaggio ad elemento composito. Mostreremo ora come usare una <span class="emphasis"><em>associazione uno a molti 
        bidirezionale e con cascate</em></span> per modellare una relazione genitore / figlio in maniera efficiente. Non
        &egrave; per niente difficile!
    </p><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-collections"></a>16.1.&nbsp;Una nota sulle collezioni</h2></div></div><div></div></div><p>
            Le collezioni di Hibernate vengono considerate logicamente parte della entit&agrave; che le possiede, e 
            mai delle entit&agrave; contenute. Questa &egrave; una precisazione cruciale, che ha le seguenti conseguenze:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                Quando rimuoviamo / aggiungiamo un oggetto da / a una collezione, il numero di versione del 
                proprietario viene incrementato.
            </p></li><li><p>
                Se un oggetto che &egrave; stato rimosso da una collezione &egrave; un'istanza di un tipo di valore ("value type"), 
                cio&egrave; un elemento composito, quell'oggetto cesser&agrave; di essere persistente e il suo stato verr&agrave; completamente
                rimosso dal database. Nello stesso modo, aggiungendo una istanza di un tipo di valore alla collezione 
                causer&agrave; il fatto che il suo stato sar&agrave; reso persistente.
            </p></li><li><p>
                Dall'altro lato, se un'entit&agrave; viene rimossa da una collezione (che sia associata uno-a-molti o 
                molti-a-molti), non verr&agrave; cancellata, come funzionamento predefinito. Questo comportamento &egrave; del
                tutto coerente - un cambiamento allo stato interno di un'altra entit&agrave; non dovrebbe causare il fatto
                che l'entit&agrave; associata svanisca! Nello stesso modo, l'aggiunta di un'entit&agrave; a una collezione non causa
                il fatto che quell'entit&agrave; venga automaticamente resa persistente (nel comportamento predefinito).
            </p></li></ul></div><p>
            Invece, il comportamento standard prevede che aggiungere un'entit&agrave; a una collezione si limiti a creare
            un collegamento tra le due entit&agrave;, cos&igrave; come rimuoverla determiner&agrave; la rimozione di quel collegamento.
            Questo funzionamento &egrave; il pi&ugrave; appropriato per moltissimi casi, mentre non &egrave; appropriato per nulla
            nel caso di una relazione genitore / figlio in cui la vita del figlio sia legata al ciclo di vita del
            genitore.
        </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-bidir"></a>16.2.&nbsp;Uno-a-molti bidirezionale</h2></div></div><div></div></div><p>
            Supponete che cominciamo con una semplice associazione <tt class="literal">&lt;one-to-many&gt;</tt> da
            <tt class="literal">Parent</tt> a <tt class="literal">Child</tt>.
        </p><pre class="programlisting">&lt;set name="children"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
            Se dovessimo eseguire il codice seguente
        </p><pre class="programlisting">Parent p = .....;
Child c = new Child();
p.getChildren().add(c);
session.save(c);
session.flush();</pre><p>
            Hibernate produrrebbe le due istruzioni SQL che seguono:
        </p><div class="itemizedlist"><ul type="disc"><li><p>una <tt class="literal">INSERT</tt> per creare il record per <tt class="literal">c</tt></p></li><li><p>
                una <tt class="literal">UPDATE</tt> per creare il collegamento da <tt class="literal">p</tt> a
                <tt class="literal">c</tt>
            </p></li></ul></div><p>
            Questo non solo &egrave; inefficiente, ma viola anche i vincoli <tt class="literal">NOT NULL</tt> sulla colonna
            <tt class="literal">parent_id</tt>.
        </p><p>
            La causa soggiacente &egrave; che il collegamento (la chiave esterna <tt class="literal">parent_id</tt>) da
            <tt class="literal">p</tt> a <tt class="literal">c</tt> non viene considerata parte dello stato dell'oggetto <tt class="literal">Child</tt>
            &egrave; quindi non viene creata nell'istruzione <tt class="literal">INSERT</tt>. La soluzione &egrave; quindi fare in modo che il collegamento
            sia parte del mappaggio di <tt class="literal">Child</tt>.
        </p><pre class="programlisting">&lt;many-to-one name="parent" column="parent_id" not-null="true"/&gt;</pre><p>
            (Abbiamo anche bisogno di aggiungere la propriet&agrave; <tt class="literal">parent</tt> sulla classe <tt class="literal">Child</tt>.)
        </p><p>
            Ora che l'entit&agrave; <tt class="literal">Child</tt> gestisce lo stato del collegamento, diciamo alla collezione di non aggiornarlo. 
            Usiamo quindi l'attributo <tt class="literal">inverse</tt>.
        </p><pre class="programlisting">&lt;set name="children" inverse="true"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
            Per aggiungere un nuovo <tt class="literal">Child</tt> verrebbe allora usato il codice seguente:
        </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
c.setParent(p);
p.getChildren().add(c);
session.save(c);
session.flush();</pre><p>
            E ora verr&agrave; generata una sola <tt class="literal">INSERT</tt> SQL!
        </p><p>
            Per facilitare un po' le cose, possiamo creare un metodo <tt class="literal">addChild()</tt> al
            <tt class="literal">Parent</tt>.
        </p><pre class="programlisting">public void addChild(Child c) {
    c.setParent(this);
    children.add(c);
}</pre><p>
            A questo punto il codice per aggiungere un <tt class="literal">Child</tt> appare cos&igrave;:
        </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
p.addChild(c);
session.save(c);
session.flush();</pre></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-cascades"></a>16.3.&nbsp;Ciclo di vita con cascate</h2></div></div><div></div></div><p>
             La chiamata esplicita a <tt class="literal">save()</tt> ci infastidisce ancora. Abbiamo quindi bisogno di gestire
             la situazione usando le cascate.
         </p><pre class="programlisting">&lt;set name="children" inverse="true" cascade="all"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
             Questo semplifica il codice seguente in questo modo:
         </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
p.addChild(c);
session.flush();</pre><p>
             In maniera similare, non abbiamo bisogno di iterare sui figli per salvare o cancellare un <tt class="literal">Parent</tt>.
             Quanto segue rimuove <tt class="literal">p</tt> e tutti i suoi figli dal database.
         </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
session.delete(p);
session.flush();</pre><p>
             Per&ograve; il codice seguente
         </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = (Child) p.getChildren().iterator().next();
p.getChildren().remove(c);
c.setParent(null);
session.flush();</pre><p>
             non rimuover&agrave; ancora <tt class="literal">c</tt> from the database; rimuover&agrave; solo il link verso <tt class="literal">p</tt>
             (e causer&agrave; la violazione di vincolo <tt class="literal">NOT NULL</tt>, in questo caso). C'&egrave; bisogno di cancellare 
             esplicitamente (<tt class="literal">delete()</tt>) il <tt class="literal">Child</tt>.
         </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = (Child) p.getChildren().iterator().next();
p.getChildren().remove(c);
session.delete(c);
session.flush();</pre><p>
             Ora, nel nostro caso un <tt class="literal">Child</tt> non pu&ograve; esistere senza il suo genitore. Quindi se rimuoviamo
             un <tt class="literal">Child</tt> dalla collezione, vogliamo che venga cancellato davvero. Per questo, dobbiamo usare
             <tt class="literal">cascade="all-delete-orphan"</tt>.
         </p><pre class="programlisting">&lt;set name="children" inverse="true" cascade="all-delete-orphan"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
             Nota: anche se il mappaggio della collezione specifica <tt class="literal">inverse="true"</tt>, le cascate sono 
             comunque gestite iterando sugli elementi della collezione. Quindi, se avete bisogno che un oggetto venga
             salvato, cancellato, o aggiornato per cascata, dovete aggiungerlo alla collezione. Non &egrave; sufficiente chiamare
             solo <tt class="literal">setParent()</tt>.
         </p></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-update"></a>16.4.&nbsp;Come utilizzare <tt class="literal">update()</tt> in cascata</h2></div></div><div></div></div><p>
             Immaginate che carichiamo un <tt class="literal">Parent</tt> in una <tt class="literal">Session</tt>, facciamo qualche
             cambiamento ad una azione di interfaccia e vogliamo rendere persistenti questi cambiamenti in una nuova Session 
             (chiamando <tt class="literal">update()</tt>). Il <tt class="literal">Parent</tt> conterr&agrave; una collezione di figli e,
             poich&eacute; &egrave; abilitato l'aggiornamento in cascata, Hibernate ha bisogno di sapere quali figli siano appena stati 
             istanziati, e quali invece rappresentino righe gi&agrave; esistenti nel database. Assumiamo che sia il <tt class="literal">Parent</tt> 
             sia il <tt class="literal">Child</tt> abbiano propriet&agrave; di identificazione (sintetiche) di tipo
             <tt class="literal">java.lang.Long</tt>. Hibernate user&agrave; il valore della propriet&agrave; identificatore per determinare quali dei figli
             sono nuovi. (Potete anche usare le propriet&agrave; versione o marca di tempo (timestamp), vedete
             <a href="#manipulatingdata-updating-detached" title="9.4.2.&nbsp;Aggiornamento di oggetti sganciati">Sezione&nbsp;9.4.2, &#8220;Aggiornamento di oggetti sganciati&#8221;</a>.)
         </p><p>
             L'attributo <tt class="literal">unsaved-value</tt> viene usato per specificae il valore di identificatore di una
             istanza appena creata. Se non specificato, <tt class="literal">unsaved-value</tt> vale "null", il che &egrave; perfetto, per 
             un identificatore di tipo <tt class="literal">Long</tt>. Se avessimo usato una propriet&agrave; di identificazione di un tipo
             primitivo, dovremmo specificare
         </p><pre class="programlisting">&lt;id name="id" type="long" unsaved-value="0"&gt;</pre><p>
             per il mappaggio del <tt class="literal">Child</tt>. (C'&egrave; anche un attributo <tt class="literal">unsaved-value</tt>
             per i mappaggi di propriet&agrave; di versione e timestamp.)
         </p><p>
             Il codice seguente aggiorner&agrave; il <tt class="literal">parent</tt> e <tt class="literal">child</tt> e inserir&agrave;
             <tt class="literal">newChild</tt>.
         </p><pre class="programlisting">//parent e child sono gi&agrave; stati caricati in una sessione precedente
parent.addChild(child);
Child newChild = new Child();
parent.addChild(newChild);
session.update(parent);
session.flush();</pre><p>
             Bene, questo &egrave; perfetto per il caso in cui si abbia un identificatore generato automaticamente, ma
             cosa succede quando si hanno identificatori assegnati manualmente e identificatori composti? In questo caso
             &egrave; pi&ugrave; difficile, perch&eacute; <tt class="literal">unsaved-value</tt> non pu&ograve; distinguere tra un oggetto appena
             istanziato (con identificatore assegnato dall'utente) e un oggetto caricato in una sessione precedente). In 
             questi casi, avrete probabilmente bisogno di dare una mano ad Hibernate, o
         </p><div class="itemizedlist"><ul type="disc"><li><p>
                 definendo <tt class="literal">unsaved-value="null"</tt> o <tt class="literal">unsaved-value="negative"</tt>
                 su una propriet&agrave; <tt class="literal">&lt;version&gt;</tt> o <tt class="literal">&lt;timestamp&gt;</tt> per la classe.
             </p></li><li><p>
                 impostare <tt class="literal">unsaved-value="none"</tt> e salvare esplicitamente (con <tt class="literal">save()</tt>)
                 i figli appena istanziati prima di chiamare <tt class="literal">update(parent)</tt>
             </p></li><li><p>
                 impostare <tt class="literal">unsaved-value="any"</tt> ed aggiornare esplicitamente (con <tt class="literal">update()</tt>)
                 i figli precedentemente resi persistenti prima di chiamare <tt class="literal">update(parent)</tt>
             </p></li></ul></div><p>
             <tt class="literal">none</tt> &egrave; il valore <tt class="literal">unsaved-value</tt> predefinito per gli identificatori assegnati e 
             composti.
         </p><p>
             C'&egrave; una possibilit&agrave; ulteriore. C'&egrave; un nuovo metodo sulla classe <tt class="literal">Interceptor</tt> che si chiama
             <tt class="literal">isUnsaved()</tt> che consente all'applicazione di implementare la propria strategia per
             distinguere gli oggetti appena istanziati. Ad esempio, potreste definire una classe di base per le vostre
             classi persistenti.
         </p><pre class="programlisting">public class Persistent {
    private boolean _saved = false;
    public void onSave() {
        _saved=true;
    }
    public void onLoad() {
        _saved=true;
    }
    ......
    public boolean isSaved() {
        return _saved;
    }
}</pre><p>
             (La propriet&agrave; <tt class="literal">saved</tt> &egrave; non-persistente.)
             Ora implementate <tt class="literal">isUnsaved()</tt> insieme a <tt class="literal">onLoad()</tt>
             e <tt class="literal">onSave()</tt> come segue:
         </p><pre class="programlisting">public Boolean isUnsaved(Object entity) {
    if (entity instanceof Persistent) {
        return new Boolean( !( (Persistent) entity ).isSaved() );
    }
    else {
        return null;
    }
}

public boolean onLoad(Object entity, 
    Serializable id,
    Object[] state,
    String[] propertyNames,
    Type[] types) {

    if (entity instanceof Persistent) ( (Persistent) entity ).onLoad();
    return false;
}

public boolean onSave(Object entity,
    Serializable id,
    Object[] state,
    String[] propertyNames,
    Type[] types) {
        
    if (entity instanceof Persistent) ( (Persistent) entity ).onSave();
    return false;
}</pre></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-conclusion"></a>16.5.&nbsp;Conclusione</h2></div></div><div></div></div><p>
             Ci sono vari concetti da digerire, qui, e potrebbe sembrare confuso, in un primo momento. Comunque, nella pratica
             funziona tutto molto bene. La maggior parte delle applicazioni basate su Hibernate usando il pattern genitore / figlio
             in vari posti.
         </p><p>
             Abbiamo menzionato un'alternativa nel primo paragrafo. Nessuna delle questioni precedenti esiste nel caso
             di mappaggi con <tt class="literal">&lt;composite-element&gt;</tt>, che hanno esattamente la semantica di una relazione
             padre / figlio. Sfortunatamente ci sono due grosse limitazioni per gli elementi composti: non possono avere
             collezioni, e non dovrebbero essere figli di un'entit&agrave; diversa dal loro genitore unico. (Per quanto,
             <span class="emphasis"><em>possano</em></span> avere una chiave primaria surrogata usando il mappaggio <tt class="literal">&lt;idbag&gt;</tt>.)
         </p></div></div><div class="chapter" lang="it"><div class="titlepage"><div><div><h2 class="title"><a name="example-weblog"></a>Capitolo&nbsp;17.&nbsp;Esempio: una applicazione che realizza un weblog</h2></div></div><div></div></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-weblog-classes"></a>17.1.&nbsp;Classi persistenti</h2></div></div><div></div></div><p>
            Le classi persistenti rappresentano un weblog, e un articolo 
            pubblicato su di esso. Devono venire modellate come una relazione
            standard genitore/figlio, ma useremo un "bag" ordinato invece di un insieme.
        </p><pre class="programlisting">package eg;

import java.util.List;

public class Blog {
    private Long _id;
    private String _name;
    private List _items;

    public Long getId() {
        return _id;
    }
    public List getItems() {
        return _items;
    }
    public String getName() {
        return _name;
    }
    public void setId(Long long1) {
        _id = long1;
    }
    public void setItems(List list) {
        _items = list;
    }
    public void setName(String string) {
        _name = string;
    }
}</pre><pre class="programlisting">package eg;

import java.text.DateFormat;
import java.util.Calendar;

public class BlogItem {
    private Long _id;
    private Calendar _datetime;
    private String _text;
    private String _title;
    private Blog _blog;

    public Blog getBlog() {
        return _blog;
    }
    public Calendar getDatetime() {
        return _datetime;
    }
    public Long getId() {
        return _id;
    }
    public String getText() {
        return _text;
    }
    public String getTitle() {
        return _title;
    }
    public void setBlog(Blog blog) {
        _blog = blog;
    }
    public void setDatetime(Calendar calendar) {
        _datetime = calendar;
    }
    public void setId(Long long1) {
        _id = long1;
    }
    public void setText(String string) {
        _text = string;
    }
    public void setTitle(String string) {
        _title = string;
    }
}</pre></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-weblog-mappings"></a>17.2.&nbsp;Mappaggi di hibernate</h2></div></div><div></div></div><p>
            I mappaggi XML sono abbastanza semplici.
        </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC 
        "-//Hibernate/Hibernate Mapping DTD 2.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

    &lt;class 
        name="Blog" 
        table="BLOGS" 
        lazy="true"&gt;
        
        &lt;id 
            name="id" 
            column="BLOG_ID"&gt;
            
            &lt;generator class="native"/&gt;
            
        &lt;/id&gt;
        
        &lt;property 
            name="name" 
            column="NAME" 
            not-null="true" 
            unique="true"/&gt;
            
        &lt;bag 
            name="items" 
            inverse="true" 
            lazy="true"
            order-by="DATE_TIME" 
            cascade="all"&gt;
            
            &lt;key column="BLOG_ID"/&gt;
            &lt;one-to-many class="BlogItem"/&gt;
            
        &lt;/bag&gt;
        
    &lt;/class&gt;
    
&lt;/hibernate-mapping&gt;</pre><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC 
        "-//Hibernate/Hibernate Mapping DTD 2.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;
    
    &lt;class 
        name="BlogItem" 
        table="BLOG_ITEMS" 
        dynamic-update="true"&gt;
        
        &lt;id 
            name="id" 
            column="BLOG_ITEM_ID"&gt;
            
            &lt;generator class="native"/&gt;
            
        &lt;/id&gt;
        
        &lt;property 
            name="title" 
            column="TITLE" 
            not-null="true"/&gt;
            
        &lt;property 
            name="text" 
            column="TEXT" 
            not-null="true"/&gt;
            
        &lt;property 
            name="datetime" 
            column="DATE_TIME" 
            not-null="true"/&gt;
            
        &lt;many-to-one 
            name="blog" 
            column="BLOG_ID" 
            not-null="true"/&gt;
            
    &lt;/class&gt;
    
&lt;/hibernate-mapping&gt;</pre></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-weblog-code"></a>17.3.&nbsp;Codice di Hibernate</h2></div></div><div></div></div><p>
            La classe seguente mostra il genere di operazioni che possiamo 
            effettuare su queste classi tramite Hibernate.
        </p><pre class="programlisting">package eg;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Iterator;
import java.util.List;

import net.sf.hibernate.HibernateException;
import net.sf.hibernate.Query;
import net.sf.hibernate.Session;
import net.sf.hibernate.SessionFactory;
import net.sf.hibernate.Transaction;
import net.sf.hibernate.cfg.Configuration;
import net.sf.hibernate.tool.hbm2ddl.SchemaExport;

public class BlogMain {
    
    private SessionFactory _sessions;
    
    public void configure() throws HibernateException {
        _sessions = new Configuration()
            .addClass(Blog.class)
            .addClass(BlogItem.class)
            .buildSessionFactory();
    }
    
    public void exportTables() throws HibernateException {
        Configuration cfg = new Configuration()
            .addClass(Blog.class)
            .addClass(BlogItem.class);
        new SchemaExport(cfg).create(true, true);
    }
    
    public Blog createBlog(String name) throws HibernateException {
        
        Blog blog = new Blog();
        blog.setName(name);
        blog.setItems( new ArrayList() );
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.save(blog);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return blog;
    }
    
    public BlogItem createBlogItem(Blog blog, String title, String text)
                        throws HibernateException {
        
        BlogItem item = new BlogItem();
        item.setTitle(title);
        item.setText(text);
        item.setBlog(blog);
        item.setDatetime( Calendar.getInstance() );
        blog.getItems().add(item);
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.update(blog);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return item;
    }
    
    public BlogItem createBlogItem(Long blogid, String title, String text)
                        throws HibernateException {
        
        BlogItem item = new BlogItem();
        item.setTitle(title);
        item.setText(text);
        item.setDatetime( Calendar.getInstance() );
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            Blog blog = (Blog) session.load(Blog.class, blogid);
            item.setBlog(blog);
            blog.getItems().add(item);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return item;
    }
    
    public void updateBlogItem(BlogItem item, String text)
                    throws HibernateException {
        
        item.setText(text);
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.update(item);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
    }
    
    public void updateBlogItem(Long itemid, String text)
                    throws HibernateException {
    
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            BlogItem item = (BlogItem) session.load(BlogItem.class, itemid);
            item.setText(text);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
    }
    
    public List listAllBlogNamesAndItemCounts(int max)
                    throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        List result = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "select blog.id, blog.name, count(blogItem) " +
                "from Blog as blog " +
                "left outer join blog.items as blogItem " +
                "group by blog.name, blog.id " +
                "order by max(blogItem.datetime)"
            );
            q.setMaxResults(max);
            result = q.list();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return result;
    }
    
    public Blog getBlogAndAllItems(Long blogid)
                    throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        Blog blog = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "from Blog as blog " +
                "left outer join fetch blog.items " +
                "where blog.id = :blogid"
            );
            q.setParameter("blogid", blogid);
            blog  = (Blog) q.list().get(0);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return blog;
    }
    
    public List listBlogsAndRecentItems() throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        List result = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "from Blog as blog " +
                "inner join blog.items as blogItem " +
                "where blogItem.datetime &gt; :minDate"
            );

            Calendar cal = Calendar.getInstance();
            cal.roll(Calendar.MONTH, false);
            q.setCalendar("minDate", cal);
            
            result = q.list();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return result;
    }
}</pre></div></div><div class="chapter" lang="it"><div class="titlepage"><div><div><h2 class="title"><a name="example-mappings"></a>Capitolo&nbsp;18.&nbsp;Alcuni mappaggi di esempio</h2></div></div><div></div></div><p>
        Queste sezioni vi mostrano alcuni mappaggi di associazioni complesse.
    </p><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-mappings-emp"></a>18.1.&nbsp;Employer/Employee (Datore di lavoro / impiegato)</h2></div></div><div></div></div><p>
            Il modello seguente della relazione tra <tt class="literal">Employer</tt> e
            <tt class="literal">Employee</tt> usa una vera classe di entit&agrave; (<tt class="literal">Employment</tt>) 
            per rappresentare l'associazione. Facciamo in questo modo perch&eacute; potrebbe esserci pi&ugrave; di
            un periodo di impiego che lega gli stessi due dipendenti. Per modellizzare i valori 
            monetari e i nomi degli impiegati vengono usati dei componenti.
        </p><div class="mediaobject" align="center"><img src="../shared/images/EmployerEmployee.gif" align="middle"></div><p>
            Ecco un possibile documento di mappaggio:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;
        
    &lt;class name="Employer" table="employers"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employer_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

    &lt;class name="Employment" table="employment_periods"&gt;

        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employment_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="startDate" column="start_date"/&gt;
        &lt;property name="endDate" column="end_date"/&gt;

        &lt;component name="hourlyRate" class="MonetoryAmount"&gt;
            &lt;property name="amount"&gt;
                &lt;column name="hourly_rate" sql-type="NUMERIC(12, 2)"/&gt;
            &lt;/property&gt;
            &lt;property name="currency" length="12"/&gt;
        &lt;/component&gt;

        &lt;many-to-one name="employer" column="employer_id" not-null="true"/&gt;
        &lt;many-to-one name="employee" column="employee_id" not-null="true"/&gt;

    &lt;/class&gt;

    &lt;class name="Employee" table="employees"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employee_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="taxfileNumber"/&gt;
        &lt;component name="name" class="Name"&gt;
            &lt;property name="firstName"/&gt;
            &lt;property name="initial"/&gt;
            &lt;property name="lastName"/&gt;
        &lt;/component&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
        Ed ecco lo schema delle tabelle generato automaticamente da <tt class="literal">SchemaExport</tt>.
    </p><pre class="programlisting">create table employers (
    id BIGINT not null, 
    name VARCHAR(255), 
    primary key (id)
)

create table employment_periods (
    id BIGINT not null,
    hourly_rate NUMERIC(12, 2),
    currency VARCHAR(12), 
    employee_id BIGINT not null, 
    employer_id BIGINT not null, 
    end_date TIMESTAMP, 
    start_date TIMESTAMP, 
    primary key (id)
)

create table employees (
    id BIGINT not null, 
    firstName VARCHAR(255), 
    initial CHAR(1), 
    lastName VARCHAR(255), 
    taxfileNumber VARCHAR(255), 
    primary key (id)
)

alter table employment_periods 
    add constraint employment_periodsFK0 foreign key (employer_id) references employers
alter table employment_periods 
    add constraint employment_periodsFK1 foreign key (employee_id) references employees
create sequence employee_id_seq
create sequence employment_id_seq
create sequence employer_id_seq</pre></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-mappings-authorwork"></a>18.2.&nbsp;Autore/Opera (Author/Work)</h2></div></div><div></div></div><p>
            Considerate il seguente modello per le relazioni tra <tt class="literal">Work</tt>,
            <tt class="literal">Author</tt> e <tt class="literal">Person</tt>. Rappresentiamo la relazione
            tra <tt class="literal">Work</tt> e <tt class="literal">Author</tt> (tra un'opera e il suo autore) 
            come una associazione molti-a-molti. Abbiamo invece scelto di rappresentare la relazione tra
            <tt class="literal">Author</tt> e <tt class="literal">Person</tt> come una associazione uno-a-uno. Un'altra possibilit&agrave;
            sarebbe che <tt class="literal">Author</tt> estendesse <tt class="literal">Person</tt>.
        </p><div class="mediaobject" align="center"><img src="../shared/images/AuthorWork.gif" align="middle"></div><p>
            Il seguente documento di mappaggio rappresenta correttamente queste relazioni:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Work" table="works" discriminator-value="W"&gt;

        &lt;id name="id" column="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;discriminator column="type" type="character"/&gt;

        &lt;property name="title"/&gt;
        &lt;set name="authors" table="author_work" lazy="true"&gt;
            &lt;key&gt;
                &lt;column name="work_id" not-null="true"/&gt;
            &lt;/key&gt;
            &lt;many-to-many class="Author"&gt;
                &lt;column name="author_id" not-null="true"/&gt;
            &lt;/many-to-many&gt;
        &lt;/set&gt;

        &lt;subclass name="Book" discriminator-value="B"&gt;
            &lt;property name="text"/&gt;
        &lt;/subclass&gt;

        &lt;subclass name="Song" discriminator-value="S"&gt;
            &lt;property name="tempo"/&gt;
            &lt;property name="genre"/&gt;
        &lt;/subclass&gt;

    &lt;/class&gt;

    &lt;class name="Author" table="authors"&gt;

        &lt;id name="id" column="id"&gt;
            &lt;!-- L'autore deve avere lo stesso identificatore della persona (Person) --&gt;
            &lt;generator class="assigned"/&gt; 
        &lt;/id&gt;

        &lt;property name="alias"/&gt;
        &lt;one-to-one name="person" constrained="true"/&gt;

        &lt;set name="works" table="author_work" inverse="true" lazy="true"&gt;
            &lt;key column="author_id"/&gt;
            &lt;many-to-many class="Work" column="work_id"/&gt;
        &lt;/set&gt;

    &lt;/class&gt;

    &lt;class name="Person" table="persons"&gt;
        &lt;id name="id" column="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
        In questo file di mappaggio ci sono quattro tabelle: <tt class="literal">works</tt>, 
        <tt class="literal">authors</tt> e <tt class="literal">persons</tt> contengano le opere, i dati
        degli autori e i dati delle persone. <tt class="literal">author_work</tt> &egrave; una tabella di 
        associazione che collega gli autori alle opere. Ecco lo schema delle tabelle cos&igrave; come
        generato da <tt class="literal">SchemaExport</tt>.
    </p><pre class="programlisting">create table works (
    id BIGINT not null generated by default as identity, 
    tempo FLOAT, 
    genre VARCHAR(255), 
    text INTEGER, 
    title VARCHAR(255), 
    type CHAR(1) not null, 
    primary key (id)
)

create table author_work (
    author_id BIGINT not null, 
    work_id BIGINT not null, 
    primary key (work_id, author_id)
)

create table authors (
    id BIGINT not null generated by default as identity, 
    alias VARCHAR(255), 
    primary key (id)
)

create table persons (
    id BIGINT not null generated by default as identity, 
    name VARCHAR(255), 
    primary key (id)
)

alter table authors 
    add constraint authorsFK0 foreign key (id) references persons
alter table author_work 
    add constraint author_workFK0 foreign key (author_id) references authors
alter table author_work
    add constraint author_workFK1 foreign key (work_id) references works</pre></div><div class="sect1" lang="it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-mappings-customerorderproduct"></a>18.3.&nbsp;Cliente/Ordine/Prodotto (Customer/Order/Product)</h2></div></div><div></div></div><p>
            Ora consideriamo un modello per le relazioni tra <tt class="literal">Customer</tt> (cliente),
            <tt class="literal">Order</tt> (ordine), <tt class="literal">LineItem</tt> (linea d'ordine) e <tt class="literal">Product</tt>
            (prodotto). C'&egrave; una associazione uno-a-molti tra <tt class="literal">Customer</tt> e
            <tt class="literal">Order</tt>, ma come potremmo rappresentare la relazione <tt class="literal">Order</tt> / 
            <tt class="literal">LineItem</tt> / <tt class="literal">Product</tt>? Abbiamo scelto di mappare 
            <tt class="literal">LineItem</tt> come una classe di associazione che rappresenti la relazione molti-a-molti
            tra gli <tt class="literal">Order</tt> e i <tt class="literal">Product</tt>. In
            Hibernate, questo si chiama un elemento composito.
        </p><div class="mediaobject" align="center"><img src="../shared/images/CustomerOrderProduct.gif" align="middle"></div><p>
            Il documento di mappaggio &egrave;:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Customer" table="customers"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
        &lt;set name="orders" inverse="true" lazy="true"&gt;
            &lt;key column="customer_id"/&gt;
            &lt;one-to-many class="Order"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Order" table="orders"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="date"/&gt;
        &lt;many-to-one name="customer" column="customer_id"/&gt;
        &lt;list name="lineItems" table="line_items" lazy="true"&gt;
            &lt;key column="order_id"/&gt;
            &lt;index column="line_number"/&gt;
            &lt;composite-element class="LineItem"&gt;
                &lt;property name="quantity"/&gt;
                &lt;many-to-one name="product" column="product_id"/&gt;
            &lt;/composite-element&gt;
        &lt;/list&gt;
    &lt;/class&gt;

    &lt;class name="Product" table="products"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="serialNumber"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
        Le tabelle<tt class="literal">customers</tt>, <tt class="literal">orders</tt>, <tt class="literal">line_items</tt> e
        <tt class="literal">products</tt> contengono rispettivamente dati dei clienti, degli ordini, delle linee
        d'ordine e dei prodotti. <tt class="literal">line_items</tt> svolge anche il ruolo di tabella di associazione
        tra gli ordini e i prodotti.
    </p><pre class="programlisting">create table customers (
    id BIGINT not null generated by default as identity, 
    name VARCHAR(255), 
    primary key (id)
)

create table orders (
    id BIGINT not null generated by default as identity, 
    customer_id BIGINT, 
    date TIMESTAMP, 
    primary key (id)
)

create table line_items (
    line_number INTEGER not null, 
    order_id BIGINT not null, 
    product_id BIGINT, 
    quantity INTEGER, 
    primary key (order_id, line_number)
)

create table products (
    id BIGINT not null generated by default as identity, 
    serialNumber VARCHAR(255), 
    primary key (id)
)

alter table orders 
    add constraint ordersFK0 foreign key (customer_id) references customers
alter table line_items
    add constraint line_itemsFK0 foreign key (product_id) references products
alter table line_items
    add constraint line_itemsFK1 foreign key (order_id) references orders</pre></div></div><div class="chapter" lang="it"><div class="titlepage"><div><div><h2 class="title"><a name="best-practices"></a>Capitolo&nbsp;19.&nbsp;Buone abitudini (best practices)</h2></div></div><div></div></div><div class="variablelist"><dl><dt><span class="term">Scrivete classi a granularit&agrave; fine, e mappatele usando <tt class="literal">&lt;component&gt;</tt>.</span></dt><dd><p>
		    Usate una classe <tt class="literal">Address</tt> (indirizzo) per incapsulare <tt class="literal">street</tt> (via),
                    <tt class="literal">suburb</tt> (comune), <tt class="literal">state</tt> (stato), <tt class="literal">postcode</tt> (codice postale).
                    Questa pratica facilita il riuso del codice e la sua ristrutturazione (refactoring).
                </p></dd><dt><span class="term">Dichiarate propriet&agrave; identificatrici sulle classi persistenti.</span></dt><dd><p>
		    In Hibernate le propriet&agrave; di identificazione sono opzionali, tuttavia ci sono molte
		    buone ragioni per cui &egrave; preferibile utilizzarle. Raccomandiamo che gli identificatori
		    siano 'sintetici' (ovvero generati, senza altro significato applicativo), e di un tipo
		    non-primitivo. Per la massima flessibilit&agrave; usate
                    <tt class="literal">java.lang.Long</tt> o <tt class="literal">java.lang.String</tt>.
                </p></dd><dt><span class="term">Mettete ogni mappaggio di classe in un file separato.</span></dt><dd><p>
		     Non usate un unico documento di mappaggio monolitico. Mappate <tt class="literal">com.eg.Foo</tt> 
		     nel file <tt class="literal">com/eg/Foo.hbm.xml</tt>. Questo &egrave; particolarmente utile nel
		     lavoro di gruppo.
                </p></dd><dt><span class="term">Caricate i mappaggi come risorse.</span></dt><dd><p>
		    Distribuite i mappaggi insieme alle classi che mappano.
                </p></dd><dt><span class="term">Prendete in considerazione l'esternalizzazione rispetto al codice delle stringhe di interrogazione.</span></dt><dd><p>
		    Questa &egrave; una buona pratica in particolare se le vostre interrogazioni chiamano delle 
		    funzioni SQL non ansi-standard. Esternalizzare le stringhe nei file di mappaggio 
		    render&agrave; l'applicazione pi&ugrave; portabile.
                </p></dd><dt><span class="term">Usate variabili di sostituzione.</span></dt><dd><p>
		     Come in JDBC, sostituite sempre i valori non constanti con "?" nelle query.Non usate mai
		     manipolazione di stringhe per sostituire un valore non costante in una interrogazione! 
		     &Egrave; anche meglio prendere in considerazione l'uso di parametri con nome, nelle interrogazioni.
		</p></dd><dt><span class="term">Non gestite le connessioni JDBC per conto vostro.</span></dt><dd><p>
		    Hibernate permette all'applicazione di gestire le connessioni JDBC. Questo approccio dovrebbe
		    essere considerato un'ultima spiaggia. Se non potete usare i fornitori di connessione predefiniti,
		    considerate la possibilit&agrave; di implementare voi stessi l'interfaccia 
		    <tt class="literal">net.sf.hibernate.connection.ConnectionProvider</tt>.
                </p></dd><dt><span class="term">Valutate l'uso di un tipo proprietario("custom type").</span></dt><dd><p>
		    Immaginate di avere un tipo di oggetto java, ad esempio proveniente da una libreria, che 
		    abbia bisogno di essere reso persistente, ma non fornisca i metodi di accesso necessari per 
		    mapparlo come un componente. Dovreste valutare la possibilit&agrave; di implementare
                    <tt class="literal">net.sf.hibernate.UserType</tt>. Questo approccio libera il codice applicativo
		    dalla necessit&agrave; di implementare trasformazioni da/a un tipo di Hibernate.
                </p></dd><dt><span class="term">Usate codice JDBC scritto a mano nei colli di bottiglia.</span></dt><dd><p>
                    Nelle aree critiche rispetto alle performance del sistema, alcune operazioni (ad esempio cancellazioni
		    o aggiornamenti massicci) potrebbero beneficiare da un'implementazione diretta in JDBC. Ma vi preghiamo
		    di attendere fino a che non <span class="emphasis"><em>sappiate</em></span> con certezza che qualcosa &egrave; un collo di bottiglia.
		    Non assumete inoltre, che il JDBC diretto sia necessariamente pi&ugrave; veloce: se avete bisogno di usarlo, potrebbe
		    essere sensato aprire una <tt class="literal">Session</tt> di Hibernate e usare la sottostante connessione SQL. In questo
		    modo potete comunque usare la stessa strategia transazionale e il fornitore di connessioni sottostante.
                </p></dd><dt><span class="term">Comprendete i meccanismi di scaricamento (flushing) della <tt class="literal">Session</tt>.</span></dt><dd><p>
		    Di tanto in tanto la Session sincronizza il suo stato persistente con il database. Le performance
		    saranno coinvolte se questo processo capita troppo spesso. Potete a volte minimizzare la quantit&agrave; 
		    di scaricamenti non necessari disabilitando i meccanismi automatici, o anche cambiando l'ordine
		    delle interrogazioni e delle altre operazioni all'interno di una particolare transazione.
                </p></dd><dt><span class="term">In un'architettura a tre livelli, valutate l'uso di <tt class="literal">saveOrUpdate()</tt>.</span></dt><dd><p>
		    Quando usate una architettura basata su servlet / session bean, potreste passare gli oggetti persistenti
		    caricati nel session bean da e al servlet o allo strato delle jep. Usate una nuova sessione per gestire 
		    ogni richiesta. Usate poi <tt class="literal">Session.update()</tt> o <tt class="literal">Session.saveOrUpdate()</tt> 
		    per aggiornare lo stato persistente di un oggetto.
                </p></dd><dt><span class="term">In un'architettura a due livelli, valutate l'use della disconnessione delle sessioni.</span></dt><dd><p>
		    Quando usate solo un servlet, potete riutilizzare la stessa sessione per richieste multiple dei client.
		    Semplicemente ricordate di sconnettere la sessione prima di restituire il controllo al client.
                </p></dd><dt><span class="term">Non trattate le eccezioni come se fossero recuperabili.</span></dt><dd><p>
		    Questa, pi&ugrave; che una migliore pratica, &egrave; una pratica necessaria. Quando capita un'eccezione, fate il rollback
                    della <tt class="literal">Transaction</tt> e chiudete la <tt class="literal">Session</tt>. Se non lo fate, Hibernate
		    non pu&ograve; garantire che lo stato in memoria rappresenti accuratamente lo stato persistente. Come caso particolare,
		    non usate <tt class="literal">Session.load()</tt> per determinare se un'istanza con quel particolare identificatore 
		    esista sul database; usate <tt class="literal">find()</tt>, invece.
                </p></dd><dt><span class="term">Preferite il caricamento differito (lazy) per le associazioni.</span></dt><dd><p>
		    Usate con moderazione il caricamento diretto (via outer-join). Usate i mediatori (proxy) e/o le collezioni
		    a caricamento differito per la maggior parte delle associazioni con classi che non siano messe in cache a 
		    livello della JVM. Per le associazioni con le classi in cache, dove ci sia un'alta possibilit&agrave; di avere 
		    gli oggetti in cache disabilitate esplicitamente il caricamento diretto usando 
                    <tt class="literal">outer-join="false"</tt>. Se in un particolare caso dovesse essere
		    appropriato un caricamento diretto con outer-join, potete usare una interrogazione con un <tt class="literal">left join</tt>.
                </p></dd><dt><span class="term">Valutate la possibilit&agrave; di separare la logica di business da Hibernate.</span></dt><dd><p>
		    Mascherate il codice di accesso ai dati (via hibernate) dietro un'interfaccia. Combinate i pattern
		    <span class="emphasis"><em>DAO</em></span> e <span class="emphasis"><em>Thread Local Session</em></span>. Potete anche avere alcune classi
		    rese persistenti da codice JDBC manuale, associate ad Hibernate tramite uno <tt class="literal">UserType</tt>. 
		    (Questo consiglio ha senso per applicazioni "sufficientemente grandi", non &egrave; appropriato per un'applicazione 
		    con poche tabelle!)
                </p></dd></dl></div></div></div></body></html>