<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;3.&nbsp;SessionFactory Configuration</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"><link rel="home" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"><link rel="up" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"><link rel="previous" href="architecture.html" title="Chapter&nbsp;2.&nbsp;Architecture"><link rel="next" href="persistent-classes.html" title="Chapter&nbsp;4.&nbsp;Persistent Classes"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;3.&nbsp;SessionFactory Configuration</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="architecture.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="persistent-classes.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="session-configuration"></a>Chapter&nbsp;3.&nbsp;SessionFactory Configuration</h2></div></div><div></div></div><p>
        Because Hibernate is designed to operate in many different environments, there
        are a large number of configuration parameters. Fortunately, most have sensible
        default values and Hibernate is distributed with an example 
        <tt class="literal">hibernate.properties</tt> file that shows the various options.
        You usually only have to put that file in your classpath and customize it.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-programmatic"></a>3.1.&nbsp;Programmatic Configuration</h2></div></div><div></div></div><p>
            An instance of <tt class="literal">net.sf.hibernate.cfg.Configuration</tt>
            represents an entire set of mappings of an application's Java types to a
            SQL database. The <tt class="literal">Configuration</tt> is used to build a
            (immutable)` <tt class="literal">SessionFactory</tt>. The mappings are compiled
            from various XML mapping files.
        </p><p>
            You may obtain a <tt class="literal">Configuration</tt> instance by
            instantiating it directly. Heres an example of setting up a datastore from 
            mappings defined in two XML configuration files (in the classpath):
        </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addFile("Item.hbm.xml")
    .addFile("Bid.hbm.xml");</pre><p>
            An alternative (sometimes better) way is to let Hibernate load a mapping file
            using <tt class="literal">getResourceAsStream()</tt>:
        </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class);</pre><p>
            Then Hibernate will look for mapping files named
            <tt class="literal">/org/hibernate/autcion/Item.hbm.xml</tt> and
            <tt class="literal">/org/hibernate/autcion/Bid.hbm.xml</tt> in the classpath.
            This approach eliminates any hardcoded filenames.
        </p><p>
            A <tt class="literal">Configuration</tt> also specifies various optional properties:
        </p><pre class="programlisting">Properties props = new Properties();
...
Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class)
    .setProperties(props);</pre><p>
            A <tt class="literal">Configuration</tt> is intended as a configuration-time object, to be
            discarded once a <tt class="literal">SessionFactory</tt> is built.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-sessionfactory"></a>3.2.&nbsp;Obtaining a SessionFactory</h2></div></div><div></div></div><p>
            When all mappings have been parsed by the <tt class="literal">Configuration</tt>, the application
            must obtain a factory for <tt class="literal">Session</tt> instances. This factory is intended
            to be shared by all application threads:
        </p><pre class="programlisting">SessionFactory sessions = cfg.buildSessionFactory();</pre><p>
            However, Hibernate does allow your application to instantiate more than one
            <tt class="literal">SessionFactory</tt>. This is useful if you are using more than one database.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-userjdbc"></a>3.3.&nbsp;User provided JDBC connection</h2></div></div><div></div></div><p>
            A <tt class="literal">SessionFactory</tt> may open a <tt class="literal">Session</tt> on 
            a user-provided JDBC connection. This design choice frees the application to 
            obtain JDBC connections wherever it pleases:
        </p><pre class="programlisting">java.sql.Connection conn = datasource.getConnection();
Session session = sessions.openSession(conn);

// do some data access work</pre><p>
            The application must be careful not to open two concurrent
            <tt class="literal">Session</tt>s on the same JDBC connection!
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-hibernatejdbc"></a>3.4.&nbsp;Hibernate provided JDBC connection</h2></div></div><div></div></div><p>
            Alternatively, you can have the <tt class="literal">SessionFactory</tt>
            open connections for you. The <tt class="literal">SessionFactory</tt>
            must be provided with JDBC connection properties in one of the
            following ways:
        </p><div class="orderedlist"><ol type="1" compact><li><p>
                    Pass an instance of <tt class="literal">java.util.Properties</tt> to
                    <tt class="literal">Configuration.setProperties()</tt>.
                </p></li><li><p>
                    Place <tt class="literal">hibernate.properties</tt> in a root directory of
                    the classpath.
                </p></li><li><p>
                    Set <tt class="literal">System</tt> properties using
                    <tt class="literal">java -Dproperty=value</tt>.
                </p></li><li><p>
                    Include <tt class="literal">&lt;property&gt;</tt> elements in
                    <tt class="literal">hibernate.cfg.xml</tt> (discussed later).
                </p></li></ol></div><p>
            If you take this approach, opening a <tt class="literal">Session</tt> is as simple as:
        </p><pre class="programlisting">Session session = sessions.openSession(); // open a new Session
// do some data access work, a JDBC connection will be used on demand</pre><p>
            All Hibernate property names and semantics are defined on the class 
            <tt class="literal">net.sf.hibernate.cfg.Environment</tt>. We will now describe the most
            important settings for JDBC connection configuration.
        </p><p>
            Hibernate will obtain (and pool) connections using <tt class="literal">java.sql.DriverManager</tt> 
            if you set the following properties:
        </p><div class="table"><a name="d0e759"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;Hibernate JDBC Properties</b></p><table summary="Hibernate JDBC Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.connection.driver_class</tt></td><td><span class="emphasis"><em>jdbc driver class</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.url</tt></td><td><span class="emphasis"><em>jdbc URL</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.username</tt></td><td><span class="emphasis"><em>database user</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.password</tt></td><td><span class="emphasis"><em>database user password</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.pool_size</tt></td><td><span class="emphasis"><em>maximum number of pooled connections</em></span></td></tr></tbody></table></div><p>
            Hibernate's own connection pooling algorithm is quite rudimentary. It is intended
            to help you get started and is <span class="emphasis"><em>not intended for use in a production system</em></span> 
            or even for performance testing. Use a third party pool for best performance and stability,
            i.e., replace the <tt class="literal">hibernate.connection.pool_size</tt> property with
            connection pool specific settings.
        </p><p>
            C3P0 is an open source JDBC connection pool distributed along with 
            Hibernate in the <tt class="literal">lib</tt> directory. Hibernate will use the built-in 
            <tt class="literal">C3P0ConnectionProvider</tt> for connection pooling if you set 
            the <tt class="literal">hibernate.c3p0.*</tt> properties.
            There is also built-in support for Apache DBCP and for Proxool. You must set the
            properties <tt class="literal">hibernate.dbcp.*</tt> (DBCP connection pool properties) 
            to enable the <tt class="literal">DBCPConnectionProvider</tt>. Prepared statement caching is
            enabled (highly recommend) if <tt class="literal">hibernate.dbcp.ps.*</tt>
            (DBCP statement cache properties) are set. Please refer the the Apache commons-pool 
            documentation for the interpretation of these properties.  You should set the 
            <tt class="literal">hibernate.proxool.*</tt> properties if you wish to use Proxool.
        </p><p>
            This is an example using C3P0:
        </p><a name="c3p0-configuration"></a><pre class="programlisting">hibernate.connection.driver_class = org.postgresql.Driver
hibernate.connection.url = jdbc:postgresql://localhost/mydatabase
hibernate.connection.username = myuser
hibernate.connection.password = secret
hibernate.c3p0.min_size=5
hibernate.c3p0.max_size=20
hibernate.c3p0.timeout=1800
hibernate.c3p0.max_statements=50
hibernate.dialect = net.sf.hibernate.dialect.PostgreSQLDialect</pre><p>
            For use inside an application server, Hibernate may obtain connections from a
            <tt class="literal">javax.sql.Datasource</tt> registered in JNDI. Set the following 
            properties:
        </p><div class="table"><a name="d0e847"></a><p class="title"><b>Table&nbsp;3.2.&nbsp;Hibernate Datasource Properties</b></p><table summary="Hibernate Datasource Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Propery name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.connection.datasource</tt></td><td><span class="emphasis"><em>datasource JNDI name</em></span></td></tr><tr><td><tt class="literal">hibernate.jndi.url</tt></td><td><span class="emphasis"><em>URL of the JNDI provider</em></span> (optional)
                </td></tr><tr><td><tt class="literal">hibernate.jndi.class</tt></td><td><span class="emphasis"><em>class of the JNDI <tt class="literal">InitialContextFactory</tt></em></span> (optional)
                </td></tr><tr><td><tt class="literal">hibernate.connection.username</tt></td><td><span class="emphasis"><em>database user</em></span> (optional)
                </td></tr><tr><td><tt class="literal">hibernate.connection.password</tt></td><td><span class="emphasis"><em>database user password</em></span> (optional)
                </td></tr></tbody></table></div><p>
            This is an example using an application server provided JNDI datasource:
        </p><pre class="programlisting">hibernate.connection.datasource = java:/comp/env/jdbc/MyDB
hibernate.transaction.factory_class = \
    net.sf.hibernate.transaction.JTATransactionFactory
hibernate.transaction.manager_lookup_class = \
    net.sf.hibernate.transaction.JBossTransactionManagerLookup
hibernate.dialect = \
    net.sf.hibernate.dialect.PostgreSQLDialect</pre><p>
            JDBC connections obtained from a JNDI datasource will automatically participate
            in the container-managed transactions of the application server.
        </p><p>
            Arbitrary connection properties may be given by prepending
            "<tt class="literal">hibernate.connnection</tt>" to the property name. For example, you
            may specify a <tt class="literal">charSet</tt> using <tt class="literal">hibernate.connnection.charSet</tt>.
        </p><p>
            You may define your own plugin strategy for obtaining JDBC connections by implementing the
            interface <tt class="literal">net.sf.hibernate.connection.ConnectionProvider</tt>. You may select
            a custom implementation by setting <tt class="literal">hibernate.connection.provider_class</tt>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-optional"></a>3.5.&nbsp;Optional configuration properties</h2></div></div><div></div></div><p>
            There are a number of other properties that control the behaviour of Hibernate
            at runtime. All are optional and have reasonable default values.
        </p><p>
            System-level properties can only be set via <tt class="literal">java -Dproperty=value</tt> or
            be defined in <tt class="literal">hibernate.properties</tt> and not with an instance of
            <tt class="literal">Properties</tt> passed to the <tt class="literal">Configuration</tt>.
        </p><div class="table"><a name="configuration-optional-properties"></a><p class="title"><b>Table&nbsp;3.3.&nbsp;Hibernate Configuration Properties</b></p><table summary="Hibernate Configuration Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.dialect</tt></td><td>
                            The classname of a Hibernate <tt class="literal">Dialect</tt> - enables
                            certain platform dependent features.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">full.classname.of.Dialect</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.default_schema</tt></td><td>
                            Qualify unqualified tablenames with the given schema/tablespace
                            in generated SQL.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">SCHEMA_NAME</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.session_factory_name</tt></td><td>
                            The <tt class="literal">SessionFactory</tt> will be automatically
                            bound to this name in JNDI after it has been created.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">jndi/composite/name</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.use_outer_join</tt></td><td>
                            Enables outer join fetching. Deprecated, use <tt class="literal">max_fetch_depth</tt>.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.max_fetch_depth</tt></td><td>
                            Set a maximum "depth" for the outer join fetch tree
                            for single-ended associations (one-to-one, many-to-one).
                            A <tt class="literal">0</tt> disables default outer join fetching.
                            <p>
                                <span class="strong">eg.</span> 
                                recommended values between <tt class="literal">0</tt> and <tt class="literal">3</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.fetch_size</tt></td><td>
                            A non-zero value determines the JDBC fetch size (calls
                            <tt class="literal">Statement.setFetchSize()</tt>).
                        </td></tr><tr><td><tt class="literal">hibernate.jdbc.batch_size</tt></td><td>
                            A non-zero value enables use of JDBC2 batch updates by Hibernate.
                            <p>
                                <span class="strong">eg.</span>
                                recommended values between <tt class="literal">5</tt> and <tt class="literal">30</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.batch_versioned_data</tt></td><td>
                            Set this property to <tt class="literal">true</tt> if your JDBC driver returns
                            correct row counts from <tt class="literal">executeBatch()</tt> (it is usually
                            safe to turn this option on). Hibernate will then use batched DML for
                            automatically versioned data. Defaults to <tt class="literal">false</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.use_scrollable_resultset</tt></td><td>
                            Enables use of JDBC2 scrollable resultsets by Hibernate.
                            This property is only necessary when using user supplied
                            JDBC connections, Hibernate uses connection metadata otherwise.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.use_streams_for_binary</tt></td><td>
                            Use streams when writing/reading <tt class="literal">binary</tt>
                            or <tt class="literal">serializable</tt> types to/from JDBC
                            (system-level property).
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.use_get_generated_keys</tt></td><td>
                            Enable use of JDBC3 <tt class="literal">PreparedStatement.getGeneratedKeys()</tt>
                            to retrieve natively generated keys after insert. Requires JDBC3+ driver
                            and JRE1.4+, set to false if your driver has problems with the Hibernate
                            identifier generators. By default, tries to determine the driver capabilites
                            using connection metadata.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true|false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cglib.use_reflection_optimizer</tt></td><td>
                            Enables use of CGLIB instead of runtime reflection (System-level
                            property). Reflection can sometimes be useful when troubleshooting,
                            note that Hibernate always requires CGLIB even if you turn off the
                            optimizer. You can not set this property in <tt class="literal">hibernate.cfg.xml</tt>.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jndi.<span class="emphasis"><em>&lt;propertyName&gt;</em></span></tt></td><td>
                            Pass the property <tt class="literal">propertyName</tt> to
                            the JNDI <tt class="literal">InitialContextFactory</tt>.
                        </td></tr><tr><td><tt class="literal">hibernate.connection.isolation</tt></td><td>
                        Set the JDBC transaction isolation level. Check
                        <tt class="literal">java.sql.Connection</tt> for meaningful values but
                        note that most databases do not support all isolation levels.
                        <p>
                            <span class="strong">eg.</span> 
                            <tt class="literal">1, 2, 4, 8</tt>
                        </p></td></tr><tr><td><tt class="literal">hibernate.connection.<span class="emphasis"><em>&lt;propertyName&gt;</em></span></tt></td><td>
                        Pass the JDBC property <tt class="literal">propertyName</tt>
                        to <tt class="literal">DriverManager.getConnection()</tt>.
                    </td></tr><tr><td><tt class="literal">hibernate.connection.provider_class</tt></td><td>
                            The classname of a custom <tt class="literal">ConnectionProvider</tt>.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">classname.of.ConnectionProvider</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.provider_class</tt></td><td>
                            The classname of a custom <tt class="literal">CacheProvider</tt>.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">classname.of.CacheProvider</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.use_minimal_puts</tt></td><td>
                            Optimize second-level cache operation to minimize writes, at the
                            cost of more frequent reads (useful for clustered caches).
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true|false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.use_query_cache</tt></td><td>
                            Enable the query cache, individual queries still have to be set cachable.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true|false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.query_cache_factory</tt></td><td>
                            The classname of a custom <tt class="literal">QueryCache</tt> interface,
                            defaults to the built-in <tt class="literal">StandardQueryCache</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">classname.of.QueryCache</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.region_prefix</tt></td><td>
                            A prefix to use for second-level cache region names.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">prefix</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.transaction.factory_class</tt></td><td>
                            The classname of a <tt class="literal">TransactionFactory</tt>
                            to use with Hibernate <tt class="literal">Transaction</tt> API
                            (defaults to <tt class="literal">JDBCTransactionFactory</tt>).
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">classname.of.TransactionFactory</tt>
                            </p></td></tr><tr><td><tt class="literal">jta.UserTransaction</tt></td><td>
                            A JNDI name used by <tt class="literal">JTATransactionFactory</tt> to
                            obtain the JTA <tt class="literal">UserTransaction</tt> from the
                            application server.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">jndi/composite/name</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.transaction.manager_lookup_class</tt></td><td>
                            The classname of a <tt class="literal">TransactionManagerLookup</tt>
                            - required when JVM-level caching is enabled in a JTA environment.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">classname.of.TransactionManagerLookup</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.query.substitutions</tt></td><td>
                            Mapping from tokens in Hibernate queries to SQL tokens
                            (tokens might be function or literal names, for example).
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.show_sql</tt></td><td>
                            Write all SQL statements to console.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.hbm2ddl.auto</tt></td><td>
                            Automatically export schema DDL to the database when the
                            <tt class="literal">SessionFactory</tt> is created. With
                            <tt class="literal">create-drop</tt>, the database schema
                            will be dropped when the <tt class="literal">SessionFactory</tt>
                            is closed explicitly.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">update</tt> | <tt class="literal">create</tt> | <tt class="literal">create-drop</tt>
                            </p></td></tr></tbody></table></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-dialects"></a>3.5.1.&nbsp;SQL Dialects</h3></div></div><div></div></div><p>
                You should always set the <tt class="literal">hibernate.dialect</tt> property to the correct
                <tt class="literal">net.sf.hibernate.dialect.Dialect</tt> subclass for your database. This is not
                strictly essential unless you wish to use <tt class="literal">native</tt> or
                <tt class="literal">sequence</tt> primary key generation or pessimistic locking (with, eg.
                <tt class="literal">Session.lock()</tt> or <tt class="literal">Query.setLockMode()</tt>).
                However, if you specify a dialect, Hibernate will use sensible defaults for some of the
                other properties listed above, saving you the effort of specifying them manually.
            </p><div class="table"><a name="sql-dialects"></a><p class="title"><b>Table&nbsp;3.4.&nbsp;Hibernate SQL Dialects (<tt class="literal">hibernate.dialect</tt>)</b></p><table summary="Hibernate SQL Dialects (hibernate.dialect)" border="1"><colgroup><col><col></colgroup><thead><tr><th>RDBMS</th><th>Dialect</th></tr></thead><tbody><tr><td>DB2</td><td><tt class="literal">net.sf.hibernate.dialect.DB2Dialect</tt></td></tr><tr><td>DB2 AS/400</td><td><tt class="literal">net.sf.hibernate.dialect.DB2400Dialect</tt></td></tr><tr><td>DB2 OS390</td><td><tt class="literal">net.sf.hibernate.dialect.DB2390Dialect</tt></td></tr><tr><td>PostgreSQL</td><td><tt class="literal">net.sf.hibernate.dialect.PostgreSQLDialect</tt></td></tr><tr><td>MySQL</td><td><tt class="literal">net.sf.hibernate.dialect.MySQLDialect</tt></td></tr><tr><td>Oracle (any version)</td><td><tt class="literal">net.sf.hibernate.dialect.OracleDialect</tt></td></tr><tr><td>Oracle 9/10g</td><td><tt class="literal">net.sf.hibernate.dialect.Oracle9Dialect</tt></td></tr><tr><td>Sybase</td><td><tt class="literal">net.sf.hibernate.dialect.SybaseDialect</tt></td></tr><tr><td>Sybase Anywhere</td><td><tt class="literal">net.sf.hibernate.dialect.SybaseAnywhereDialect</tt></td></tr><tr><td>Microsoft SQL Server</td><td><tt class="literal">net.sf.hibernate.dialect.SQLServerDialect</tt></td></tr><tr><td>SAP DB</td><td><tt class="literal">net.sf.hibernate.dialect.SAPDBDialect</tt></td></tr><tr><td>Informix</td><td><tt class="literal">net.sf.hibernate.dialect.InformixDialect</tt></td></tr><tr><td>HypersonicSQL</td><td><tt class="literal">net.sf.hibernate.dialect.HSQLDialect</tt></td></tr><tr><td>Ingres</td><td><tt class="literal">net.sf.hibernate.dialect.IngresDialect</tt></td></tr><tr><td>Progress</td><td><tt class="literal">net.sf.hibernate.dialect.ProgressDialect</tt></td></tr><tr><td>Mckoi SQL</td><td><tt class="literal">net.sf.hibernate.dialect.MckoiDialect</tt></td></tr><tr><td>Interbase</td><td><tt class="literal">net.sf.hibernate.dialect.InterbaseDialect</tt></td></tr><tr><td>Pointbase</td><td><tt class="literal">net.sf.hibernate.dialect.PointbaseDialect</tt></td></tr><tr><td>FrontBase</td><td><tt class="literal">net.sf.hibernate.dialect.FrontbaseDialect</tt></td></tr><tr><td>Firebird</td><td><tt class="literal">net.sf.hibernate.dialect.FirebirdDialect</tt></td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-outerjoin"></a>3.5.2.&nbsp;Outer Join Fetching</h3></div></div><div></div></div><p>
                If your database supports ANSI or Oracle style outer joins, <span class="emphasis"><em>outer join
                fetching</em></span> might increase performance by limiting the number of round
                trips to and from the database (at the cost of possibly more work performed by
                the database itself). Outer join fetching allows a graph of objects connected
                by many-to-one, one-to-many or one-to-one associations to be retrieved in a single
                SQL <tt class="literal">SELECT</tt>.
            </p><p>
                By default, the fetched graph when loading an objects ends at leaf objects,
                collections, objects with proxies, or where circularities occur.
            </p><p>
                For a <span class="emphasis"><em>particular  association</em></span>, fetching may be enabled
                or disabled (and the default behaviour overridden) by setting the
                <tt class="literal">outer-join</tt> attribute in the XML mapping.
            </p><p>
                Outer join fetching may be disabled <span class="emphasis"><em>globally</em></span> by setting
                the property <tt class="literal">hibernate.max_fetch_depth</tt> to <tt class="literal">0</tt>.
                A setting of <tt class="literal">1</tt> or higher enables outer join fetching for
                all one-to-one and many-to-one associations, which are, also by default, set
                to <tt class="literal">auto</tt> outer join. However, one-to-many associations and
                collections are never fetched with an outer-join, unless explicitly declared
                for each particular association. This behavior can also be overriden at runtime
                with Hibernate queries.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-binarystreams"></a>3.5.3.&nbsp;Binary Streams</h3></div></div><div></div></div><p>
                Oracle limits the size of <tt class="literal">byte</tt> arrays that may
                be passed to/from its JDBC driver. If you wish to use large instances of
                <tt class="literal">binary</tt> or <tt class="literal">serializable</tt> type, you should
                enable <tt class="literal">hibernate.jdbc.use_streams_for_binary</tt>.
                <span class="emphasis"><em>This is a JVM-level setting only.</em></span>
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-cacheprovider"></a>3.5.4.&nbsp;Custom <tt class="literal">CacheProvider</tt></h3></div></div><div></div></div><p>
                You may integrate a JVM-level (or clustered) second-level cache system by
                implementing the interface <tt class="literal">net.sf.hibernate.cache.CacheProvider</tt>.
                You may select the custom implementation by setting
                <tt class="literal">hibernate.cache.provider_class</tt>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-transactionstrategy"></a>3.5.5.&nbsp;Transaction strategy configuration</h3></div></div><div></div></div><p>
                If you wish to use the Hibernate <tt class="literal">Transaction</tt> API, you must
                specify a factory class for <tt class="literal">Transaction</tt> instances by
                setting the property <tt class="literal">hibernate.transaction.factory_class</tt>.
                The <tt class="literal">Transaction</tt> API hides the underlying transaction
                mechanism and allows Hibernate code to run in managed and non-managed environments.
            </p><p>
                There are two standard (built-in) choices:
            </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">net.sf.hibernate.transaction.JDBCTransactionFactory</tt></span></dt><dd><p>delegates to database (JDBC) transactions (default)</p></dd><dt><span class="term"><tt class="literal">net.sf.hibernate.transaction.JTATransactionFactory</tt></span></dt><dd><p>delegates to JTA (if an existing transaction is underway, the <tt class="literal">Session</tt>
                        performs its work in that context, otherwise a new transaction is started)</p></dd></dl></div><p>
                You may also define your own transaction strategies (for a CORBA transaction service,
                for example).
            </p><p>
                If you wish to use JVM-level caching of mutable data in a JTA environment, you must specify
                a strategy for obtaining the JTA <tt class="literal">TransactionManager</tt>, as this is
                not standardized for J2EE containers:
            </p><div class="table"><a name="jtamanagerlookup"></a><p class="title"><b>Table&nbsp;3.5.&nbsp;JTA TransactionManagers</b></p><table summary="JTA TransactionManagers" border="1"><colgroup><col><col></colgroup><thead><tr><th>Transaction Factory</th><th align="center">Application Server</th></tr></thead><tbody><tr><td><tt class="literal">net.sf.hibernate.transaction.JBossTransactionManagerLookup</tt></td><td align="center">JBoss</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.WeblogicTransactionManagerLookup</tt></td><td align="center">Weblogic</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.WebSphereTransactionManagerLookup</tt></td><td align="center">WebSphere</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.OrionTransactionManagerLookup</tt></td><td align="center">Orion</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.ResinTransactionManagerLookup</tt></td><td align="center">Resin</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.JOTMTransactionManagerLookup</tt></td><td align="center">JOTM</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.JOnASTransactionManagerLookup</tt></td><td align="center">JOnAS</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.JRun4TransactionManagerLookup</tt></td><td align="center">JRun4</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.BESTransactionManagerLookup</tt></td><td align="center">Borland ES</td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-jndi"></a>3.5.6.&nbsp;JNDI-bound <tt class="literal">SessionFactory</tt></h3></div></div><div></div></div><p>
                A JNDI bound Hibernate <tt class="literal">SessionFactory</tt> can simplify the lookup
                of the factory and the creation of new <tt class="literal">Session</tt>s.
            </p><p>
                If you wish to have the <tt class="literal">SessionFactory</tt> bound to a JNDI namespace, specify
                a name (eg. <tt class="literal">java:comp/env/hibernate/SessionFactory</tt>) using the property
                <tt class="literal">hibernate.session_factory_name</tt>. If this property is omitted, the 
                <tt class="literal">SessionFactory</tt> will not be bound to JNDI. (This is especially useful in 
                environments with a read-only JNDI default implementation, eg. Tomcat.)
            </p><p>
                When binding the <tt class="literal">SessionFactory</tt> to JNDI, Hibernate will use the values of
                <tt class="literal">hibernate.jndi.url</tt>, <tt class="literal">hibernate.jndi.class</tt> to instantiate 
                an initial context. If they are not specified, the default <tt class="literal">InitialContext</tt>
                will be used.
            </p><p>
                If you do choose to use JNDI, an EJB or other utility class may obtain the 
                <tt class="literal">SessionFactory</tt> using a JNDI lookup.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-querysubstitution"></a>3.5.7.&nbsp;Query Language Substitution</h3></div></div><div></div></div><p>
                You may define new Hibernate query tokens using <tt class="literal">hibernate.query.substitutions</tt>.
                For example:
            </p><pre class="programlisting">hibernate.query.substitutions true=1, false=0</pre><p>
                would cause the tokens <tt class="literal">true</tt> and <tt class="literal">false</tt> to be translated to
                integer literals in the generated SQL.
            </p><pre class="programlisting">hibernate.query.substitutions toLowercase=LOWER</pre><p>
                would allow you to rename the SQL <tt class="literal">LOWER</tt> function.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-logging"></a>3.6.&nbsp;Logging</h2></div></div><div></div></div><p>
            Hibernate logs various events using Apache commons-logging.
        </p><p>
            The commons-logging service will direct output to either Apache Log4j
            (if you include <tt class="literal">log4j.jar</tt> in your classpath) or
            JDK1.4 logging (if running under JDK1.4 or above). You may download
            Log4j from <tt class="literal">http://jakarta.apache.org</tt>.
            To use Log4j you will need to place a <tt class="literal">log4j.properties</tt>
            file in your classpath, an example properties file is distributed with
            Hibernate in the <tt class="literal">src/</tt> directory.
        </p><p>
            We strongly recommend that you familiarize yourself with Hibernate's log
            messages. A lot of work has been put into making the Hibernate log as
            detailed as possible, without making it unreadable. It is an essential
            troubleshooting device. Also don't forget to enable SQL logging as
            described above (<tt class="literal">hibernate.show_sql</tt>), it is your first
            step when looking for performance problems.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-namingstrategy"></a>3.7.&nbsp;Implementing a <tt class="literal">NamingStrategy</tt></h2></div></div><div></div></div><p>
            The interface <tt class="literal">net.sf.hibernate.cfg.NamingStrategy</tt> allows you
            to specify a "naming standard" for database objects and schema elements.
        </p><p>
            You may provide rules for automatically generating database identifiers from
            Java identifiers or for processing "logical" column and table names given in
            the mapping file into  "physical" table and column names. This feature helps
            reduce the verbosity of the mapping document, eliminating repetitive noise
            (<tt class="literal">TBL_</tt> prefixes, for example). The default strategy used by
            Hibernate is quite minimal.
        </p><p>
            You may specify a different strategy by calling
            <tt class="literal">Configuration.setNamingStrategy()</tt> before adding mappings:
        </p><pre class="programlisting">SessionFactory sf = new Configuration()
    .setNamingStrategy(ImprovedNamingStrategy.INSTANCE)
    .addFile("Item.hbm.xml")
    .addFile("Bid.hbm.xml")
    .buildSessionFactory();</pre><p>
            <tt class="literal">net.sf.hibernate.cfg.ImprovedNamingStrategy</tt> is a built-in
            strategy that might be a useful starting point for some applications.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-xmlconfig"></a>3.8.&nbsp;XML Configuration File</h2></div></div><div></div></div><p>
            An alternative approach is to specify a full configuration in a file named
            <tt class="literal">hibernate.cfg.xml</tt>. This file can be used as a replacement
            for the <tt class="literal">hibernate.properties</tt> file or, if both are present,
            override properties.
        </p><p>
            The XML configuration file is by default expected to be in the root o
            your <tt class="literal">CLASSPATH</tt>. Here is an example:
        </p><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 2.0//EN"

 "http://hibernate.sourceforge.net/hibernate-configuration-2.0.dtd"&gt;

&lt;hibernate-configuration&gt;

    &lt;!-- a SessionFactory instance listed as /jndi/name --&gt;
    &lt;session-factory
        name="java:comp/env/hibernate/SessionFactory"&gt;

        &lt;!-- properties --&gt;
        &lt;property name="connection.datasource"&gt;my/first/datasource&lt;/property&gt;
        &lt;property name="dialect"&gt;net.sf.hibernate.dialect.MySQLDialect&lt;/property&gt;
        &lt;property name="show_sql"&gt;false&lt;/property&gt;
        &lt;property name="use_outer_join"&gt;true&lt;/property&gt;
        &lt;property name="transaction.factory_class"&gt;
            net.sf.hibernate.transaction.JTATransactionFactory
        &lt;/property&gt;
        &lt;property name="jta.UserTransaction"&gt;java:comp/UserTransaction&lt;/property&gt;

        &lt;!-- mapping files --&gt;
        &lt;mapping resource="org/hibernate/auction/Item.hbm.xml"/&gt;
        &lt;mapping resource="org/hibernate/auction/Bid.hbm.xml"/&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre><p>
           Configuring Hibernate is then as simple as
       </p><pre class="programlisting">SessionFactory sf = new Configuration().configure().buildSessionFactory();</pre><p>
           You can pick a different XML configuration file using
       </p><a name="configuration-xmlconfig-ex3"></a><pre class="programlisting">SessionFactory sf = new Configuration()
    .configure("/my/package/catdb.cfg.xml")
    .buildSessionFactory();</pre></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="architecture.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="persistent-classes.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;2.&nbsp;Architecture&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;4.&nbsp;Persistent Classes</td></tr></table></div></body></html>