<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HIBERNATE - Persistence Relationnelle dans un Java standard</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="fr"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>HIBERNATE - Persistence Relationnelle dans un Java standard</h1></div><div><h2 class="subtitle">Documentation de r&eacute;f&eacute;rence d'Hibernate</h2></div><div><p class="releaseinfo">2.1.8</p></div></div><div></div><hr></div><div class="toc"><p><b>Table des mati&egrave;res</b></p><dl><dt><span class="preface"><a href="#preface">Pr&eacute;face</a></span></dt><dt><span class="chapter"><a href="#quickstart">1. Exemple simple utilisant Tomcat</a></span></dt><dd><dl><dt><span class="sect1"><a href="#quickstart-intro">1.1. Vos d&eacute;buts avec Hibernate</a></span></dt><dt><span class="sect1"><a href="#quickstart-persistentclass">1.2. La premi&egrave;re classe persistante</a></span></dt><dt><span class="sect1"><a href="#quickstart-mapping">1.3. Mapper le Chat</a></span></dt><dt><span class="sect1"><a href="#quickstart-playingwithcats">1.4. Jouer avec les chats</a></span></dt><dt><span class="sect1"><a href="#quickstart-summary">1.5. Conclusion</a></span></dt></dl></dd><dt><span class="chapter"><a href="#architecture">2. Architecture</a></span></dt><dd><dl><dt><span class="sect1"><a href="#architecture-overview">2.1. G&eacute;n&eacute;ralit&eacute;s</a></span></dt><dt><span class="sect1"><a href="#architecture-jmx">2.2. Integration JMX</a></span></dt><dt><span class="sect1"><a href="#architecture-jca">2.3. Support JCA</a></span></dt></dl></dd><dt><span class="chapter"><a href="#session-configuration">3. Configuration de la SessionFactory</a></span></dt><dd><dl><dt><span class="sect1"><a href="#configuration-programmatic">3.1. Configuration par programmation</a></span></dt><dt><span class="sect1"><a href="#configuration-sessionfactory">3.2. Obtenir une SessionFactory</a></span></dt><dt><span class="sect1"><a href="#configuration-userjdbc">3.3. Connexion JDBC fournie par l'utilisateur</a></span></dt><dt><span class="sect1"><a href="#configuration-hibernatejdbc">3.4. Connexions JDBC fournie par Hibernate</a></span></dt><dt><span class="sect1"><a href="#configuration-optional">3.5. Propri&eacute;t&eacute;s de configuration optionnelles</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuration-optional-dialects">3.5.1. Dialectes SQL</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-outerjoin">3.5.2. Chargement par Jointure Ouverte</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-binarystreams">3.5.3. Flux binaires</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-cacheprovider">3.5.4. CacheProvider sp&eacute;cifique</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-transactionstrategy">3.5.5. Configuration de la strat&eacute;gie transactionnelle</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-jndi">3.5.6. SessionFactory associ&eacute;e au JNDI</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-querysubstitution">3.5.7. Substitution dans le langage de requ&ecirc;tage</a></span></dt></dl></dd><dt><span class="sect1"><a href="#configuration-logging">3.6. Logguer</a></span></dt><dt><span class="sect1"><a href="#configuration-namingstrategy">3.7. Impl&eacute;menter une NamingStrategy</a></span></dt><dt><span class="sect1"><a href="#configuration-xmlconfig">3.8. Fichier de configuration XML</a></span></dt></dl></dd><dt><span class="chapter"><a href="#persistent-classes">4. Classes persistantes</a></span></dt><dd><dl><dt><span class="sect1"><a href="#persistent-classes-pojo">4.1. Un exemple simple de POJO</a></span></dt><dd><dl><dt><span class="sect2"><a href="#persistent-classes-pojo-accessors">4.1.1. D&eacute;clarer les accesseurs et modifieurs des attributs persistants</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-constructor">4.1.2. Impl&eacute;menter un constructeur par d&eacute;faut</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-identifier">4.1.3. Fournir une propri&eacute;t&eacute; d'indentifiant (optionnel)</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-final">4.1.4. Favoriser les classes non finales (optionnel)</a></span></dt></dl></dd><dt><span class="sect1"><a href="#persistent-classes-inheritance">4.2. Impl&eacute;menter l'h&eacute;ritage</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-equalshashcode">4.3. Impl&eacute;menter equals() et hashCode()</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-lifecycle">4.4. Callbacks de cycle de vie</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-validatable">4.5. Callback de validation</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-xdoclet">4.6. Utiliser le marquage XDoclet</a></span></dt></dl></dd><dt><span class="chapter"><a href="#mapping">5. Mapping O/R basique</a></span></dt><dd><dl><dt><span class="sect1"><a href="#mapping-declaration">5.1. D&eacute;claration de Mapping</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-declaration-doctype">5.1.1. Doctype</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-mapping">5.1.2. hibernate-mapping</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-class">5.1.3. class</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id">5.1.4. id</a></span></dt><dd><dl><dt><span class="sect3"><a href="#mapping-declaration-id-generator">5.1.4.1. generator</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-hilo">5.1.4.2. Algorithme Hi/Lo</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-uuid">5.1.4.3. UUID Algorithm</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-sequences">5.1.4.4. Colonne Identity et Sequences</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-assigned">5.1.4.5. Identifiants assign&eacute;s</a></span></dt></dl></dd><dt><span class="sect2"><a href="#mapping-declaration-compositeid">5.1.5. composite-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-discriminator">5.1.6. discriminator</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-version">5.1.7. version (optionnel)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-timestamp">5.1.8. timestamp (optionnel)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-property">5.1.9. property</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-manytoone">5.1.10. many-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-onetoone">5.1.11. one-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-component">5.1.12. component, dynamic-component</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-subclass">5.1.13. subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-joinedsubclass">5.1.14. joined-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-collections">5.1.15. map, set, list, bag</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-import">5.1.16. import</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-types">5.2. Types Hibernate</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-types-entitiesvalues">5.2.1. Entit&eacute;s et valeurs</a></span></dt><dt><span class="sect2"><a href="#mapping-types-basictypes">5.2.2. Les types de valeurs basiques</a></span></dt><dt><span class="sect2"><a href="#mapping-types-enum">5.2.3. Type persistant d'enum&eacute;ration</a></span></dt><dt><span class="sect2"><a href="#mapping-types-custom">5.2.4. Types de valeurs personnalis&eacute;s</a></span></dt><dt><span class="sect2"><a href="#mapping-types-anymapping">5.2.5. Type de mappings "Any"</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-quotedidentifiers">5.3. identificateur SQL mis entre guillemets</a></span></dt><dt><span class="sect1"><a href="#mapping-modularfiles">5.4. Fichiers de mapping modulaires</a></span></dt></dl></dd><dt><span class="chapter"><a href="#collections">6. Mapping des Collections</a></span></dt><dd><dl><dt><span class="sect1"><a href="#collections-persistent">6.1. Collections persistantes</a></span></dt><dt><span class="sect1"><a href="#collections-mapping">6.2. Mapper une Collection</a></span></dt><dt><span class="sect1"><a href="#collections-ofvalues">6.3. Collections de valeurs et associations Plusieurs-vers-Plusieurs</a></span></dt><dt><span class="sect1"><a href="#collections-onetomany">6.4. Associations Un-vers-Plusieurs</a></span></dt><dt><span class="sect1"><a href="#collections-lazy">6.5. Initialisation tardive</a></span></dt><dt><span class="sect1"><a href="#collections-sorted">6.6. Collections tri&eacute;es</a></span></dt><dt><span class="sect1"><a href="#collections-idbag">6.7. Utiliser un &lt;idbag&gt;</a></span></dt><dt><span class="sect1"><a href="#collections-bidirectional">6.8. Associations Bidirectionnelles</a></span></dt><dt><span class="sect1"><a href="#collections-ternary">6.9. Associations ternaires</a></span></dt><dt><span class="sect1"><a href="#collections-heterogeneous">6.10. Associations h&eacute;t&eacute;rog&egrave;nes</a></span></dt><dt><span class="sect1"><a href="#collections-example">6.11. Exemples de collection</a></span></dt></dl></dd><dt><span class="chapter"><a href="#components">7. Mappings des composants</a></span></dt><dd><dl><dt><span class="sect1"><a href="#components-dependentobjects">7.1. Objets d&eacute;pendants</a></span></dt><dt><span class="sect1"><a href="#components-incollections">7.2. Collections d'objets dependants</a></span></dt><dt><span class="sect1"><a href="#components-asmapindex">7.3. Composants pour les indexes de Map</a></span></dt><dt><span class="sect1"><a href="#components-compositeid">7.4. composants en tant qu'identifiants compos&eacute;s</a></span></dt><dt><span class="sect1"><a href="#components-dynamic">7.5. Composants dynamiques</a></span></dt></dl></dd><dt><span class="chapter"><a href="#inheritance">8. Mapping de l'h&eacute;ritage de classe</a></span></dt><dd><dl><dt><span class="sect1"><a href="#inheritance-strategies">8.1. Les trois strat&eacute;gies</a></span></dt><dt><span class="sect1"><a href="#inheritance-limitations">8.2. Limitations</a></span></dt></dl></dd><dt><span class="chapter"><a href="#manipulatingdata">9. Manipuler les donn&eacute;es persistantes</a></span></dt><dd><dl><dt><span class="sect1"><a href="#manipulatingdata-creating">9.1. Cr&eacute;ation d'un objet persistant</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-loading">9.2. Chargement d'un objet</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-querying">9.3. Requ&ecirc;tage</a></span></dt><dd><dl><dt><span class="sect2"><a href="#manipulatingdata-scalarqueries">9.3.1. Requ&ecirc;tes scalaires</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-queryinterface">9.3.2. L'interface de requ&ecirc;tage Query</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-scrolling">9.3.3. Iteration scrollable</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-filtering">9.3.4. Filtrer les collections</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-criteria">9.3.5. Les requ&ecirc;tes par crit&egrave;res</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-nativesql">9.3.6. Requ&ecirc;tes en SQL natif</a></span></dt></dl></dd><dt><span class="sect1"><a href="#manipulatingdata-updating">9.4. Mise &agrave; jour des objets</a></span></dt><dd><dl><dt><span class="sect2"><a href="#manipulatingdata-updating-insession">9.4.1. Mise &agrave; jour dans la m&ecirc;me session</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-updating-detached">9.4.2. Mise &agrave; jour d'objets d&eacute;tach&eacute;s</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-update-lock">9.4.3. R&eacute;associer des objets d&eacute;tach&eacute;s</a></span></dt></dl></dd><dt><span class="sect1"><a href="#manipulatingdata-deleting">9.5. Suppression d'objets persistants</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-flushing">9.6. Flush</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-endingsession">9.7. Terminer une Session</a></span></dt><dd><dl><dt><span class="sect2"><a href="#manipulatingdata-endingsession-flushing">9.7.1. Flusher la Session</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-endingsession-commit">9.7.2. Commit de la transaction de la base de donn&eacute;es</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-endingsession-close">9.7.3. Fermeture de la Session</a></span></dt></dl></dd><dt><span class="sect1"><a href="#manipulatingdata-exceptions">9.8. Traitement des exceptions</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-graphs">9.9. Cycles de vie et graphes d'objets</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-interceptors">9.10. Intercepteurs</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-metadata">9.11. API d'acc&egrave;s aux m&eacute;tadonn&eacute;es</a></span></dt></dl></dd><dt><span class="chapter"><a href="#transactions">10. Transactions et acc&egrave;s concurrents</a></span></dt><dd><dl><dt><span class="sect1"><a href="#transactions-basics">10.1. Configurations, Sessions et Fabriques (Factories)</a></span></dt><dt><span class="sect1"><a href="#transactions-threads">10.2. Threads et connections</a></span></dt><dt><span class="sect1"><a href="#transactions-identity">10.3. Comprendre l'identit&eacute; d'un objet</a></span></dt><dt><span class="sect1"><a href="#transactions-optimistic">10.4. Gestion de la concurrence par contr&ocirc;le optimiste</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-optimistic-longsession">10.4.1. Session longue avec versionnage automatique</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-detached">10.4.2. Plusieurs sessions avec versionnage automatique</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-manual">10.4.3. Contr&ocirc;le de version de mani&egrave;re applicative</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-disconnection">10.5. D&eacute;connexion de Session</a></span></dt><dt><span class="sect1"><a href="#transactions-locking">10.6. V&eacute;rouillage pessimiste</a></span></dt></dl></dd><dt><span class="chapter"><a href="#queryhql">11. HQL: Langage de requ&ecirc;tage d'Hibernate</a></span></dt><dd><dl><dt><span class="sect1"><a href="#queryhql-casesensitivity">11.1. Sensibilit&eacute; &agrave; la casse</a></span></dt><dt><span class="sect1"><a href="#queryhql-from">11.2. La clause from</a></span></dt><dt><span class="sect1"><a href="#queryhql-joins">11.3. Associations et jointures</a></span></dt><dt><span class="sect1"><a href="#queryhql-select">11.4. La clause select</a></span></dt><dt><span class="sect1"><a href="#queryhql-aggregation">11.5. Fonctions d'aggr&eacute;gation</a></span></dt><dt><span class="sect1"><a href="#queryhql-polymorphism">11.6. Requ&ecirc;tes polymorphiques</a></span></dt><dt><span class="sect1"><a href="#queryhql-where">11.7. La clause where</a></span></dt><dt><span class="sect1"><a href="#queryhql-expressions">11.8. Expressions</a></span></dt><dt><span class="sect1"><a href="#queryhql-ordering">11.9. La clause order by</a></span></dt><dt><span class="sect1"><a href="#queryhql-grouping">11.10. La clause group by</a></span></dt><dt><span class="sect1"><a href="#queryhql-subqueries">11.11. Sous requ&ecirc;tes</a></span></dt><dt><span class="sect1"><a href="#queryhql-examples">11.12. Exemples HQL</a></span></dt><dt><span class="sect1"><a href="#queryhql-tipstricks">11.13. Trucs &amp; Astuces</a></span></dt></dl></dd><dt><span class="chapter"><a href="#querycriteria">12. Requ&ecirc;tes par crit&egrave;res</a></span></dt><dd><dl><dt><span class="sect1"><a href="#querycriteria-creating">12.1. Cr&eacute;er une instance de Criteria</a></span></dt><dt><span class="sect1"><a href="#querycriteria-narrowing">12.2. Restriction du r&eacute;sultat</a></span></dt><dt><span class="sect1"><a href="#querycriteria-ordering">12.3. Trier les r&eacute;sultats</a></span></dt><dt><span class="sect1"><a href="#querycriteria-associations">12.4. Associations</a></span></dt><dt><span class="sect1"><a href="#querycriteria-dynamicfetching">12.5. Peuplement d'associations de mani&egrave;re dynamique</a></span></dt><dt><span class="sect1"><a href="#querycriteria-examples">12.6. Requ&ecirc;te par l'exemple</a></span></dt></dl></dd><dt><span class="chapter"><a href="#querysql">13. Requ&ecirc;tes en sql natif</a></span></dt><dd><dl><dt><span class="sect1"><a href="#querysql-creating">13.1. Cr&eacute;er une requ&ecirc;te bas&eacute;e sur SQL</a></span></dt><dt><span class="sect1"><a href="#querysql-aliasreferences">13.2. Alias et r&eacute;f&eacute;rences de propri&eacute;t&eacute;s</a></span></dt><dt><span class="sect1"><a href="#querysql-namedqueries">13.3. Requ&ecirc;tes SQL nomm&eacute;es</a></span></dt></dl></dd><dt><span class="chapter"><a href="#performance">14. Am&eacute;liorer les performances</a></span></dt><dd><dl><dt><span class="sect1"><a href="#performance-collections">14.1. Comprendre les performances des Collections</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-collections-taxonomy">14.1.1. Classification</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficientupdate">14.1.2. Les lists, les maps et les sets sont les collections les plus efficaces pour la mise &agrave; jour</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficentinverse">14.1.3. Les Bags et les lists sont les plus efficaces pour les collections inverse</a></span></dt><dt><span class="sect2"><a href="#performance-collections-oneshotdelete">14.1.4. Suppression en un coup</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-proxies">14.2. Proxy pour une Initialisation Tardive</a></span></dt><dt><span class="sect1"><a href="#performance-batchfetching">14.3. Utiliser le batch fetching (chargement par batch)</a></span></dt><dt><span class="sect1"><a href="#performance-cache">14.4. Le cache de second niveau</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-cache-mapping">14.4.1. Mapping de Cache</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readonly">14.4.2. Strategie : lecture seule</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readwrite">14.4.3. Strat&eacute;gie : lecture/&eacute;criture</a></span></dt><dt><span class="sect2"><a href="#performance-cache-nonstrict">14.4.4. Strat&eacute;gie : lecture/&eacute;criture non stricte</a></span></dt><dt><span class="sect2"><a href="#performance-cache-transactional">14.4.5. Strat&eacute;gie : transactionelle</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-sessioncache">14.5. G&eacute;rer le cache de la Session </a></span></dt><dt><span class="sect1"><a href="#performance-querycache">14.6. Le cache de requ&ecirc;tes</a></span></dt></dl></dd><dt><span class="chapter"><a href="#toolsetguide">15. Guide des outils</a></span></dt><dd><dl><dt><span class="sect1"><a href="#toolsetguide-s1">15.1. G&eacute;n&eacute;ration de Sch&eacute;ma</a></span></dt><dd><dl><dt><span class="sect2"><a href="#toolsetguide-s1-2">15.1.1. Personnaliser le sch&eacute;ma</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-3">15.1.2. Ex&eacute;cuter l'outil</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-4">15.1.3. Propri&eacute;t&eacute;s</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-5">15.1.4. Utiliser Ant</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-6">15.1.5. Mises &agrave; jour incr&eacute;mentales du sch&eacute;ma</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-7">15.1.6. Utiliser Ant pour des mises &agrave; jour de sch&eacute;ma par incr&eacute;ment</a></span></dt></dl></dd><dt><span class="sect1"><a href="#toolsetguide-s2">15.2. G&eacute;n&eacute;ration de code</a></span></dt><dd><dl><dt><span class="sect2"><a href="#toolsetguide-s2-1">15.2.1. Le fichier de configuration (optionnel)</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s2-2">15.2.2. L'attribut meta</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s2-3">15.2.3. G&eacute;n&eacute;rateur de Requ&ecirc;teur Basique (Basic Finder)</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s2-4">15.2.4. Renderer/G&eacute;n&eacute;rateur bas&eacute;s sur Velocity</a></span></dt></dl></dd><dt><span class="sect1"><a href="#toolsetguide-s3">15.3. G&eacute;n&eacute;ration des fichier de mapping</a></span></dt><dd><dl><dt><span class="sect2"><a href="#toolsetguide-s3-1">15.3.1. Ex&eacute;cuter l'outil</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#example-parentchild">16. Exemple : P&egrave;re/Fils</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-parentchild-collections">16.1. Une note &agrave; propos des collections</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-bidir">16.2. un-vers-plusieurs bidirectionnel</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-cascades">16.3. Cycle de vie en cascade</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-update">16.4. Utiliser update() en cascade</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-conclusion">16.5. Conclusion</a></span></dt></dl></dd><dt><span class="chapter"><a href="#example-weblog">17. Exemple : Application de Weblog</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-weblog-classes">17.1. Classes persistantes</a></span></dt><dt><span class="sect1"><a href="#example-weblog-mappings">17.2. Mappings Hibernate</a></span></dt><dt><span class="sect1"><a href="#example-weblog-code">17.3. Code Hibernate</a></span></dt></dl></dd><dt><span class="chapter"><a href="#example-mappings">18. Exemple : Quelques mappings</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-mappings-emp">18.1. Employeur/Employ&eacute; (Employer/Employee)</a></span></dt><dt><span class="sect1"><a href="#example-mappings-authorwork">18.2. Auteur/Travail (Author/Work)</a></span></dt><dt><span class="sect1"><a href="#example-mappings-customerorderproduct">18.3. Client/Commande/Produit (Customer/Order/Product)</a></span></dt></dl></dd><dt><span class="chapter"><a href="#best-practices">19. Meilleures pratiques</a></span></dt></dl></div><div class="preface" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>Pr&eacute;face</h2></div></div><div></div></div><p>
            WARNING! This is a translated version of the English Hibernate reference
            documentation. The translated version might not be up to date! However, the
            differences should only be very minor. Consult the English reference
            documentation if you are missing information or encounter a translation
            error. If you like to contribute to a particular translation, contact us
            on the Hibernate developer mailing list.
        </p><p>
            Traducteur(s): Anthony Patricio &lt;anthony@hibernate.org&gt;,
                            Emmanuel Bernard &lt;emmanuel@hibernate.org&gt;,
                            R&eacute;my Laroche, Bassem Khadige, St&eacute;phane Vanpoperynghe
        </p><p>
            Travailler dans les deux univers que sont l'orient&eacute; objet et la base de donn&eacute;es
	    relationnelle peut &ecirc;tre lourd et consommateur en temps dans le monde de
            l'entreprise d'aujourd'hui. Hibernate est un outil de  mapping objet/relationnel 
	    pour le monde Java. Le terme mapping objet/relationnel (ORM) d&eacute;crit la technique
	    consistant &agrave; faire le lien entre la repr&eacute;sentation objet des donn&eacute;es  
	    et sa repr&eacute;sentation relationnelle bas&eacute; sur un sch&eacute;ma SQL.
        </p><p>
            Non seulement, Hibernate s'occupe du transfert des classes Java dans les tables 
	    de la base de donn&eacute;es (et des types de donn&eacute;es Java dans les types de donn&eacute;es SQL), 
	    mais il permet de requ&ecirc;ter les donn&eacute;es et propose des moyens de les r&eacute;cup&eacute;rer. 
	    Il peut donc r&eacute;duire de mani&egrave;re significative le temps de d&eacute;veloppement qui 
	    aurait &eacute;t&eacute; d&eacute;pens&eacute; autrement dans une manipulation manuelle des donn&eacute;es via SQL 
	    et JDBC.
        </p><p>
            Le but d'Hibernate est de lib&eacute;rer le d&eacute;veloppeur de 95 pourcent des t&acirc;ches de
            programmation li&eacute;es &agrave; la persistence des donn&eacute;es communes. Hibernate n'est
            probablement pas la meilleure solution pour les applications centr&eacute;es sur les
            donn&eacute;es qui n'utilisent que les proc&eacute;dures stock&eacute;es pour impl&eacute;menter la logique
            m&eacute;tier dans la base de donn&eacute;es, il est le plus utile dans les mod&egrave;les m&eacute;tier orient&eacute;s
            objets dont la logique m&eacute;tier est impl&eacute;ment&eacute;e dans la couche Java dite interm&eacute;diaire.
            Cependant, Hibernate vous aidera &agrave; supprimer ou &agrave; encapsuler le code SQL
            sp&eacute;cifique &agrave; votre base de donn&eacute;es et vous aidera sur la t&acirc;che commune qu'est
            la transformation des donn&eacute;es d'une repr&eacute;sentation tabulaire &agrave; une 
            repr&eacute;sentation sous forme de graphe d'objets.
        </p><p>
            Si vous &ecirc;tes nouveau dans Hibernate et le mapping Objet/Relationnel voire m&ecirc;me en Java,
            suivez ces quelques &eacute;tapes :
        </p><div class="orderedlist"><ol type="1"><li><p>
                    Lisez <a href="#quickstart" title="Chapitre&nbsp;1.&nbsp;Exemple simple utilisant Tomcat">Chapitre&nbsp;1, <i>Exemple simple utilisant Tomcat</i></a>, c'est un tutoriel de 30 minutes utilisant Tomcat.
                </p></li><li><p>
                    Lisez <a href="#architecture" title="Chapitre&nbsp;2.&nbsp;Architecture">Chapitre&nbsp;2, <i>Architecture</i></a> pour comprendre les environnements dans lesquels
                    Hibernate peut &ecirc;tre utilis&eacute;.
                </p></li><li><p>
                    Regardez le r&eacute;pertoire <tt class="literal">eg</tt> de la distribution Hibernate, il contient
                    une application simple et autonome. Copiez votre pilote JDBC dans le r&eacute;pertoire
                    <tt class="literal">lib/</tt> et &eacute;ditez <tt class="literal">src/hibernate.properties</tt>, en
                    positionnant correctement les valeurs pour votre base de donn&eacute;es. A partir d'une 
                    invite de commande dans le r&eacute;pertoire de la distribution, tapez <tt class="literal">ant eg</tt> 
                    (cela utilise Ant), ou sous Windows tapez <tt class="literal">build eg</tt>.
                </p></li><li><p>
                    Fa&icirc;tes de cette documentation de r&eacute;f&eacute;rence votre principale source d'information.
					Pensez &agrave; lire <span class="emphasis"><em>Hibernate in Action</em></span>
                    (http://www.manning.com/bauer) si vous avez besoin de plus d'aide avec le design
                    d'applications ou si vous pr&eacute;f&eacute;rez un tutoriel pas &agrave; pas. Visitez aussi
                    http://caveatemptor.hibernate.org et t&eacute;l&eacute;chargez l'application exemple
                    pour Hibernate in Action.
                </p></li><li><p>
                    Les questions les plus fr&eacute;quemment pos&eacute;es (FAQs) trouvent leur r&eacute;ponse sur le
                    site web Hibernate.
		</p></li><li><p>
                    Des d&eacute;mos, exemples et tutoriaux de tierces personnes sont r&eacute;f&eacute;renc&eacute;s sur 
                    le site web Hibernate.
		</p></li><li><p>
                    La zone communautaire (Community Area) du site web Hibernate est une
                    bonne source d'information sur les design patterns et sur diff&eacute;rentes
                    solutions d'int&eacute;gration d'Hibernate (Tomcat, JBoss, Spring Framework, Struts,
                    EJB, etc...).
                </p></li></ol></div><p>
             Si vous avez des questions, utilisez le forum utilisateurs du site web Hibernate. 
             Nous utilisons &eacute;galement l'outil de gestion des incidents JIRA pour tout ce qui
             est rapports de bogue et demandes d'&eacute;volution. Si vous &ecirc;tes int&eacute;ress&eacute; par le
             d&eacute;veloppement d'Hibernate, joignez-vous &agrave; la liste de diffusion de d&eacute;veloppement.
         </p><p>
             Le d&eacute;veloppement commercial, le support de production et les formations &agrave; Hibernate
             sont propos&eacute;s par JBoss Inc (voir http://www.hibernate.org/SupportTraining/). Hibernate
             est un projet de la suite de produits Open Source Professionels JBoss.
         </p></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="quickstart"></a>Chapitre&nbsp;1.&nbsp;Exemple simple utilisant Tomcat</h2></div></div><div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-intro"></a>1.1.&nbsp;Vos d&eacute;buts avec Hibernate</h2></div></div><div></div></div><p>
            Ce tutoriel d&eacute;taille la mise en place d'Hibernate 2.1 avec le conteneur de
            servlet Apache Tomcat sur une application web. Hibernate est pr&eacute;vu pour fonctionner 
            &agrave; la fois dans un environnement manag&eacute; tel que propos&eacute; par tous les plus 
            grands serveurs d'applications J2EE, mais aussi dans les applications Java autonomes.
            Bien que le syst&egrave;me de base de donn&eacute;es utilis&eacute; dans ce toturiel soit PostgreSQL 7.3,
            le support d'autres bases de donn&eacute;es n'est qu'une question de configuration du 
            dialecte SQL d'Hibernate.
        </p><p>
            Premi&egrave;rement, nous devons copier toutes les biblioth&egrave;ques n&eacute;cessaires &agrave; l'installation
            dans Tomcat. Utilisant un contexte web s&eacute;par&eacute; (<tt class="literal">webapps/quickstart</tt>)
            pour ce tutoriel, nous devons faire attention &agrave; la fois au chemin vers des biblioth&egrave;ques
            globales (<tt class="literal">TOMCAT/common/lib</tt>) et au chemin du classloader contextuel 
            de la webapp dans <tt class="literal">webapps/quickstart/WEB-INF/lib</tt> (pour les fichiers JAR) et
            <tt class="literal">webapps/quickstart/WEB-INF/classes</tt>. On se r&eacute;f&egrave;rera aux deux niveaux
            de classloader que sont le classloader de classpath global et de classpath contextuel de la webapp.
        </p><p>
            Maintenant, copions les biblioth&egrave;ques dans les deux classpaths :
        </p><div class="orderedlist"><ol type="1"><li><p>
                    Copiez le pilote JDBC de la base de donn&eacute;es dans le classpath global. C'est
                    n&eacute;cessaire &agrave; l'utilisation du pool de connexions DBCP qui vient avec Tomcat.
                    Hibernate utilise les connexions JDBC pour ex&eacute;cuter les ordres SQL sur la base de donn&eacute;es,
                    donc vous devez soit fournir les connexions JDBC pool&eacute;es, soit configurer Hibernate
                    pour utiliser l'un des pools nativement support&eacute;s (C3P0, Proxool). Pour ce tutoriel,
                    copiez la blblioth&egrave;que <tt class="literal">pg73jdbc3.jar</tt> (pour PostgreSQL 7.3 et le JDK 1.4)
                    dans le classpath global. Si vous voulez utiliser une base de donn&eacute;es diff&eacute;rente, copiez
                    simplement le pilote JDBC appropri&eacute;.
                </p></li><li><p>
                    Ne copiez jamais autre chose dans le classpath global de Tomcat ou vous auriez des
                    probl&egrave;mes avec divers outils tels que log4j, commons-logging, et d'autres. Utilisez 
                    toujours le classpath contextuel de la webapp propre &agrave; chaque application, et donc copiez les 
                    biblioth&egrave;ques dans <tt class="literal">WEB-INF/lib</tt>, puis copiez vos propres
                    classes ainsi que les fichiers de configuration/de propri&eacute;t&eacute; dans 
                    <tt class="literal">WEB-INF/classes</tt>. Ces deux r&eacute;pertoires sont, 
                    par d&eacute;finition de la sp&eacute;cification J2EE, dans le classpath contextuel de la webapp.
				</p></li><li><p>
                    Hibernate se pr&eacute;sente sous la forme d'une blblioth&egrave;que JAR. Le fichier 
                    <tt class="literal">hibernate2.jar</tt> doit &ecirc;tre copi&eacute; dans le classpath  
                    contextuel de la webapp avec les autres classes de l'application. 
                    Hibernate a besoin
                    de quelques biblioth&egrave;ques tierces &agrave; l'ex&eacute;cution, elles sont embarqu&eacute;es dans
                    la distribution Hibernate et se trouvent dans le r&eacute;pertoire
                    <tt class="literal">lib/</tt> ; voir <a href="#3rdpartylibs" title="Tableau&nbsp;1.1.&nbsp;&#xA;                Biblioth&egrave;ques tierces n&eacute;cessaires &agrave; Hibernate&#xA;            ">Tableau&nbsp;1.1, &laquo;&nbsp;
                Biblioth&egrave;ques tierces n&eacute;cessaires &agrave; Hibernate
            &nbsp;&raquo;</a>.
                    Copiez les biblioth&egrave;ques tierces requises dans le classpath de contexte.
                </p></li></ol></div><div class="table"><a name="3rdpartylibs"></a><p class="title"><b>Tableau&nbsp;1.1.&nbsp;
                Biblioth&egrave;ques tierces n&eacute;cessaires &agrave; Hibernate
            </b></p><table summary="&#xA;                Biblioth&egrave;ques tierces n&eacute;cessaires &agrave; Hibernate&#xA;            " border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">
                            Biblioth&egrave;que
                        </th><th align="center">
                            Description
                        </th></tr></thead><tbody><tr><td>
                            dom4j (requise)
                        </td><td>
                            Hibernate utilise dom4j pour lire la configuration XML
                            et les fichiers XML de m&eacute;tadonn&eacute;es du mapping.
                        </td></tr><tr><td>
                            CGLIB (requise)
                        </td><td>
                            Hibernate utilise cette biblioth&egrave;que de g&eacute;n&eacute;ration de code
                            pour &eacute;tendre les classes &agrave; l'ex&eacute;cution (en conjonction
                            avec la r&eacute;flexion Java).
                        </td></tr><tr><td>
                            Commons Collections, Commons Logging (requises)
                        </td><td>
                            Hibernate utilise diverses biblioth&egrave;ques du projet Apache
                            Jakarta Commons.
                        </td></tr><tr><td>
                            ODMG4 (requise)
                        </td><td>
                            Hibernate est compatible avec l'interface de gestion de la 
                            persistance telle que d&eacute;finie par l'ODMG. Elle est n&eacute;cessaire
                            si vous voulez mapper des collections m&ecirc;me si vous n'avez pas
                            l'intention d'utiliser l'API de l'ODMG. Nous ne mappons pas de
                            collections dans ce tutoriel, mais, quoi qu'il arrive c'est une
                            bonne id&eacute;e de copier ce JAR.
                        </td></tr><tr><td>
                            EHCache (requise)
                        </td><td>
                            Hibernate peut utiliser diverses impl&eacute;mentations de cache de second 
                            niveau. EHCache est l'impl&eacute;mentation par d&eacute;faut (tant qu'elle n'est
                            pas chang&eacute;e dans le fichier de configuration).
                        </td></tr><tr><td>
                            Log4j (optionnelle)
                        </td><td>
                            Hibernate utilise l'API Commons Logging, qui peut utiliser log4j comme
                            m&eacute;canisme de log sous-jacent. Si la biblioth&egrave;que Log4j est disponible dans
                            le classpath, Commons Logging l'utilisera ainsi que son fichier
                            de configuration <tt class="literal">log4j.properties</tt> r&eacute;cup&eacute;r&eacute; depuis le 
                            classpath. Un exemple de fichier de propri&eacute;t&eacute;s pour log4j
                            est embarqu&eacute; dans la distribution d'Hibernate. Donc, copiez
                            <tt class="literal">log4j.jar</tt> et le fichier de configuration (qui se trouve
                            dans <tt class="literal">src/</tt>) dans le classpath contextuel de la webapp si vous voulez
                            voir ce que fait Hibernate pour vous.
                        </td></tr><tr><td>
                            N&eacute;cessaire ou pas ?
                        </td><td>
                            Jetez un coup d'oeil &agrave; <tt class="literal">lib/README.txt</tt> de la
                            distribution d'Hibernate. C'est une liste &agrave; jour des biblioth&egrave;ques
                            tierces distribu&eacute;es avec Hibernate. Vous y trouverez toutes les
                            biblioth&egrave;ques list&eacute;es et si elles sont requises ou optionnelles.
                        </td></tr></tbody></table></div><p>
            Nous allons maintenant configurer le pool de connexions &agrave; la base de donn&eacute;es
            &agrave; la fois dans Tomcat mais aussi dans Hibernate. Cela signifie que Tomcat
            proposera des connexions JDBC pool&eacute;es (en s'appuyant sur son pool DBCP),
            et qu'Hibernate demandera ces connexions &agrave; travers le JNDI. Tomcat proposant
            l'acc&egrave;s au pool de connexions via JNDI, nous ajoutons la d&eacute;claration de ressource
            dans le fichier de configuration principal de Tomcat
            (<tt class="literal">TOMCAT/conf/server.xml</tt>) :
        </p><pre class="programlisting">&lt;Context path="/quickstart" docBase="quickstart"&gt;
    &lt;Resource name="jdbc/quickstart" scope="Shareable" type="javax.sql.DataSource"/&gt;
    &lt;ResourceParams name="jdbc/quickstart"&gt;
        &lt;parameter&gt;
            &lt;name&gt;factory&lt;/name&gt;
            &lt;value&gt;org.apache.commons.dbcp.BasicDataSourceFactory&lt;/value&gt;
        &lt;/parameter&gt;

        &lt;!-- param&egrave;tres de connexion DBCP &agrave; la base de donn&eacute;es --&gt;
        &lt;parameter&gt;
            &lt;name&gt;url&lt;/name&gt;
            &lt;value&gt;jdbc:postgresql://localhost/quickstart&lt;/value&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
            &lt;name&gt;driverClassName&lt;/name&gt;&lt;value&gt;org.postgresql.Driver&lt;/value&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
            &lt;name&gt;username&lt;/name&gt;
            &lt;value&gt;quickstart&lt;/value&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
            &lt;name&gt;password&lt;/name&gt;
            &lt;value&gt;secret&lt;/value&gt;
        &lt;/parameter&gt;

        &lt;!-- options du pool de connexion DBCP --&gt;
        &lt;parameter&gt;
            &lt;name&gt;maxWait&lt;/name&gt;
            &lt;value&gt;3000&lt;/value&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
            &lt;name&gt;maxIdle&lt;/name&gt;
            &lt;value&gt;100&lt;/value&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
            &lt;name&gt;maxActive&lt;/name&gt;
            &lt;value&gt;10&lt;/value&gt;
        &lt;/parameter&gt;
    &lt;/ResourceParams&gt;
&lt;/Context&gt;</pre><p>
            Le contexte web que l'on a configur&eacute; dans cet exemple se nomme <tt class="literal">quickstart</tt>,
            son r&eacute;pertoire de base &eacute;tant <tt class="literal">TOMCAT/webapp/quickstart</tt>.
            Pour acc&eacute;der aux servlets, appeler l'URL <tt class="literal">http://localhost:8080/quickstart</tt> 
            &agrave; partir de votre navigateur (apr&egrave;s avoir bien entendu ajout&eacute; le nom de votre servlet et
            l'avoir li&eacute; dans votre fichier <tt class="literal">web.xml</tt>). Vous pouvez &eacute;galement commencer &agrave; 
            cr&eacute;er une servlet simple qui poss&egrave;de une m&eacute;thode <tt class="literal">process()</tt> vide.
		</p><p>
            Tomcat utilise le pool de connexions DBCP avec sa configuration et fournit les 
            <tt class="literal">Connection</tt>s JDBC pool&eacute;es &agrave; travers l'interface JNDI &agrave; l'adresse 
            <tt class="literal">java:comp/env/jdbc/quickstart</tt>. Si vous &eacute;prouvez des probl&egrave;mes pour faire
            fonctionner le pool de connexions, r&eacute;f&eacute;rez-vous &agrave; la documentation Tomcat. Si vous
            avez des messages de type exception du pilote JDBC, commencez par configurer le pool de 
            connexions JDBC sans Hibernate. Des tutoriels sur Tomcat et JDBC sont disponibles sur le Web.
        </p><p>
            La prochaine &eacute;tape consiste &agrave; configurer Hibernate pour utiliser les connexions du pool 
            attach&eacute; au JNDI. Nous allons utiliser le fichier de configuration XML d'Hibernate.
            L'approche basique utilisant le fichier .properties est &eacute;quivalente fonctionnellement, mais
            n'offre pas d'avantage. Nous utiliserons le fichier de configuration XML parce que c'est
            souvent plus pratique. Le fichier de configuration XML est plac&eacute; dans le classpath contextuel
            de la webapp (<tt class="literal">WEB-INF/classes</tt>), sous le nom <tt class="literal">hibernate.cfg.xml</tt> :
        </p><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!DOCTYPE hibernate-configuration
    PUBLIC "-//Hibernate/Hibernate Configuration DTD//EN"
    "http://hibernate.sourceforge.net/hibernate-configuration-2.0.dtd"&gt;

&lt;hibernate-configuration&gt;

    &lt;session-factory&gt;

        &lt;property name="connection.datasource"&gt;java:comp/env/jdbc/quickstart&lt;/property&gt;
        &lt;property name="show_sql"&gt;false&lt;/property&gt;
        &lt;property name="dialect"&gt;net.sf.hibernate.dialect.PostgreSQLDialect&lt;/property&gt;

        &lt;!-- fichiers de mapping --&gt;
        &lt;mapping resource="Cat.hbm.xml"/&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre><p>
            Le fichier de configuration montre que nous avons stopp&eacute; la log des commandes
            SQL, positionn&eacute; le dialecte SQL de la base de donn&eacute;es utilis&eacute;e, et fournit
            le lien o&ugrave; r&eacute;cup&eacute;rer les
            connexions JDBC (en d&eacute;clarant l'adresse JNDI &agrave; laquelle est attach&eacute;e le pool de
            source de donn&eacute;es). Le dialecte est un param&egrave;trage n&eacute;cessaire du fait que les
            bases de donn&eacute;es diff&egrave;rent dans leur interpr&eacute;tation du SQL "standard". Hibernate
            s'occupe de ces diff&eacute;rences et vient avec des dialectes pour toutes les
            bases de donn&eacute;es les plus connues commerciales ou open sources.
        </p><p>
            Une <tt class="literal">SessionFactory</tt> est un concept Hibernate qui repr&eacute;sente
            un et un seul entrep&ocirc;t de donn&eacute;es ; plusieurs bases de donn&eacute;es peuvent &ecirc;tre
            utilis&eacute;es en cr&eacute;ant plusieurs fichiers de configuration XML, plusieurs objets
            <tt class="literal">Configuration</tt> et <tt class="literal">SessionFactory</tt> dans
            votre application.
        </p><p>
            Le dernier &eacute;l&eacute;ment de <tt class="literal">hibernate.cfg.xml</tt> d&eacute;clare
            <tt class="literal">Cat.hbm.xml</tt> comme fichier de mapping Hibernate pour
            la classe <tt class="literal">Cat</tt>. Ce fichier contient les m&eacute;tadonn&eacute;es
            du lien entre la classe Java (aussi appel&eacute; POJO pour Plain Old Java 
            Object) et une table de la base de donn&eacute;es (voire plusieurs tables).
            Nous reviendrons bient&ocirc;t sur ce fichier. Commen&ccedil;ons par &eacute;crire la classe
            java (ou POJO) et d&eacute;clarons les m&eacute;tadonn&eacute;es de mapping pour celle-ci.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-persistentclass"></a>1.2.&nbsp;La premi&egrave;re classe persistante</h2></div></div><div></div></div><p>
            Hibernate fonctionne au mieux dans un mod&egrave;le de programmation 
            consistant &agrave; utiliser de Bon Vieux Objets Java (Plain Old Java Objects - 
            POJO) pour les classes persistantes (NdT: on parle de POJO en comparaison 
            d'objets de type EJB ou d'objets n&eacute;cessitants d'h&eacute;riter d'une quelconque 
            classe de base). Un POJO est souvent un JavaBean dont les propri&eacute;t&eacute;s 
            de la classe sont accessibles via des getters et des setters qui encapsulent 
            la repr&eacute;sentation interne dans une interface publique :
        </p><pre class="programlisting">package net.sf.hibernate.examples.quickstart;

public class Cat {

    private String id;
    private String name;
    private char sex;
    private float weight;

    public Cat() {
    }

    public String getId() {
        return id;
    }

    private void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public char getSex() {
        return sex;
    }

    public void setSex(char sex) {
        this.sex = sex;
    }

    public float getWeight() {
        return weight;
    }

    public void setWeight(float weight) {
        this.weight = weight;
    }

}</pre><p>
            Hibernate ne restreint pas l'usage des types de propri&eacute;t&eacute;s ; tous les
            types du JDK et les types primitifs (comme <tt class="literal">String</tt>,
            <tt class="literal">char</tt> et <tt class="literal">Date</tt>) peuvent &ecirc;tre mapp&eacute;s,
            ceci inclus les classes du framework de collection de Java. Vous pouvez
            les mapper en tant que valeurs, collections de valeurs ou comme associations
            avec les autres entit&eacute;s. <tt class="literal">id</tt> est une propri&eacute;t&eacute; sp&eacute;ciale
            qui repr&eacute;sente l'identifiant dans la base de donn&eacute;es pour cette classe
            (appel&eacute; aussi cl&eacute; primaire). Cet identifiant est chaudement recommand&eacute;
            pour les entit&eacute;s comme <tt class="literal">Cat</tt> : Hibernate peut utiliser
            les identifiants pour son seul fonctionnement interne (non visible de 
            l'application) mais vous perdriez en flexibilit&eacute; dans l'architecture de
            votre application.
        </p><p>
            Les classes persistantes n'ont besoin d'impl&eacute;menter aucune interface
            particuli&egrave;re et n'ont pas besoin d'h&eacute;riter d'une quelconque classe 
            de base. Hibernate n'utilise &eacute;galement aucun m&eacute;canisme de
            manipulation des classes &agrave; la construction, tel que la manipulation du
            byte-code ; il s'appuie uniquement sur le m&eacute;canisme de r&eacute;flexion de Java
            et sur l'extension des classes &agrave; l'ex&eacute;cution (via CGLIB). On peut donc,
            sans la moindre d&eacute;pendance entre les classes POJO et Hibernate, les
            mapper &agrave; une table de la base de donn&eacute;es.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-mapping"></a>1.3.&nbsp;Mapper le Chat</h2></div></div><div></div></div><p>
            Le fichier de mapping <tt class="literal">Cat.hbm.xml</tt> contient les 
	    m&eacute;tadonn&eacute;es requises pour le mapping objet/relationnel. Les m&eacute;tadonn&eacute;es
	    contiennent la d&eacute;claration des classes persistantes et le mapping entre
	    les propri&eacute;t&eacute;s (les colonnes, les relations de type cl&eacute; &eacute;trang&egrave;re vers les
	    autres entit&eacute;s) et les tables de la base de donn&eacute;es.
        </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping
    PUBLIC "-//Hibernate/Hibernate Mapping DTD//EN"
    "http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd"&gt;

&lt;hibernate-mapping&gt;

    &lt;class name="net.sf.hibernate.examples.quickstart.Cat" table="CAT"&gt;

        &lt;!-- Une cha&icirc;ne de 32 caract&egrave;res hexad&eacute;cimaux est notre
	    cl&eacute; technique. Elle est g&eacute;n&eacute;r&eacute;e automatiquement par 
	    Hibernate en utilisant le pattern UUID. --&gt;
        &lt;id name="id" type="string" unsaved-value="null" &gt;
            &lt;column name="CAT_ID" sql-type="char(32)" not-null="true"/&gt;
            &lt;generator class="uuid.hex"/&gt;
        &lt;/id&gt;

        &lt;!-- Un chat poss&egrave;de un nom mais qui ne doit pas &ecirc;tre trop
	     long. --&gt;
        &lt;property name="name"&gt;
            &lt;column name="NAME" length="16" not-null="true"/&gt;
        &lt;/property&gt;

        &lt;property name="sex"/&gt;

        &lt;property name="weight"/&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            Toute classe persistante doit avoir un identifiant (en fait, uniquement les
            classes repr&eacute;sentant des entit&eacute;s, pas les valeurs d&eacute;pendant d'objets, qui sont
            mapp&eacute;es en tant que composant d'une entit&eacute;). Cette propri&eacute;t&eacute; est utilis&eacute;e pour
            distinguer les objets persistants : deux chats sont &eacute;gaux si l'expression
            <tt class="literal">catA.getId().equals(catB.getId())</tt> est vraie, ce concept est 
            appel&eacute; <span class="emphasis"><em>identit&eacute; de base de donn&eacute;es</em></span>. Hibernate fournit en
            standard un certain nombre de g&eacute;n&eacute;rateurs d'identifiants qui couvrent la plupart
            des sc&eacute;narii (notamment les g&eacute;n&eacute;rateurs natifs pour les s&eacute;quences de base de donn&eacute;es,
            les tables d'identifiants hi/lo, et les identifiants assign&eacute;s par l'application).
            Nous utilisons le g&eacute;n&eacute;rateur UUID (recommand&eacute; uniquement pour les tests dans la
            mesure o&ugrave; les cl&eacute;s techniques g&eacute;n&eacute;r&eacute;es par la base de donn&eacute;es doivent &ecirc;tre privil&eacute;gi&eacute;es).
            et d&eacute;clarons que la colonne <tt class="literal">CAT_ID</tt> de la table <tt class="literal">CAT</tt>
            contient la valeur de l'identifiant g&eacute;n&eacute;r&eacute; par Hibernate (en tant que cl&eacute; 
            primaire de la table).
        </p><p>
            Toutes les propri&eacute;t&eacute;s de <tt class="literal">Cat</tt> sont mapp&eacute;es &agrave; la m&ecirc;me table. La
            propri&eacute;t&eacute; <tt class="literal">name</tt> est mapp&eacute;e utilisant une d&eacute;claration explicite
            de la colonne de base de donn&eacute;es. C'est particuli&egrave;rement utile dans le cas o&ugrave; le
            sch&eacute;ma de la base de donn&eacute;es est g&eacute;n&eacute;r&eacute; automatiquement (en tant qu'ordre SQL - DDL)
            par l'outil d'Hibernate <span class="emphasis"><em>SchemaExport</em></span> &agrave; partir des d&eacute;clarations
            du mapping. Toutes les autres propri&eacute;t&eacute;s prennent la valeur par d&eacute;faut donn&eacute;e par
            Hibernate ; ce qui, dans la majorit&eacute; des cas, est ce que l'on souhaite. La table
            <tt class="literal">CAT</tt> dans la base de donn&eacute;es sera :
        </p><pre class="programlisting"> Colonne |         Type          | Modificateurs
---------+-----------------------+---------------
 cat_id  | character(32)         | not null
 name    | character varying(16) | not null
 sex     | character(1)          |
 weight  | real                  |
Indexes : cat_pkey primary key btree (cat_id)</pre><p>
            Vous devez maintenant cr&eacute;er manuellement cette table dans votre base de donn&eacute;es,
            plus tard, vous pourrez vous r&eacute;f&eacute;rer &agrave; <a href="#toolsetguide" title="Chapitre&nbsp;15.&nbsp;Guide des outils">Chapitre&nbsp;15, <i>Guide des outils</i></a> si vous d&eacute;sirez
            automatiser cette &eacute;tape avec l'outil SchemaExport. Cet outil cr&eacute;e un fichier de
            type DDL SQL qui contient la d&eacute;finition de la table, les contraintes de type
            des colonnes, les contraintes d'unicit&eacute; et les index.
    	</p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-playingwithcats"></a>1.4.&nbsp;Jouer avec les chats</h2></div></div><div></div></div><p>
            Nous sommes maintenant pr&ecirc;ts &agrave; utiliser la <tt class="literal">Session</tt> Hibernate.
            C'est l'interface du <span class="emphasis"><em>gestionnaire de persistance</em></span>, on
            l'utilise pour sauver et r&eacute;cup&eacute;rer les <tt class="literal">Cat</tt>s respectivement
            dans et &agrave; partir de la base de donn&eacute;es. Mais d'abord, nous devons r&eacute;cup&eacute;rer une
            <tt class="literal">Session</tt> (l'unit&eacute; de travail Hibernate) &agrave; partir de la 
            <tt class="literal">SessionFactory</tt> :
        </p><pre class="programlisting">SessionFactory sessionFactory =
            new Configuration().configure().buildSessionFactory();</pre><p>
            Une <tt class="literal">SessionFactory</tt> est responsable d'une base de donn&eacute;es
            et n'accepte qu'un seul fichier de configuration XML 
            (<tt class="literal">hibernate.cfg.xml</tt>). Vous pouver positionner les autres
            propri&eacute;t&eacute;s (voire m&ecirc;me changer le m&eacute;ta-mod&egrave;le du mapping) en utilisant
            <tt class="literal">Configuration</tt> <span class="emphasis"><em>avant</em></span>
			de construire la <tt class="literal">SessionFactory</tt> (elle est immuable).
            Comment cr&eacute;er la  <tt class="literal">SessionFactory</tt> et comment y acc&eacute;der dans
            notre application ?
        </p><p>
            En g&eacute;n&eacute;ral, une <tt class="literal">SessionFactory</tt> n'est construite
            qu'une seule fois, c'est-&agrave;-dire au d&eacute;marrage (avec une servlet de
            type <span class="emphasis"><em>load-on-startup</em></span>). Cela veut donc dire que
            l'on ne doit pas la garder dans une variable d'instance des servlets,
            mais plut&ocirc;t ailleurs. Il faut un support de type <span class="emphasis"><em>Singleton</em></span>
            pour pouvoir y acc&eacute;der facilement. L'approche montr&eacute;e ci-dessous r&eacute;sout 
            les deux probl&egrave;mes : celui de configuration et celui de la facilit&eacute; 
            d'acc&egrave;s &agrave; <tt class="literal">SessionFactory</tt>.
		</p><p>
            Nous impl&eacute;mentons <tt class="literal">HibernateUtil</tt>, une classe utilitaire
		</p><pre class="programlisting">import net.sf.hibernate.*;
import net.sf.hibernate.cfg.*;

public class HibernateUtil {

    private static final SessionFactory sessionFactory;

    static {
        try {
            // Cr&eacute;e la SessionFactory
            sessionFactory = new Configuration().configure().buildSessionFactory();
        } catch (HibernateException ex) {
            throw new RuntimeException("Probl&egrave;me de configuration : " + ex.getMessage(), ex);
        }
    }

    public static final ThreadLocal session = new ThreadLocal();

    public static Session currentSession() throws HibernateException {
        Session s = (Session) session.get();
        // Ouvre une nouvelle Session, si ce Thread n'en a aucune
        if (s == null) {
            s = sessionFactory.openSession();
            session.set(s);
        }
        return s;
    }

    public static void closeSession() throws HibernateException {
        Session s = (Session) session.get();
        session.set(null);
        if (s != null)
            s.close();
    }
}</pre><p>
            Non seulement cette classe s'occupe de garder <tt class="literal">SessionFactory</tt>
            dans un de ses attributs statiques, mais en plus elle garde la 
            <tt class="literal">Session</tt> du thread courant dans une variable de type
            <tt class="literal">ThreadLocal</tt>. Vous devez bien comprendre le concept Java
            de variable de type tread-local (locale &agrave; un thread) avant d'utiliser cette 
            classe utilitaire.
		</p><p>
            Une <tt class="literal">SessionFactory</tt> est threadsafe : beaucoup de threads peuvent
            y acc&eacute;der de mani&egrave;re concurrente et demander une <tt class="literal">Session</tt>.
            Une <tt class="literal">Session</tt> est un objet non threadsafe qui repr&eacute;sente
            une unit&eacute; de travail avec la base de donn&eacute;es. Les <tt class="literal">Session</tt>s
            sont ouvertes par la <tt class="literal">SessionFactory</tt> et sont ferm&eacute;es quand
            le travail est termin&eacute; :
        </p><pre class="programlisting">Session session = HibernateUtil.currentSession();

Transaction tx= session.beginTransaction();

Cat princess = new Cat();
princess.setName("Princess");
princess.setSex('F');
princess.setWeight(7.4f);

session.save(princess);
tx.commit();

HibernateUtil.closeSession();</pre><p>
            Dans une <tt class="literal">Session</tt>, chaque op&eacute;ration sur la base de donn&eacute;es
            se fait dans une transaction qui isole les op&eacute;rations de la base de donn&eacute;es
            (c'est &eacute;galement le cas pour les lectures seules). Nous utilisons l'API
            <tt class="literal">Transaction</tt> pour s'abstraire de la strat&eacute;gie transactionnelle
            utilis&eacute;e (dans notre cas, les transactions JDBC). Cela permet d'avoir un code
            portable et d&eacute;ployable sans le moindre changement dans un environnement 
            transactionnel g&eacute;r&eacute; par le conteneur - CMT - (JTA est utilis&eacute; dans ce cas).
            Il est &agrave; noter que l'exemple ci-dessus ne g&egrave;re pas les exceptions.
        </p><p>
            Notez &eacute;galement que vous pouvez appeler <tt class="literal">HibernateUtil.currentSession();</tt>
            autant de fois que vous voulez, cette m&eacute;thode vous ram&egrave;nera toujours la 
            <tt class="literal">Session</tt> courante pour ce thread. Vous devez vous assurer que
            la <tt class="literal">Session</tt> est ferm&eacute;e apr&egrave;s la fin de votre unit&eacute; de travail
            et avant que la r&eacute;ponse HTTP soit envoy&eacute;e. Cela peut &ecirc;tre par exemple dans le code 
            de votre servlet ou dans un filtre de servlet. L'effet de bord int&eacute;ressant de la
            seconde solution est l'initialisation tardive : la <tt class="literal">Session</tt>
            est encore ouverte lorsque la vue est construite. Hibernate peut donc charger,
            lors de votre navigation dans le graphe, les objets qui n'&eacute;taient pas initialis&eacute;s.
        </p><p>
            Hibernate poss&egrave;de diff&eacute;rentes m&eacute;thodes de r&eacute;cup&eacute;ration des objets &agrave; partir de  
            la base de donn&eacute;es. La plus flexible est d'utiliser le langage de 
            requ&ecirc;tage d'Hibernate (HQL comme Hibernate Query Language). Ce langage
            puissant et facile &agrave; comprendre est une extension orient&eacute;e objet du SQL:
        </p><pre class="programlisting">Transaction tx = session.beginTransaction();

Query query = session.createQuery("select c from Cat as c where c.sex = :sex");
query.setCharacter("sex", 'F');
for (Iterator it = query.iterate(); it.hasNext();) {
    Cat cat = (Cat) it.next();
    out.println("Chat femelle : " + cat.getName() );
}

tx.commit();</pre><p>
            Hibernate offre &eacute;galement une API orient&eacute;e objet de <span class="emphasis"><em>requ&ecirc;tage par 
            crit&egrave;res</em></span> qui peut &ecirc;tre utilis&eacute;e pour formuler des requ&ecirc;tes typ&eacute;es.
            Bien s&ucirc;r, Hibernate utilise des <tt class="literal">PreparedStatement</tt>s et les
            param&egrave;tres associ&eacute;s pour toutes ses communications SQL avec la base
            de donn&eacute;es. Vous pouvez &eacute;galement utiliser la fonctionalit&eacute; de requ&ecirc;tage
            SQL natif d'Hibernate ou, dans de rares occasions, r&eacute;cup&eacute;rer un connexion
            JDBC &agrave; partir de la <tt class="literal">Session</tt>.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-summary"></a>1.5.&nbsp;Conclusion</h2></div></div><div></div></div><p>
            Nous n'avons fait que gratter la surface d'Hibernate dans ce petit tutoriel.
            Notez que nous n'avons pas inclus de code sp&eacute;cifique aux servlets dans notre
            exemple. Vous devez cr&eacute;er vous-m&ecirc;me une servlet et y ins&eacute;rer le code Hibernate
            qui convient.
        </p><p>
            Garder &agrave; l'esprit qu'Hibernate, en tant que couche d'acc&egrave;s aux donn&eacute;es, est
            fortement int&eacute;gr&eacute; &agrave; votre application. En g&eacute;n&eacute;ral, toutes les autres couches
            d&eacute;pendent du m&eacute;canisme de persistance quel qu'il soit. Soyez s&ucirc;r de comprendre les implications
            de ce design.
        </p></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="architecture"></a>Chapitre&nbsp;2.&nbsp;Architecture</h2></div></div><div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-overview"></a>2.1.&nbsp;G&eacute;n&eacute;ralit&eacute;s</h2></div></div><div></div></div><p>
            Voici une vue (tr&egrave;s) haut niveau de l'architecture d'Hibernate :
        </p><div class="mediaobject" align="center"><img src="../shared/images/overview.gif" align="middle"></div><p>
            Ce diagramme montre Hibernate utilisant une base de donn&eacute;es et des donn&eacute;es
            de configuration pour fournir un service de persistance (et des objets
            persistants) &agrave; l'application.
        </p><p>
            Nous aimerions d&eacute;crire une vue plus d&eacute;taill&eacute;e de l'architecture. Malheureusement,
            Hibernate est flexible et supporte diff&eacute;rentes approches. Nous allons en
            montrer les deux extr&ecirc;mes. L'architecture l&eacute;g&egrave;re laisse l'application fournir
            ses propres connexions JDBC et g&eacute;rer ses propres transactions. Cette approche
            utilise le minimum des APIs Hibernate.:
        </p><div class="mediaobject" align="center"><img src="../shared/images/lite.gif" align="middle"></div><p>
            L'architecture la plus compl&egrave;te abstrait l'application des APIs JDBC/JTA 
            sous-jacentes et laisse Hibernate s'occuper des d&eacute;tails.
        </p><div class="mediaobject" align="center"><img src="../shared/images/full_cream.gif" align="middle"></div><p>
            Voici quelques d&eacute;finitions des objets des diagrammes :

            </p><div class="variablelist"><dl><dt><span class="term">SessionFactory (<tt class="literal">net.sf.hibernate.SessionFactory</tt>)</span></dt><dd><p>
                            Un cache threadsafe (immuable) des mappings vers une (et une seule) base 
                            de donn&eacute;es. Une factory (fabrique) de <tt class="literal">Session</tt> et un client
                            de <tt class="literal">ConnectionProvider</tt>. Peut contenir un cache optionnel de
                            donn&eacute;es (de second niveau) qui est r&eacute;utilisable entre les diff&eacute;rentes transactions
                            que cela soit au niveau processus ou au niveau cluster.
                        </p></dd><dt><span class="term">Session (<tt class="literal">net.sf.hibernate.Session</tt>)</span></dt><dd><p>
                            Un objet mono-thread&eacute;, &agrave; dur&eacute;e de vie courte, qui repr&eacute;sente une conversation
                            entre l'application et l'entrep&ocirc;t de persistance. Encapsule une connexion JDBC.
                            Factory (fabrique) des objets <tt class="literal">Transaction</tt>. Contient un cache
                            (de premier niveau) des objets persistants, ce cache est obligatoire. Il est 
                            utilis&eacute; lors de la navigation dans le graphe d'objets ou lors de la r&eacute;cup&eacute;ration
                            d'objets par leur identifiant.
                        </p></dd><dt><span class="term">Objets et Collections persistants</span></dt><dd><p>
                            Objets mono-thread&eacute;s &agrave; vie courte contenant l'&eacute;tat de persistance
                            et la fonction m&eacute;tier. Ceux-ci sont en g&eacute;n&eacute;ral les objets de type JavaBean
                            (ou POJOs) ; la seule particularit&eacute; est qu'ils sont associ&eacute;s avec une (et
                            une seule) <tt class="literal">Session</tt>. D&egrave;s que la <tt class="literal">Session</tt>
                            est ferm&eacute;e, ils seront d&eacute;tach&eacute;s et libre d'&ecirc;tre utilis&eacute;s par n'importe laquelle
                            des couches de l'application (ie. de et vers la pr&eacute;sentation en tant que Data 
                            Transfer Objects - DTO : objet de transfert de donn&eacute;es).
                        </p></dd><dt><span class="term">Objets et collections transients</span></dt><dd><p>
                            Instances de classes persistantes qui ne sont actuellement pas associ&eacute;es &agrave;
                            une <tt class="literal">Session</tt>. Elles ont pu &ecirc;tre instanci&eacute;es par l'application
                            et ne pas avoir (encore) &eacute;t&eacute; persist&eacute;es ou elle ont pu &ecirc;tre instanci&eacute;es par
                            une <tt class="literal">Session</tt> ferm&eacute;e.
                        </p></dd><dt><span class="term">Transaction (<tt class="literal">net.sf.hibernate.Transaction</tt>)</span></dt><dd><p>
                            (Optionnel) Un objet mono-thread&eacute; &agrave; vie courte utilis&eacute; par l'application
                            pour d&eacute;finir une unit&eacute; de travail atomique. Abstrait l'application des
                            transactions sous-jacentes qu'elles soient JDBC, JTA ou CORBA. Une
                            <tt class="literal">Session</tt> peut fournir plusieurs <tt class="literal">Transaction</tt>s
                            dans certain cas.
                        </p></dd><dt><span class="term">ConnectionProvider (<tt class="literal">net.sf.hibernate.connection.ConnectionProvider</tt>)</span></dt><dd><p>
                            (Optionnel) Une fabrique de (pool de) connexions JDBC. Abstrait l'application
                            de la <tt class="literal">Datasource</tt> ou du <tt class="literal">DriverManager</tt> sous-jacent.
                            Non expos&eacute; &agrave; l'application, mais peut &ecirc;tre &eacute;tendu/impl&eacute;ment&eacute; par le d&eacute;veloppeur.
                        </p></dd><dt><span class="term">TransactionFactory (<tt class="literal">net.sf.hibernate.TransactionFactory</tt>)</span></dt><dd><p>
                            (Optionnel) Une fabrique d'instances de <tt class="literal">Transaction</tt>. Non
                            expos&eacute; &agrave; l'application, mais peut &ecirc;tre &eacute;tendu/impl&eacute;ment&eacute; par le d&eacute;veloppeur.
                        </p></dd></dl></div><p>
        </p><p>
            Dans une architecture l&eacute;g&egrave;re, l'application n'utilisera pas les APIs
            <tt class="literal">Transaction</tt>/<tt class="literal">TransactionFactory</tt>
            et/ou n'utilisera pas les APIs <tt class="literal">ConnectionProvider</tt>
            pour utiliser JTA ou JDBC.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-jmx"></a>2.2.&nbsp;Integration JMX</h2></div></div><div></div></div><p>
            JMX est le standard J2EE du configuration des composants Java. Hibernate peut &ecirc;tre configur&eacute;
            via une MBean standard. Mais dans la mesure o&ugrave; la plupart des serveurs d'application ne
            supportent pas encore JMX, Hibernate fournit quelques m&eacute;canismes de configuration "non-standard".
        </p><p>
            Merci de vous r&eacute;f&eacute;rer au site web d'Hibernate pour de plus amples d&eacute;tails sur la fa&ccedil;on
            de configurer Hibernate et le faire tourner en tant que composant JMX dans JBoss.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-jca"></a>2.3.&nbsp;Support JCA</h2></div></div><div></div></div><p>
            Hibernate peut aussi &ecirc;tre configur&eacute; en tant que connecteur JCA. R&eacute;f&eacute;rez-vous au site
            web pour de plus amples d&eacute;tails.
        </p></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="session-configuration"></a>Chapitre&nbsp;3.&nbsp;Configuration de la SessionFactory</h2></div></div><div></div></div><p>
        Parce qu'Hibernate est con&ccedil;u pour fonctionner dans diff&eacute;rents environnements,
        il existe beaucoup de param&egrave;tres de configuration. Heureusement, la plupart
        ont des valeurs par d&eacute;faut appropri&eacute;es et la distribution d'Hibernate contient
        un exemple de fichier <tt class="literal">hibernate.properties</tt> qui montre
        les diff&eacute;rentes options. G&eacute;n&eacute;ralement, vous n'avez qu'&agrave; placer ce fichier dans
        votre classpath et &agrave; l'adapter.
    </p><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-programmatic"></a>3.1.&nbsp;Configuration par programmation</h2></div></div><div></div></div><p>
            Une instance de <tt class="literal">net.sf.hibernate.cfg.Configuration</tt>
            repr&eacute;sente un ensemble de mappings des classes Java d'une application vers
            la base de donn&eacute;es SQL. La <tt class="literal">Configuration</tt> est utilis&eacute;e
            pour construire un objet (immuable) <tt class="literal">SessionFactory</tt>.
            Les mappings sont constitu&eacute;s d'un ensemble de fichiers de mapping XML.
        </p><p>
            Vous pouvez obtenir une instance de <tt class="literal">Configuration</tt>
            en l'instanciant directement. Voici un exemple de configuration d'une
            source de donn&eacute;es et d'un mapping compos&eacute; de deux fichiers de configuration
            XML (qui se trouvent dans le classpath) :
        </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addFile("Item.hbm.xml")
    .addFile("Bid.hbm.xml");</pre><p>
            Une alternative (parfois meilleure) est de laisser Hibernate charger le fichier
            de mapping en utilisant <tt class="literal">getResourceAsStream()</tt> :
        </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class);</pre><p>
            Hibernate va rechercher les fichiers de mappings 
            <tt class="literal">/org/hibernate/auction/Item.hbm.xml</tt> et
            <tt class="literal">/org/hibernate/auction/Bid.hbm.xml</tt> dans le classpath.
            Cette approche &eacute;limine les noms de fichiers en dur.
        </p><p>
            Une <tt class="literal">Configuration</tt> permet &eacute;galement plusieurs valeurs optionnelles :
        </p><pre class="programlisting">Properties props = new Properties();
...
Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class)
    .setProperties(props);</pre><p>
            Une <tt class="literal">Configuration</tt> est sens&eacute;e &ecirc;tre un objet n&eacute;cessaire pendant la 
            phase de configuration et &ecirc;tre lib&eacute;r&eacute;e une fois la <tt class="literal">SessionFactory</tt> construite.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-sessionfactory"></a>3.2.&nbsp;Obtenir une SessionFactory</h2></div></div><div></div></div><p>
            Quand tous les mappings ont &eacute;t&eacute; pars&eacute;s par la <tt class="literal">Configuration</tt>, l'application
            doit obtenir une fabrique d'instances de <tt class="literal">Session</tt>. Cette fabrique est suppos&eacute;e
            &ecirc;tre partag&eacute;e par tous les threads de l'application :
        </p><pre class="programlisting">SessionFactory sessions = cfg.buildSessionFactory();</pre><p>
            Cependant, Hibernate permet &agrave; votre application d'instancier plus d'une <tt class="literal">SessionFactory</tt>.
            C'est utile si vous utilisez plus d'une base de donn&eacute;es.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-userjdbc"></a>3.3.&nbsp;Connexion JDBC fournie par l'utilisateur</h2></div></div><div></div></div><p>
            Une <tt class="literal">SessionFactory</tt> peut ouvrir une <tt class="literal">Session</tt>
            en utilisant une connexion JDBC fournie par l'utilisateur. Ce choix de design
            permet &agrave; l'application d'obtenir les connexions JDBC de la fa&ccedil;on qu'il lui plait :
        </p><pre class="programlisting">java.sql.Connection conn = datasource.getConnection();
Session session = sessions.openSession(conn);

// do some data access work</pre><p>
            L'application doit faire attention &agrave; ne pas ouvrir deux
            <tt class="literal">Session</tt>s concurrentes en utilisant la 
            m&ecirc;me connexion !
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-hibernatejdbc"></a>3.4.&nbsp;Connexions JDBC fournie par Hibernate</h2></div></div><div></div></div><p>
            Alternativement, vous pouvez laisser la <tt class="literal">SessionFactory</tt>
            ouvrir les connexions pour vous. La <tt class="literal">SessionFactory</tt>
            doit recevoir les propri&eacute;t&eacute;s de connexions JDBC de l'une des mani&egrave;res
            suivantes :
        </p><div class="orderedlist"><ol type="1" compact><li><p>
                    Passer une instance de <tt class="literal">java.util.Properties</tt>
                    &agrave; <tt class="literal">Configuration.setProperties()</tt>.
                </p></li><li><p>
                    Placer <tt class="literal">hibernate.properties</tt> dans un r&eacute;pertoire racine
                    du classpath
                </p></li><li><p>
                    Positionner les propri&eacute;t&eacute;s <tt class="literal">System</tt> en utilisant
                    <tt class="literal">java -Dproperty=value</tt>.
                </p></li><li><p>
                    Inclure des &eacute;l&eacute;ments <tt class="literal">&lt;property&gt;</tt> dans le
                    fichier <tt class="literal">hibernate.cfg.xml</tt> (voir plus loin).
                </p></li></ol></div><p>
            Si vous suivez cette approche, ouvrir une <tt class="literal">Session</tt> est aussi simple que :
        </p><pre class="programlisting">Session session = sessions.openSession(); // ouvre une nouvelle session
// faire quelques acc&egrave;s aux donn&eacute;es, une connexion JDBC sera utilis&eacute;e &agrave; la demande</pre><p>
            Tous les noms et s&eacute;mantiques des propri&eacute;t&eacute;s d'Hibernate sont d&eacute;finies dans la javadoc
            de la classe <tt class="literal">net.sf.hibernate.cfg.Environment</tt>. Nous allons d&eacute;crire
            les param&egrave;tres les plus importants pour une connexion JDBC.
        </p><p>
            Hibernate obtiendra des connexions (et les mettra dans un pool) en utilisant 
            <tt class="literal">java.sql.DriverManager</tt> si vous positionner les param&egrave;tres de la mani&egrave;re
            suivante :
        </p><div class="table"><a name="d0e764"></a><p class="title"><b>Tableau&nbsp;3.1.&nbsp;Propri&eacute;t&eacute;s JDBC d'Hibernate</b></p><table summary="Propri&eacute;t&eacute;s JDBC d'Hibernate" border="1"><colgroup><col><col></colgroup><thead><tr><th>Nom de la propri&eacute;t&eacute;</th><th>Fonction</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.connection.driver_class</tt></td><td><span class="emphasis"><em>Classe du driver jdbc</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.url</tt></td><td><span class="emphasis"><em>URL jdbc</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.username</tt></td><td><span class="emphasis"><em>utilisateur de la base de donn&eacute;es</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.password</tt></td><td><span class="emphasis"><em>mot de passe de la base de donn&eacute;es</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.pool_size</tt></td><td><span class="emphasis"><em>nombre maximum de connexions dans le pool</em></span></td></tr></tbody></table></div><p>
            L'algorithme natif de pool de connexions d'Hibernate est plut&ocirc;t rudimentaire. Il a &eacute;t&eacute; fait 
            dans le but de vous aider &agrave; d&eacute;marrer et <span class="emphasis"><em>n'est pas pr&eacute;vu pour un syst&egrave;me en production</em></span>
            ou m&ecirc;me pour un test de peformance. Utiliser un pool tiers pour de meilleures performances et une
            meilleure stabilit&eacute; : remplacer la propri&eacute;t&eacute; <tt class="literal">hibernate.connection.pool_size</tt> avec les propri&eacute;t&eacute;s
            sp&eacute;cifique au pool de connexions que vous avez choisi.
        </p><p>
            C3P0 est un pool de connexions JDBC open source distribu&eacute; avec Hibernate dans le r&eacute;pertoire
            <tt class="literal">lib</tt>. Hibernate utilisera le provider int&eacute;gr&eacute; <tt class="literal">C3P0ConnectionProvider</tt>
            pour le pool de connexions si vous positionnez les propri&eacute;t&eacute;s <tt class="literal">hibernate.c3p0.*</tt>.
            Il y a &eacute;galement un support int&eacute;gr&eacute; pour Apache DBCP et Proxool. Vous devez
            positionner les propri&eacute;t&eacute;s <tt class="literal">hibernate.dbcp.*</tt> (propri&eacute;t&eacute;s du pool de connexions
            DBCP) pour activer le <tt class="literal">DBCPConnectionProvider</tt>. Le cache des Prepared Statement
            est activ&eacute; (fortement recommand&eacute;) si <tt class="literal">hibernate.dbcp.ps.*</tt> (propri&eacute;t&eacute;s du cache 
            de statement de DBCP) sont positionn&eacute;es. Merci de vous r&eacute;f&eacute;rer &agrave; la documentation de apache commons-pool
            pour l'utilisation et la compr&eacute;hension de ces propri&eacute;t&eacute;s. Vous devez positionner les propri&eacute;t&eacute;s 
            <tt class="literal">hibernate.proxool.*</tt> si vous voulez utiliser Proxool.
        </p><p>
            Voici un exemple utilisant C3P0:
        </p><a name="c3p0-configuration"></a><pre class="programlisting">hibernate.connection.driver_class = org.postgresql.Driver
hibernate.connection.url = jdbc:postgresql://localhost/mydatabase
hibernate.connection.username = myuser
hibernate.connection.password = secret
hibernate.c3p0.min_size=5
hibernate.c3p0.max_size=20
hibernate.c3p0.timeout=1800
hibernate.c3p0.max_statement=50
hibernate.dialect = net.sf.hibernate.dialect.PostgreSQLDialect</pre><p>
            Dans le cadre de l'utilisation au sein d'un serveur d'applications, Hibernate 
            peut obtenir les connexions &agrave; partir d'une <tt class="literal">javax.sql.Datasource</tt>
            enregistr&eacute;e dans le JNDI. Positionner les propri&eacute;t&eacute;s suivantes :
        </p><div class="table"><a name="d0e852"></a><p class="title"><b>Tableau&nbsp;3.2.&nbsp;Propri&eacute;t&eacute; d'une Datasource Hibernate</b></p><table summary="Propri&eacute;t&eacute; d'une Datasource Hibernate" border="1"><colgroup><col><col></colgroup><thead><tr><th>Nom d'une propri&eacute;t&eacute;</th><th>fonction</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.connection.datasource</tt></td><td><span class="emphasis"><em>Nom JNDI de la datasource</em></span></td></tr><tr><td><tt class="literal">hibernate.jndi.url</tt></td><td><span class="emphasis"><em>URL du fournisseur JNDI</em></span> (optionnelle)
                </td></tr><tr><td><tt class="literal">hibernate.jndi.class</tt></td><td><span class="emphasis"><em>Classe de l'<tt class="literal">InitialContextFactory</tt> du JNDI</em></span> (optionnelle)
                </td></tr><tr><td><tt class="literal">hibernate.connection.username</tt></td><td><span class="emphasis"><em>utilisateur de la base de donn&eacute;es</em></span> (optionnelle)
                </td></tr><tr><td><tt class="literal">hibernate.connection.password</tt></td><td><span class="emphasis"><em>mot de passe de la base de donn&eacute;es</em></span> (optionnelle)
                </td></tr></tbody></table></div><p>
            voici un exemple utilisant les datasources JNDI fournies par un serveur d'applications :
        </p><pre class="programlisting">hibernate.connection.datasource = java:/comp/env/jdbc/MyDB
hibernate.transaction.factory_class = \
    net.sf.hibernate.transaction.JTATransactionFactory
hibernate.transaction.manager_lookup_class = \
    net.sf.hibernate.transaction.JBossTransactionManagerLookup
hibernate.dialect = \
    net.sf.hibernate.dialect.PostgreSQLDialect</pre><p>
            Les connexions JDBC obtenues &agrave; partir d'une datasource JNDI participeront automatiquement
            aux transactions g&eacute;r&eacute;es par le conteneur du serveur d'applications.
        </p><p>
            Des propri&eacute;t&eacute;s suppl&eacute;mentaires de connexion peuvent &ecirc;tre pass&eacute;es en pr&eacute;fixant
            le nom de la propri&eacute;t&eacute; par "<tt class="literal">hibernate.connnection</tt>". Par exemple,
            vous pouvez sp&eacute;cifier un jeu de caract&egrave;res en utilisant 
            <tt class="literal">hibernate.connnection.charSet</tt>.
        </p><p>
            Vous pouvez fournir votre propre strat&eacute;gie d'obtention des connexions JDBC en impl&eacute;mentant l'interface
            <tt class="literal">net.sf.hibernate.connection.ConnectionProvider</tt>. Vous pouvez s&eacute;lectionner
            une impl&eacute;mentation sp&eacute;cifique en positionnant <tt class="literal">hibernate.connection.provider_class</tt>.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-optional"></a>3.5.&nbsp;Propri&eacute;t&eacute;s de configuration optionnelles</h2></div></div><div></div></div><p>
            Il y a un certain nombre d'autres propri&eacute;t&eacute;s qui contr&ocirc;lent le fonctionnement 
            d'Hibernate &agrave; l'ex&eacute;cution. Toutes sont optionnelles et ont comme valeurs par d&eacute;faut
            des valeurs "raisonnables" pour un fonctionnement nominal.
        </p><p>
            Les propri&eacute;t&eacute;s de niveau System ne peuvent &ecirc;tre positionn&eacute;es que via la ligne de commande
            (<tt class="literal">java -Dproperty=value</tt>) ou &ecirc;tre d&eacute;finies dans <tt class="literal">hibernate.properties</tt>.
            Elle ne peuvent l'&ecirc;tre dans une instance de <tt class="literal">Properties</tt> pass&eacute;e &agrave; la 
            <tt class="literal">Configuration</tt>.
        </p><div class="table"><a name="configuration-optional-properties"></a><p class="title"><b>Tableau&nbsp;3.3.&nbsp;Propri&eacute;t&eacute;s de configuration d'Hibernate</b></p><table summary="Propri&eacute;t&eacute;s de configuration d'Hibernate" border="1"><colgroup><col><col></colgroup><thead><tr><th>Nom de la propri&eacute;t&eacute;</th><th>Fonction</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.dialect</tt></td><td>
                            Le nom de la classe du <tt class="literal">Dialect</tt> Hibernate - active
                            l'utilisation de certaines fonctionalit&eacute;s sp&eacute;cifiques &agrave; la plateforme.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">nom.complet.de.ma.classe.de.Dialect</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.default_schema</tt></td><td>
                            Positionne dans le SQL g&eacute;n&eacute;r&eacute; un sch&eacute;ma/tablespace par d&eacute;faut pour les noms de
                            table ne l'ayant pas surcharg&eacute;.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">MON_SCHEMA</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.session_factory_name</tt></td><td>
                            La <tt class="literal">SessionFactory</tt> sera automatiquement
                            li&eacute;e &agrave; ce nom dans le JNDI apr&egrave;s sa cr&eacute;ation.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">jndi/nom/hierarchique</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.use_outer_join</tt></td><td>
                            Active le chargement via les jointures ouvertes. D&eacute;pr&eacute;ci&eacute;e, utiliser <tt class="literal">max_fetch_depth</tt>.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.max_fetch_depth</tt></td><td>
                            D&eacute;finit la profondeur maximale d'un arbre de chargement par
                            jointures ouvertes pour les associations &agrave; cardinalit&eacute; unitaire
                            (un-&agrave;-un, plusieurs-&agrave;-un).
                            Un <tt class="literal">0</tt> d&eacute;sactive le chargement par jointure
                            ouverte.
                            <p>
                                <span class="strong">ex.</span> 
                                valeurs recommand&eacute;es entre <tt class="literal">0</tt> et <tt class="literal">3</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.fetch_size</tt></td><td>
                            Une valeur non nulle d&eacute;termine la taille de chargement
                            des statements JDBC (appelle 
                            <tt class="literal">Statement.setFetchSize()</tt>).
                        </td></tr><tr><td><tt class="literal">hibernate.jdbc.batch_size</tt></td><td>
                            Une valeur non nulle active l'utilisation par Hibernate des mises 
                            &agrave; jour par batch de JDBC2.
                            <p>
                                <span class="strong">ex.</span> 
                                les valeurs recommand&eacute;es entre <tt class="literal">5</tt> et <tt class="literal">30</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.batch_versioned_data</tt></td><td>
                            Param&eacute;trez cette propri&eacute;t&eacute; &agrave; <tt class="literal">true</tt> si votre pilote JDBC
                            retourne des row counts corrects depuis <tt class="literal">executeBatch()</tt> (il est 
                            souvent appropri&eacute; d'activer cette option). Hibernate utilisera alors le "batched DML" pour
                            versionner automatiquement les donn&eacute;es. Par d&eacute;faut = <tt class="literal">false</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.use_scrollable_resultset</tt></td><td>
                            Active l'utilisation par Hibernate des resultsets scrollables 
                            de JDBC2. Cette propri&eacute;t&eacute; est seulement n&eacute;cessaire lorsque l'on
                            utilise une connexion JDBC fournie par l'utilisateur. Autrement,
                            Hibernate utilise les m&eacute;tadonn&eacute;es de la connexion.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.use_streams_for_binary</tt></td><td>
                            Utilise des flux lorsque l'on &eacute;crit/lit des types
                            <tt class="literal">binary</tt> ou <tt class="literal">serializable</tt>
                            vers et &agrave; partir de JDBC (propri&eacute;t&eacute; de niveau syst&egrave;me).
                            <p>
                                <span class="strong">ex.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.use_get_generated_keys</tt></td><td>
                            Active l'utilisation de <tt class="literal">PreparedStatement.getGeneratedKeys()</tt> de JDBC3
                            pour r&eacute;cup&eacute;rer nativement les cl&eacute;s g&eacute;n&eacute;r&eacute;es apr&egrave;s insertion. N&eacute;cessite un pilote
                            JDBC3+, le mettre &agrave; false si votre pilote a des probl&egrave;mes avec les g&eacute;n&eacute;rateurs
                            d'identifiant Hibernate. Par d&eacute;faut, essaie de d&eacute;terminer les possibilit&eacute;s du
                            pilote en utilisant les meta donn&eacute;es de connexion.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true|false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cglib.use_reflection_optimizer</tt></td><td>
                            Active l'utilisation de CGLIB &agrave; la place de la r&eacute;flexion &agrave; l'ex&eacute;cution
                            (Propri&eacute;t&eacute; de niveau syst&egrave;me, la valeur par d&eacute;faut &eacute;tant d'utiliser CGLIB
                            lorsque c'est possible). La r&eacute;flexion est parfois utile en cas de probl&egrave;me.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jndi.<span class="emphasis"><em>&lt;propertyName&gt;</em></span></tt></td><td>
                            Passe la propri&eacute;t&eacute; <tt class="literal">propertyName</tt> au
                            JNDI <tt class="literal">InitialContextFactory</tt>.
                        </td></tr><tr><td><tt class="literal">hibernate.connection.isolation</tt></td><td>
                        Positionne le niveau de transaction JDBC. Merci de vous r&eacute;f&eacute;rer
                        &agrave; <tt class="literal">java.sql.Connection</tt> pour le d&eacute;tail des valeurs
                        mais sachez que toutes les bases de donn&eacute;es ne supportent pas
                        tous les niveaux d'isolation.
                        <p>
                            <span class="strong">ex.</span> 
                            <tt class="literal">1, 2, 4, 8</tt>
                        </p></td></tr><tr><td><tt class="literal">hibernate.connection.<span class="emphasis"><em>&lt;propertyName&gt;</em></span></tt></td><td>
                        Passe la propri&eacute;t&eacute; JDBC <tt class="literal">propertyName</tt>
                        au <tt class="literal">DriverManager.getConnection()</tt>.
                    </td></tr><tr><td><tt class="literal">hibernate.connection.provider_class</tt></td><td>
                            Le nom de classe d'un <tt class="literal">ConnectionProvider</tt> 
                            sp&eacute;cifique.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">nom.de.classe.du.ConnectionProvider</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.provider_class</tt></td><td>
                            Le nom de classe d'un <tt class="literal">CacheProvider</tt> 
                            sp&eacute;cifique.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">nom.de.classe.du.CacheProvider</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.use_minimal_puts</tt></td><td>
                            Optimise le cache de second niveau en minimisant les &eacute;critures,
                            au prix de plus de lectures (utile pour les caches en cluster).
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">true|false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.use_query_cache</tt></td><td>
                            Activer le cache de requ&ecirc;te, les requ&ecirc;tes individuelles doivent tout
                            de m&ecirc;me &ecirc;tre d&eacute;clar&eacute;es comme mettable en cache.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">true|false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.query_cache_factory</tt></td><td>
                            Le nom de classe d'une interface <tt class="literal">QueryCache</tt> ,
                            par d&eacute;faut = built-in <tt class="literal">StandardQueryCache</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">nom.de.la.classe.de.QueryCache</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.region_prefix</tt></td><td>
                            Un pr&eacute;fixe &agrave; utiliser pour le nom des r&eacute;gions du 
                            cache de second niveau.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">prefix</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.transaction.factory_class</tt></td><td>
                            Le nom de classe d'une <tt class="literal">TransactionFactory</tt>
                            qui sera utilis&eacute;e par l'API <tt class="literal">Transaction</tt>
                            d'Hibernate (la valeur par d&eacute;faut est 
                            <tt class="literal">JDBCTransactionFactory</tt>).
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">nom.de.classe.d.une.TransactionFactory</tt>
                            </p></td></tr><tr><td><tt class="literal">jta.UserTransaction</tt></td><td>
                            Le nom JNDI utilis&eacute; par la <tt class="literal">JTATransactionFactory</tt>
                            pour obtenir la <tt class="literal">UserTransaction</tt> JTA du serveur 
                            d'applications.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">jndi/nom/compose</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.transaction.manager_lookup_class</tt></td><td>
                            Le nom de la classe du <tt class="literal">TransactionManagerLookup</tt>
                            - requis lorsque le cache de niveau JVM est activ&eacute; dans un 
                            environnement JTA.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">nom.de.classe.du.TransactionManagerLookup</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.query.substitutions</tt></td><td>
                            Lien entre les tokens de requ&ecirc;tes Hibernate et les 
                            tokens SQL (les tokens peuvent &ecirc;tre des fonctions ou des
                            noms litt&eacute;raux par exemple).
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.show_sql</tt></td><td>
                            Ecrit les ordres SQL dans la console.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.hbm2ddl.auto</tt></td><td>
                            Exporte le sch&eacute;ma DDL vers la base de donn&eacute;es automatiquement
                            lorsque la <tt class="literal">SessionFactory</tt> est cr&eacute;&eacute;e.
                            La valeur <tt class="literal">create-drop</tt> permet de supprimer 
                            le sch&eacute;ma de base de donn&eacute;es lorsque la <tt class="literal">SessionFactory</tt>
                            est ferm&eacute;e explicitement.
                            <p>
                                <span class="strong">ex.</span> 
                                <tt class="literal">update</tt> | <tt class="literal">create</tt> | <tt class="literal">create-drop</tt>
                            </p></td></tr></tbody></table></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-dialects"></a>3.5.1.&nbsp;Dialectes SQL</h3></div></div><div></div></div><p>
                Vous devriez toujours positionner la propri&eacute;t&eacute; <tt class="literal">hibernate.dialect</tt> &agrave;
                la sous-classe appropri&eacute;e &agrave; votre base de donn&eacute;es. Ce n'est pas strictement obligatoire
                &agrave; moins de vouloir utiliser la g&eacute;n&eacute;ration de cl&eacute; primaire <tt class="literal">native</tt> ou par
                <tt class="literal">sequence</tt> ou de vouloir utiliser le m&eacute;canisme de lock pessimiste (ex. via
                <tt class="literal">Session.lock()</tt> ou <tt class="literal">Query.setLockMode()</tt>). Cependant,
                si vous sp&eacute;cifiez un dialecte, Hibernate utilisera des valeurs adapt&eacute;es pour certaines autres
                propri&eacute;t&eacute;s list&eacute;es ci-dessus, vous &eacute;vitant l'effort de le faire &agrave; la main.
            </p><div class="table"><a name="sql-dialects"></a><p class="title"><b>Tableau&nbsp;3.4.&nbsp;Dialectes SQL d'Hibernate (<tt class="literal">hibernate.dialect</tt>)</b></p><table summary="Dialectes SQL d'Hibernate (hibernate.dialect)" border="1"><colgroup><col><col></colgroup><thead><tr><th>SGBD</th><th>Dialecte</th></tr></thead><tbody><tr><td>DB2</td><td><tt class="literal">net.sf.hibernate.dialect.DB2Dialect</tt></td></tr><tr><td>DB2 AS/400</td><td><tt class="literal">net.sf.hibernate.dialect.DB2400Dialect</tt></td></tr><tr><td>DB2 OS390</td><td><tt class="literal">net.sf.hibernate.dialect.DB2390Dialect</tt></td></tr><tr><td>PostgreSQL</td><td><tt class="literal">net.sf.hibernate.dialect.PostgreSQLDialect</tt></td></tr><tr><td>MySQL</td><td><tt class="literal">net.sf.hibernate.dialect.MySQLDialect</tt></td></tr><tr><td>SAP DB</td><td><tt class="literal">net.sf.hibernate.dialect.SAPDBDialect</tt></td></tr><tr><td>Oracle (toutes versions)</td><td><tt class="literal">net.sf.hibernate.dialect.OracleDialect</tt></td></tr><tr><td>Oracle 9/10g</td><td><tt class="literal">net.sf.hibernate.dialect.Oracle9Dialect</tt></td></tr><tr><td>Sybase</td><td><tt class="literal">net.sf.hibernate.dialect.SybaseDialect</tt></td></tr><tr><td>Sybase Anywhere</td><td><tt class="literal">net.sf.hibernate.dialect.SybaseAnywhereDialect</tt></td></tr><tr><td>Microsoft SQL Server</td><td><tt class="literal">net.sf.hibernate.dialect.SQLServerDialect</tt></td></tr><tr><td>SAP DB</td><td><tt class="literal">net.sf.hibernate.dialect.SAPDBDialect</tt></td></tr><tr><td>Informix</td><td><tt class="literal">net.sf.hibernate.dialect.InformixDialect</tt></td></tr><tr><td>HypersonicSQL</td><td><tt class="literal">net.sf.hibernate.dialect.HSQLDialect</tt></td></tr><tr><td>Ingres</td><td><tt class="literal">net.sf.hibernate.dialect.IngresDialect</tt></td></tr><tr><td>Progress</td><td><tt class="literal">net.sf.hibernate.dialect.ProgressDialect</tt></td></tr><tr><td>Mckoi SQL</td><td><tt class="literal">net.sf.hibernate.dialect.MckoiDialect</tt></td></tr><tr><td>Interbase</td><td><tt class="literal">net.sf.hibernate.dialect.InterbaseDialect</tt></td></tr><tr><td>Pointbase</td><td><tt class="literal">net.sf.hibernate.dialect.PointbaseDialect</tt></td></tr><tr><td>FrontBase</td><td><tt class="literal">net.sf.hibernate.dialect.FrontbaseDialect</tt></td></tr><tr><td>Firebird</td><td><tt class="literal">net.sf.hibernate.dialect.FirebirdDialect</tt></td></tr></tbody></table></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-outerjoin"></a>3.5.2.&nbsp;Chargement par Jointure Ouverte</h3></div></div><div></div></div><p>
                Si votre base de donn&eacute;es supporte les outer joins de type ANSI ou Oracle, 
                <span class="emphasis"><em>le chargement par jointure ouverte</em></span> devrait am&eacute;liorer les 
                performances en limitant le nombre d'aller-retour avec la base de donn&eacute;es (la
                base de donn&eacute;es effectuant donc potentiellement plus de travail). Le chargement par
                jointure ouverte permet &agrave; un graphe connect&eacute; d'objets par une relation plusieurs-&agrave;-un,
                un-&agrave;-plusieurs ou un-&agrave;-un d'&ecirc;tre charg&eacute; en un seul <tt class="literal">SELECT</tt> SQL.
            </p><p>
                Par d&eacute;faut, le graphe charg&eacute; lorsqu'un objet est demand&eacute;, finit aux objets feuilles,
                aux collections, aux objets avec proxy ou lorsqu'une circularit&eacute; appara&icirc;t.
            </p><p>
                Le chargement peut &ecirc;tre activ&eacute; ou d&eacute;sactiv&eacute; (valeur par d&eacute;faut) pour une 
                <span class="emphasis"><em>association particuli&egrave;re</em></span>, en positionant l'attribut
                <tt class="literal">outer-join</tt> dans le mapping XML.
            </p><p>
                Le chargement par jointure ouverte peut &ecirc;tre d&eacute;sactiv&eacute; <span class="emphasis"><em>de mani&egrave;re
                globale</em></span> en positionant la propri&eacute;t&eacute; 
                <tt class="literal">hibernate.max_fetch_depth</tt> &agrave; <tt class="literal">0</tt>.
                Une valeur de <tt class="literal">1</tt> ou plus permet les jointures ouvertes
                pour toutes les associations un-&agrave;-un et plusieurs-&agrave;-un qui sont, par d&eacute;faut,
                positionn&eacute;es &agrave; la valeur de jointure outerte <tt class="literal">auto</tt>.
                Cependant, les associations un-&agrave;-plusieurs et les collections ne sont jamais charg&eacute;es
                en utilisant une jonture ouverte, &agrave; moins de le d&eacute;clarer de fa&ccedil;on explicite
                pour chaque association. Cette fonctionalit&eacute; peut &ecirc;tre surcharg&eacute;e &agrave; l'ex&eacute;cution
                dans les requ&ecirc;tes Hibernate.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-binarystreams"></a>3.5.3.&nbsp;Flux binaires</h3></div></div><div></div></div><p>
                Oracle limite la taille d'un tableau de <tt class="literal">byte</tt> qui peuvent &ecirc;tre
                pass&eacute;es &agrave; et vers son pilote JDBC. Si vous souhaitez utiliser des instances larges
                de type <tt class="literal">binary</tt> ou <tt class="literal">serializable</tt>, vous devez activer
                la propri&eacute;t&eacute; <tt class="literal">hibernate.jdbc.use_streams_for_binary</tt>. <span class="emphasis"><em>C'est une 
                fonctionalit&eacute; de niveau JVM uniquement.</em></span>
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-cacheprovider"></a>3.5.4.&nbsp;<tt class="literal">CacheProvider</tt> sp&eacute;cifique</h3></div></div><div></div></div><p>
                Vous pouvez int&eacute;grer un cache de second niveau de type JVM (ou cluster)
                en impl&eacute;mentant l'interface <tt class="literal">net.sf.hibernate.cache.CacheProvider</tt>.
                Vous pouvez s&eacute;lectionner l'impl&eacute;mentation sp&eacute;cifique en positionnant
                <tt class="literal">hibernate.cache.provider_class</tt>.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-transactionstrategy"></a>3.5.5.&nbsp;Configuration de la strat&eacute;gie transactionnelle</h3></div></div><div></div></div><p>
                Si vous souhaitez utiliser l'API d'Hibernate <tt class="literal">Transaction</tt>,
                vous devez sp&eacute;cifier une classe factory d'instances de 
                <tt class="literal">Transaction</tt> en positionnant la propri&eacute;t&eacute;
                <tt class="literal">hibernate.transaction.factory_class</tt>.
                L'API <tt class="literal">Transaction</tt> masque le m&eacute;canisme de transaction 
                sous-jacent et permet au code utilisant Hibernate de tourner dans des environnements
                manag&eacute;s et non-manag&eacute;s sans le moindre changement.
            </p><p>
                Il existe deux choix standards (fournis) :
            </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">net.sf.hibernate.transaction.JDBCTransactionFactory</tt></span></dt><dd><p>d&eacute;l&egrave;gue aux transactions de la base de donn&eacute;es (JDBC). Valeur par d&eacute;faut.</p></dd><dt><span class="term"><tt class="literal">net.sf.hibernate.transaction.JTATransactionFactory</tt></span></dt><dd><p>d&eacute;l&egrave;gue &agrave; JTA (si une transaction existant est en cours, la 
                        <tt class="literal">Session</tt> ex&eacute;cute son travail dans ce contexte ; sinon,
                        une nouvelle transaction est d&eacute;marr&eacute;e).</p></dd></dl></div><p>
                Vous pouvez &eacute;galement d&eacute;finir votre propre strat&eacute;gie transactionnelle
                (pour un service de transaction CORBA par exemple).
            </p><p>
                Si vous voulez utiliser un cache de niveau JVM pour des donn&eacute;es muables dans un 
                environnement JTA, vous devez sp&eacute;cifier une strat&eacute;gie d'obtention du
                <tt class="literal">TransactionManager</tt> JTA. En effet, cet acc&egrave;s n'est pas 
                standardis&eacute; par la norme J2EE :
            </p><div class="table"><a name="jtamanagerlookup"></a><p class="title"><b>Tableau&nbsp;3.5.&nbsp;TransactionManagers JTA</b></p><table summary="TransactionManagers JTA" border="1"><colgroup><col><col></colgroup><thead><tr><th>Factory de Transaction</th><th align="center">Serveur d'application</th></tr></thead><tbody><tr><td><tt class="literal">net.sf.hibernate.transaction.JBossTransactionManagerLookup</tt></td><td align="center">JBoss</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.WeblogicTransactionManagerLookup</tt></td><td align="center">Weblogic</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.WebSphereTransactionManagerLookup</tt></td><td align="center">WebSphere</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.OrionTransactionManagerLookup</tt></td><td align="center">Orion</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.ResinTransactionManagerLookup</tt></td><td align="center">Resin</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.JOTMTransactionManagerLookup</tt></td><td align="center">JOTM</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.JOnASTransactionManagerLookup</tt></td><td align="center">JOnAS</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.JRun4TransactionManagerLookup</tt></td><td align="center">JRun4</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.BESTransactionManagerLookup</tt></td><td align="center">Borland ES</td></tr></tbody></table></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-jndi"></a>3.5.6.&nbsp;<tt class="literal">SessionFactory</tt> associ&eacute;e au JNDI</h3></div></div><div></div></div><p>
                Une <tt class="literal">SessionFactory</tt> Hibernate associ&eacute;e au JNDI peut 
                simplifier l'acc&egrave;s &agrave; la fabrique et donc la cr&eacute;ation de nouvelles
                <tt class="literal">Session</tt>s.
            </p><p>
                Si vous d&eacute;sirez associer la <tt class="literal">SessionFactory</tt> &agrave; un nom JNDI,
                sp&eacute;cifiez un nom (ex. <tt class="literal">java:comp/env/hibernate/SessionFactory</tt>) en
                utilisant la propri&eacute;t&eacute; <tt class="literal">hibernate.session_factory_name</tt>.
                Si cette propri&eacute;t&eacute; est omise, la <tt class="literal">SessionFactory</tt> ne sera pas
                associ&eacute;e au JNDI (c'est particuli&egrave;rement pratique dans les environnements ayant une
                impl&eacute;mentation de JNDI en lecture seule, comme c'est le cas pour Tomcat).
            </p><p>
                Lorsqu'il associe la <tt class="literal">SessionFactory</tt> au JNDI, Hibernate utilisera 
                les valeurs de <tt class="literal">hibernate.jndi.url</tt>, <tt class="literal">hibernate.jndi.class</tt>
                pour instancier un contexte d'initialisation. S'ils ne sont pas sp&eacute;cifi&eacute;s, 
                l'<tt class="literal">InitialContext</tt> par d&eacute;faut sera utilis&eacute;.
            </p><p>
                Si vous d&eacute;cidez d'utiliser JNDI, un EJB ou toute autre classe utilitaire
                pourra obtenir la <tt class="literal">SessionFactory</tt> en faisant un acc&egrave;s
                au JNDI.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-querysubstitution"></a>3.5.7.&nbsp;Substitution dans le langage de requ&ecirc;tage</h3></div></div><div></div></div><p>
                Vous pouvez d&eacute;finir de nouveaux tokens dans les requ&ecirc;tes Hibernate en utilisant la propri&eacute;t&eacute;
                <tt class="literal">hibernate.query.substitutions</tt>. Par exemple :
            </p><pre class="programlisting">hibernate.query.substitutions vrai=1, faux=0</pre><p>
                remplacerait les tokens <tt class="literal">vrai</tt> et <tt class="literal">faux</tt> par
                des entiers dans le SQL g&eacute;n&eacute;r&eacute;.
            </p><pre class="programlisting">hibernate.query.substitutions toLowercase=LOWER</pre><p>
                permettrait de renommer la fonction SQL <tt class="literal">LOWER</tt> en <tt class="literal">toLowercase</tt>
            </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-logging"></a>3.6.&nbsp;Logguer</h2></div></div><div></div></div><p>
            Hibernate loggue divers &eacute;v&egrave;nements en utilisant Apache commons-logging.
        </p><p>
            Le service commons-logging d&eacute;l&egrave;guera directement &agrave; Apache Log4j
            (si vous incluez <tt class="literal">log4j.jar</tt> dans votre classpath)
            ou le syst&egrave;me de log du JDK 1.4 (si vous tournez sous le JDK 1.4
            et sup&eacute;rieur). Vous pouvez t&eacute;l&eacute;charger Log4j &agrave; partir de
            <tt class="literal">http://jakarta.apache.org</tt>. Pour utiliser Log4j,
            vous devrez placer dans votre classpath un fichier 
            <tt class="literal">log4j.properties</tt>. Un exemple de fichier est distribu&eacute;
            avec Hibernate dans le r&eacute;pertoire <tt class="literal">src/</tt>.
        </p><p>
            Nous vous recommandons fortement de vous familiariser avec les messages de logs 
            d'Hibernate. Beaucoup de soins a &eacute;t&eacute; apport&eacute; pour donner le plus de d&eacute;tails
            possibles sans les rendre illisibles. C'est un outil essentiel en cas de soucis.
            De m&ecirc;me, n'oubliez pas d'activer les logs SQL comme d&eacute;crit pr&eacute;c&eacute;demment
            <tt class="literal">hibernate.show_sql</tt>, c'est la premi&egrave;re &eacute;tape
            pour regarder les probl&egrave;mes de performance.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-namingstrategy"></a>3.7.&nbsp;Impl&eacute;menter une <tt class="literal">NamingStrategy</tt></h2></div></div><div></div></div><p>
            L'interface <tt class="literal">net.sf.hibernate.cfg.NamingStrategy</tt> vous permet de
            sp&eacute;cifier une "strat&eacute;gie de nommage" des objets et &eacute;l&eacute;ments de la base de donn&eacute;es.
        </p><p>
            Vous pouvez fournir des r&egrave;gles pour automatiquement g&eacute;n&eacute;rer les identifiants
            de base de donn&eacute;es &agrave; partir des identifiants Java, ou transformer une colonne
            ou table "logique" donn&eacute;e dans le fichier de mapping en une colonne ou table
            "physique". Cette fonctionnalit&eacute; aide &agrave; r&eacute;duire la verbosit&eacute; de documents
            de mapping, en &eacute;liminant le bruit r&eacute;p&eacute;titif (les pr&eacute;fixes <tt class="literal">TBL_</tt>
            par exemple). La strat&eacute;gie par d&eacute;faut utilis&eacute;e par Hibernate est minimale.
        </p><p>
            Vous pouvez d&eacute;finir une strat&eacute;gie diff&eacute;rente en appelant
            <tt class="literal">Configuration.setNamingStrategy()</tt> avant d'ajouter des
            mappings :
        </p><pre class="programlisting">SessionFactory sf = new Configuration()
    .setNamingStrategy(ImprovedNamingStrategy.INSTANCE)
    .addFile("Item.hbm.xml")
    .addFile("Bid.hbm.xml")
    .buildSessionFactory();</pre><p>
            <tt class="literal">net.sf.hibernate.cfg.ImprovedNamingStrategy</tt> est une 
            strat&eacute;gie fournie qui peut &ecirc;tre utile comme point de d&eacute;part de quelques
            applications.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-xmlconfig"></a>3.8.&nbsp;Fichier de configuration XML</h2></div></div><div></div></div><p>
            Une approche alternative est de sp&eacute;cifier toute la configuration dans un
            fichier nomm&eacute; <tt class="literal">hibernate.cfg.xml</tt>. Ce fichier peut &ecirc;tre 
            utilis&eacute; &agrave; la place du fichier <tt class="literal">hibernate.properties</tt>, voire
            m&ecirc;me peut servir &agrave; surcharger les propri&eacute;t&eacute;s si les deux fichiers sont pr&eacute;sents.
        </p><p>
            Le fichier de configuration XML doit par d&eacute;faut se placer &agrave; la racine
            du <tt class="literal">CLASSPATH</tt>. En voici un exemple :
        </p><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 2.0//EN"

 "http://hibernate.sourceforge.net/hibernate-configuration-2.0.dtd"&gt;

&lt;hibernate-configuration&gt;

    &lt;!-- une instance de SessionFactory accessible par son nom jndi --&gt;
    &lt;session-factory
        name="java:comp/env/hibernate/SessionFactory"&gt;

        &lt;!-- propri&eacute;t&eacute;s --&gt;
        &lt;property name="connection.datasource"&gt;ma/premiere/datasource&lt;/property&gt;
        &lt;property name="dialect"&gt;net.sf.hibernate.dialect.MySQLDialect&lt;/property&gt;
        &lt;property name="show_sql"&gt;false&lt;/property&gt;
        &lt;property name="use_outer_join"&gt;true&lt;/property&gt;
        &lt;property name="transaction.factory_class"&gt;
            net.sf.hibernate.transaction.JTATransactionFactory
        &lt;/property&gt;
        &lt;property name="jta.UserTransaction"&gt;java:comp/UserTransaction&lt;/property&gt;

        &lt;!-- mapping files --&gt;
        &lt;mapping resource="org/hibernate/auction/Item.hbm.xml"/&gt;
        &lt;mapping resource="org/hibernate/auction/Bid.hbm.xml"/&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre><p>
           Configurer Hibernate devient donc aussi simple que ceci :
       </p><pre class="programlisting">SessionFactory sf = new Configuration().configure().buildSessionFactory();</pre><p>
           Vous pouvez utiliser une fichier de configuration XML de nom diff&eacute;rent en utilisant
       </p><a name="configuration-xmlconfig-ex3"></a><pre class="programlisting">SessionFactory sf = new Configuration()
    .configure("/my/package/catdb.cfg.xml")
    .buildSessionFactory();</pre></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="persistent-classes"></a>Chapitre&nbsp;4.&nbsp;Classes persistantes</h2></div></div><div></div></div><p>
        Les classes persistantes sont les classes d'une application qui impl&eacute;mentent
        les entit&eacute;s d'un probl&egrave;me m&eacute;tier (ex. Client et Commande dans une application
        de commerce &eacute;lectronique). Les classes persistantes ont, comme leur nom l'indique,
        des instances transiantes mais aussi persistantes c'est-&agrave;-dire stock&eacute;es en base de donn&eacute;es.
    </p><p>
        Hibernate fonctionne de mani&egrave;re optimale lorsque ces classes suivent quelques r&egrave;gles
        simples, aussi connues comme le mod&egrave;le de programmation Plain Old Java Object
        (POJO).
    </p><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-pojo"></a>4.1.&nbsp;Un exemple simple de POJO</h2></div></div><div></div></div><p>
            Toute bonne application Java n&eacute;cessite une classe persistante
            repr&eacute;sentant les f&eacute;lins.
        </p><pre class="programlisting">package eg;
import java.util.Set;
import java.util.Date;

public class Cat {
    private Long id; // identifiant
    private String name;
    private Date birthdate;
    private Cat mate;
    private Set kittens
    private Color color;
    private char sex;
    private float weight;

    private void setId(Long id) {
        this.id=id;
    }
    public Long getId() {
        return id;
    }

    void setName(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }

    void setMate(Cat mate) {
        this.mate = mate;
    }
    public Cat getMate() {
        return mate;
    }

    void setBirthdate(Date date) {
        birthdate = date;
    }
    public Date getBirthdate() {
        return birthdate;
    }
    void setWeight(float weight) {
        this.weight = weight;
    }
    public float getWeight() {
        return weight;
    }

    public Color getColor() {
        return color;
    }
    void setColor(Color color) {
        this.color = color;
    }
    void setKittens(Set kittens) {
        this.kittens = kittens;
    }
    public Set getKittens() {
        return kittens;
    }
    // addKitten n'est pas n&eacute;cessaire pour Hibernate
    public void addKitten(Cat kitten) {
        kittens.add(kitten);
    }
    void setSex(char sex) {
        this.sex=sex;
    }
    public char getSex() {
        return sex;
    }
}</pre><p>
            Il y a quatre r&egrave;gles &agrave; suivre ici :
        </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-pojo-accessors"></a>4.1.1.&nbsp;D&eacute;clarer les accesseurs et modifieurs des attributs persistants</h3></div></div><div></div></div><p>
                <tt class="literal">Cat</tt> d&eacute;clare des m&eacute;thodes d'acc&egrave;s pour tous ses attributs
                persistants. Beaucoup d'autres solutions de mapping Objet/relationnel
                persistent directement les instances des attributs.
                Nous pensons qu'il est bien mieux de d&eacute;coupler ce d&eacute;tail d'impl&eacute;mentation
                du m&eacute;canisme de persistence. Hibernate persiste les propri&eacute;t&eacute;s suivant le style
                JavaBeans et reconnait les noms de m&eacute;thodes de la forme
                <tt class="literal">getFoo</tt>, <tt class="literal">isFoo</tt> et
                <tt class="literal">setFoo</tt>.
            </p><p>
                Les propri&eacute;t&eacute;s <span class="emphasis"><em>n'ont pas</em></span> &agrave; &ecirc;tre d&eacute;clar&eacute;es publiques -
                Hibernate peut persister une propri&eacute;t&eacute; avec un paire de getter/setter de
                visibilit&eacute; par d&eacute;fault, <tt class="literal">protected</tt> ou <tt class="literal">
                private</tt>
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-pojo-constructor"></a>4.1.2.&nbsp;Impl&eacute;menter un constructeur par d&eacute;faut</h3></div></div><div></div></div><p>
                <tt class="literal">Cat</tt> poss&egrave;de un constructeur par d&eacute;faut (sans argument)
                implicite. Toute classe persistante doit avoir un constructeur par d&eacute;faut
                (qui peut &ecirc;tre non-publique) pour permettre &agrave; Hibernate de l'instancier en
                utilisant <tt class="literal">Constructor.newInstance()</tt>.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-pojo-identifier"></a>4.1.3.&nbsp;Fournir une propri&eacute;t&eacute; d'indentifiant (optionnel)</h3></div></div><div></div></div><p>
                <tt class="literal">Cat</tt> poss&egrave;de une propri&eacute;t&eacute; appel&eacute;e <tt class="literal">id</tt>.
                Cette propri&eacute;t&eacute; conserve la valeur de la colonne de cl&eacute; primaire de la table 
                d'une base de donn&eacute;es. La propri&eacute;t&eacute; aurait pu s'appeler compl&egrave;tement autrement,
                et son type aurait pu &ecirc;tre n'importe quel type primitif, n'importe quel "encapsuleur"
                de type primitif, <tt class="literal">java.lang.String</tt> ou <tt class="literal">java.util.Date</tt>.
                (Si votre base de donn&eacute;es h&eacute;rit&eacute;e poss&egrave;de des cl&eacute;s composites, elles peuvent &ecirc;tre mapp&eacute;es
                en utilisant une classe d&eacute;finie par l'utilisateur et poss&eacute;dant les propri&eacute;t&eacute;s associ&eacute;es aux
                types de la cl&eacute; composite - voir la section concernant les identifiants composites plus bas).
            </p><p>
                La propri&eacute;t&eacute; d'identifiant est optionnelle. Vous pouver l'oublier et laisser Hibernate
                s'occuper des identifiants de l'objet en interne. Cependant, pour beaucoup d'applications,
                avoir un identifiant reste un design bon (et tr&egrave;s populaire).
            </p><p>
                De plus, quelques fonctionnalit&eacute;s ne sont disponibles que pour les classes
                d&eacute;clarant un identifiant de propri&eacute;t&eacute; :
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        Mises &agrave; jour en cascade (Voir "Cycle de vie des objets")
                    </p></li><li><p>
                        <tt class="literal">Session.saveOrUpdate()</tt>
                    </p></li></ul></div><p>
                Nous recommandons que vous d&eacute;clariez les propri&eacute;t&eacute;s d'identifiant de mani&egrave;re
                uniforme. Nous recommandons &eacute;galement que vous utilisiez un type nullable
                (ie. non primitif).
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-pojo-final"></a>4.1.4.&nbsp;Favoriser les classes non finales (optionnel)</h3></div></div><div></div></div><p>
                Une fonctionalit&eacute; cl&eacute;e d'Hibernate, les <span class="emphasis"><em>proxies</em></span>, n&eacute;cessitent
                que la classe persistente soit non finale ou qu'elle soit l'impl&eacute;mentation d'une
                interface qui d&eacute;clare toutes les m&eacute;thodes publiques.
            </p><p>
                Vous pouvez persister, gr&acirc;ce &agrave; Hibernate, les classes <tt class="literal">final</tt> 
                qui n'impl&eacute;mentent pas d'interface, mais vous ne pourrez pas utiliser les proxies
                - ce qui limitera vos possibilit&eacute;s d'ajustement des performances.
            </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-inheritance"></a>4.2.&nbsp;Impl&eacute;menter l'h&eacute;ritage</h2></div></div><div></div></div><p>
            Une sous-classe doit &eacute;galement suivre la premi&egrave;re et la seconde r&egrave;gle.
            Elle h&eacute;rite sa propri&eacute;t&eacute; d'identifiant de <tt class="literal">Cat</tt>.
        </p><pre class="programlisting">package eg;

public class DomesticCat extends Cat {
        private String name;

        public String getName() {
                return name;
        }
        protected void setName(String name) {
                this.name=name;
        }
}</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-equalshashcode"></a>4.3.&nbsp;Impl&eacute;menter <tt class="literal">equals()</tt> et <tt class="literal">hashCode()</tt></h2></div></div><div></div></div><p>
            Vous devez surcharger les m&eacute;thodes <tt class="literal">equals()</tt> et 
            <tt class="literal">hashCode()</tt> si vous avez l'intention de "m&eacute;langer" des objets
            de classes persistantes (ex dans un <tt class="literal">Set</tt>).
        </p><p>
            <span class="emphasis"><em>Cette r&egrave;gle ne s'applique que si ces objets sont charg&eacute;s &agrave; partir de
            deux <tt class="literal">Session</tt>s diff&eacute;rentes, dans la mesure o&ugrave; Hibernate
            ne garantit l'identit&eacute; de niveau JVM (<tt class="literal"> a == b </tt>,
            l'impl&eacute;mentation par d&eacute;faut d'<tt class="literal">equals()</tt> en Java) qu'au sein d'une
            seule <tt class="literal">Session</tt> !</em></span>
        </p><p>
            M&ecirc;me si deux objets <tt class="literal">a</tt> et <tt class="literal">b</tt> repr&eacute;sentent la m&ecirc;me
            ligne dans la base de donn&eacute;es (ils ont la m&ecirc;me valeur de cl&eacute; primaire comme identifiant),
            nous ne pouvons garantir qu'ils seront la m&ecirc;me instance Java hors du contexte d'une
            <tt class="literal">Session</tt> donn&eacute;e.
        </p><p>
            La mani&egrave;re la plus &eacute;vidente est d'impl&eacute;menter <tt class="literal">equals()</tt>/<tt class="literal">hashCode()</tt>
            en comparant la valeur de l'identifiant des deux objets. Si cette valeur est identique, les deux
            doivent repr&eacute;senter la m&ecirc;me ligne de base de donn&eacute;es, ils sont donc &eacute;gaux (si les deux sont
            ajout&eacute;s &agrave; un <tt class="literal">Set</tt>, nous n'auront qu'un seul &eacute;l&eacute;ment dans le <tt class="literal">Set</tt>).
            Malheureusement, nous ne pouvons pas utiliser cette approche. Hibernate n'assignera de
            valeur d'identifiant qu'aux objets qui sont persistant, une instance nouvellement cr&eacute;&eacute;e n'aura 
            donc pas de valeur d'identifiant ! Nous recommandons donc d'impl&eacute;menter
            <tt class="literal">equals()</tt> et <tt class="literal">hashCode()</tt> en utilisant <span class="emphasis"><em>
            l'&eacute;galit&eacute; par cl&eacute; m&eacute;tier</em></span>.
        </p><p>
            L'&eacute;galit&eacute; par cl&eacute; m&eacute;tier signifie que la m&eacute;thode <tt class="literal">equals()</tt>
            compare uniquement les propri&eacute;t&eacute;s qui forment une cl&eacute; m&eacute;tier, une cl&eacute; qui
            identifierait notre instance dans le monde r&eacute;el (une cl&eacute; candidate
            <span class="emphasis"><em>naturelle</em></span>) :
        </p><pre class="programlisting">public class Cat {

    ...
    public boolean equals(Object other) {
        if (this == other) return true;
        if (!(other instanceof Cat)) return false;

        final Cat cat = (Cat) other;

        if (!getName().equals(cat.getName())) return false;
        if (!getBirthday().equals(cat.getBirthday())) return false;

        return true;
    }

    public int hashCode() {
        int result;
        result = getName().hashCode();
        result = 29 * result + getBirthday().hashCode();
        return result;
    }

}</pre><p>
            Garder &agrave; l'esprit que notre cl&eacute; candidate (dans ce cas, une cl&eacute; compos&eacute;e du nom et
            de la date de naissance) n'a &agrave; &ecirc;tre valide et pertinente que pour une op&eacute;ration de comparaison
            particuli&egrave;re (peut-&ecirc;tre m&ecirc;me pour un seul cas d'utilisation). Nous n'avons pas besoin
            du m&ecirc;me crit&egrave;re de stabilit&eacute; que celui n&eacute;cessaire &agrave; la cl&eacute; primaire r&eacute;elle !
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-lifecycle"></a>4.4.&nbsp;Callbacks de cycle de vie</h2></div></div><div></div></div><p>
            Une classe persistence peut, de mani&egrave;re facultative, impl&eacute;menter l'interface
            <tt class="literal">Lifecycle</tt> qui fournit des callbacks permettant aux
            objets persistants d'effectuer des op&eacute;rations d'initialisation ou
            de nettoyage apr&egrave;s une sauvegarde ou un chargement et avant une 
            suppression ou une mise &agrave; jour.
        </p><p>
            
            L'<tt class="literal">Interceptor</tt> d'Hibernate offre cependant une 
            alternative moins intrusive.
        </p><div class="programlistingco"><pre class="programlisting">public interface Lifecycle {
        public boolean onSave(Session s) throws CallbackException;   <span class="co">(1)</span>
        public boolean onUpdate(Session s) throws CallbackException; <span class="co">(2)</span>
        public boolean onDelete(Session s) throws CallbackException; <span class="co">(3)</span>
        public void onLoad(Session s, Serializable id);              <span class="co">(4)</span>
}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">onSave</tt> - appel&eacute; juste avant que l'objet soit 
                        sauv&eacute; ou ins&eacute;r&eacute;
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">onUpdate</tt> - appel&eacute; juste avant qu'un objet
                        soit mis &agrave; jour (quand l'objet est pass&eacute; &agrave; 
                        <tt class="literal">Session.update()</tt>)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">onDelete</tt> - appel&eacute; juste avant que l'objet soit supprim&eacute;
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                        <tt class="literal">onLoad</tt> - appel&eacute; juste apr&egrave;s que l'objet soit charg&eacute;
                    </p></td></tr></table></div></div><p>
            <tt class="literal">onSave()</tt>, <tt class="literal">onDelete()</tt> et
            <tt class="literal">onUpdate()</tt> peuvent &ecirc;tre utilis&eacute;s pour sauver ou
            supprimer en cascade de objets d&eacute;pendants. <tt class="literal">onLoad()</tt>
            peut &ecirc;tre utilis&eacute; pour initialiser des propri&eacute;t&eacute;s transiantes de l'objet
            &agrave; partir de son &eacute;tat persistant. Il ne doit pas &ecirc;tre utilis&eacute; pour charger des
            objets d&eacute;pendants parce que l'interface <tt class="literal">Session</tt> ne doit pas
            &ecirc;tre appel&eacute;e au sein de cette m&eacute;thode. Un autre usage possible de 
            <tt class="literal">onLoad()</tt>, <tt class="literal">onSave()</tt> et 
            <tt class="literal">onUpdate()</tt> est de garder une r&eacute;f&eacute;rence &agrave; la 
            <tt class="literal">Session</tt> courante pour un usage ult&eacute;rieur.
        </p><p>
            Notez que <tt class="literal">onUpdate()</tt> n'est pas appel&eacute; &agrave; chaque fois que l'&eacute;tat
            persistant d'un objet est mis &agrave; jour. Elle n'est appel&eacute;e que lorsqu'un objet 
            transiant est pass&eacute; &agrave; <tt class="literal">Session.update()</tt>.
        </p><p>
            Si <tt class="literal">onSave()</tt>, <tt class="literal">onUpdate()</tt> ou
            <tt class="literal">onDelete()</tt> retourne <tt class="literal">true</tt>,
            l'op&eacute;ration n'est pas effectu&eacute;e et ceci de mani&egrave;re silencieuse.
            Si une <tt class="literal">CallbackException</tt> est lev&eacute;e, l'op&eacute;ration
            n'est pas effectu&eacute;e et l'exception est retourn&eacute;e &agrave; l'application.
        </p><p>
            Notez que <tt class="literal">onSave()</tt> est appel&eacute; apr&egrave;s que l'identifiant
            ait &eacute;t&eacute; assign&eacute; &agrave; l'objet sauf si la g&eacute;n&eacute;ration native de cl&eacute;s est utilis&eacute;e.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-validatable"></a>4.5.&nbsp;Callback de validation</h2></div></div><div></div></div><p>
            Si la classe persistante a besoin de v&eacute;rifier des invariants avant que
            son &eacute;tat soit persist&eacute;, elle peut impl&eacute;menter l'interface suivante :
        </p><pre class="programlisting">public interface Validatable {
        public void validate() throws ValidationFailure;
}</pre><p>
            L'objet doit lever une <tt class="literal">ValidationFailure</tt> si un invariant
            a &eacute;t&eacute; viol&eacute;. Une instance de <tt class="literal">Validatable</tt> ne doit pas 
            changer son &eacute;tat au sein de la m&eacute;thode <tt class="literal">validate()</tt>.
        </p><p>
            Contrairement aux m&eacute;thodes de callback de l'interface <tt class="literal">Lifecycle</tt>,
            <tt class="literal">validate()</tt> peut &ecirc;tre appel&eacute; &agrave; n'importe quel moment.
            L'application ne doit pas s'appuyer sur les appels &agrave; <tt class="literal">validate()</tt>
            pour des fonctionalit&eacute;s m&eacute;tier.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-xdoclet"></a>4.6.&nbsp;Utiliser le marquage XDoclet</h2></div></div><div></div></div><p>
            Dans le chapitre suivant, nous allons voir comment les mappings Hibernate
            sont exprim&eacute;s dans un format XML simple et lisible. Beaucoup d'utilisateurs
            d'Hibernate pr&eacute;f&egrave;rent embarquer les informations de mapping directement dans
            le code source en utilisant les tags XDoclet <tt class="literal">@hibernate.tags</tt>.
            Nous ne couvrirons pas cette approche dans ce document parce que consid&eacute;r&eacute;e
            comme une part de XDoclet. Cepdendant, nous avons inclus l'exemple suivant
            utilisant la classe <tt class="literal">Cat</tt> et le mapping XDoclet.
        </p><pre class="programlisting">package eg;
import java.util.Set;
import java.util.Date;

/**
 * @hibernate.class
 *  table="CATS"
 */
public class Cat {
    private Long id; // identifiant
    private Date birthdate;
    private Cat mate;
    private Set kittens
    private Color color;
    private char sex;
    private float weight;

    /**
     * @hibernate.id
     *  generator-class="native"
     *  column="CAT_ID"
     */
    public Long getId() {
        return id;
    }
    private void setId(Long id) {
        this.id=id;
    }

    /**
     * @hibernate.many-to-one
     *  column="MATE_ID"
     */
    public Cat getMate() {
        return mate;
    }
    void setMate(Cat mate) {
        this.mate = mate;
    }

    /**
     * @hibernate.property
     *  column="BIRTH_DATE"
     */
    public Date getBirthdate() {
        return birthdate;
    }
    void setBirthdate(Date date) {
        birthdate = date;
    }
    /**
     * @hibernate.property
     *  column="WEIGHT"
     */
    public float getWeight() {
        return weight;
    }
    void setWeight(float weight) {
        this.weight = weight;
    }

    /**
     * @hibernate.property
     *  column="COLOR"
     *  not-null="true"
     */
    public Color getColor() {
        return color;
    }
    void setColor(Color color) {
        this.color = color;
    }
    /**
     * @hibernate.set
     *  lazy="true"
     *  order-by="BIRTH_DATE"
     * @hibernate.collection-key
     *  column="PARENT_ID"
     * @hibernate.collection-one-to-many
     */
    public Set getKittens() {
        return kittens;
    }
    void setKittens(Set kittens) {
        this.kittens = kittens;
    }
    // addKitten n'est pas n&eacute;cesaire &agrave; Hibernate
    public void addKitten(Cat kitten) {
        kittens.add(kitten);
    }

    /**
     * @hibernate.property
     *  column="SEX"
     *  not-null="true"
     *  update="false"
     */
    public char getSex() {
        return sex;
    }
    void setSex(char sex) {
        this.sex=sex;
    }
}</pre></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="mapping"></a>Chapitre&nbsp;5.&nbsp;Mapping O/R basique</h2></div></div><div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-declaration"></a>5.1.&nbsp;D&eacute;claration de Mapping</h2></div></div><div></div></div><p>
            Les mappings objet/relationnel sont d&eacute;finis dans un document XML. Le document de
	    mapping est con&ccedil;u pour &ecirc;tre lisible et &eacute;ditable &agrave; la main. Le vocabulaire de mapping
	    est orient&eacute; Java, ce qui signifie que les mappings sont construits autour des classes
	    java et non autour des d&eacute;clarations de tables.
        </p><p>
            M&ecirc;me si beaucoup d'utilisateurs d'Hibernate choisissent d'&eacute;crire les fichiers de mapping
	    &agrave; la main, il existe des outils pour les g&eacute;n&eacute;rer, comme XDoclet, Middlegen et AndroMDA.
        </p><p>
            Encha&icirc;nons sur un exemple de mapping:
        </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 2.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

        &lt;class name="Cat" table="CATS" discriminator-value="C"&gt;
                &lt;id name="id" column="uid" type="long"&gt;
                        &lt;generator class="hilo"/&gt;
                &lt;/id&gt;
                &lt;discriminator column="subclass" type="character"/&gt;
                &lt;property name="birthdate" type="date"/&gt;
                &lt;property name="color" not-null="true"/&gt;
                &lt;property name="sex" not-null="true" update="false"/&gt;
                &lt;property name="weight"/&gt;
                &lt;many-to-one name="mate" column="mate_id"/&gt;
                &lt;set name="kittens"&gt;
                        &lt;key column="mother_id"/&gt;
                        &lt;one-to-many class="Cat"/&gt;
                &lt;/set&gt;
                &lt;subclass name="DomesticCat" discriminator-value="D"&gt;
                        &lt;property name="name" type="string"/&gt;
                &lt;/subclass&gt;
        &lt;/class&gt;

        &lt;class name="Dog"&gt;
                &lt;!-- Le mapping de dog peut &ecirc;tre plac&eacute; ici --&gt;
        &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
             Nous allons parler du document de mapping. Nous aborderons uniquement les &eacute;l&eacute;ments
	     du document utilis&eacute;s &agrave; l'ex&eacute;cution par Hibernate. Ce document contient d'autres 
	     attributs et &eacute;l&eacute;ments optionnels qui agissent sur le sch&eacute;ma de base de donn&eacute;es export&eacute; par l'outil
	     d'export de sch&eacute;ma.(par exemple l'attribut <tt class="literal">not-null</tt>.)
        </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-doctype"></a>5.1.1.&nbsp;Doctype</h3></div></div><div></div></div><p>
                Tous les mappings XML doivent d&eacute;clarer le doctype de l'exemple pr&eacute;c&eacute;dent. L'actuelle 
		DTD peut &ecirc;tre trouv&eacute;e &agrave; l'URL du dessus, dans le r&eacute;pertoire <tt class="literal">hibernate-x.x.x/src/net/sf/hibernate
                </tt> ou dans <tt class="literal">hibernate2.jar</tt>. Hibernate cherchera toujours en priorit&eacute; la DTD
		dans le classpath.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-mapping"></a>5.1.2.&nbsp;hibernate-mapping</h3></div></div><div></div></div><p>
                Cet &eacute;l&eacute;ment poss&egrave;de trois attributs optionnels. L'attribut <tt class="literal">schema</tt> sp&eacute;cifie
		&agrave; quel sch&eacute;ma appartiennent les tables d&eacute;clar&eacute;es par ce mapping. S'il est sp&eacute;cifi&eacute;, les noms
		des tables seront qualifi&eacute;s par le nom de sch&eacute;ma donn&eacute;. S'il est absent, les noms des tables
		ne seront pas qualifi&eacute;es. L'attribut <tt class="literal">default-cascade</tt> sp&eacute;cifie quel style de 
		cascade doit &ecirc;tre adopt&eacute; pour les propri&eacute;t&eacute;s et collections qui ne sp&eacute;cifient par leur propre
		attribut <tt class="literal">cascade</tt>. L'attribut <tt class="literal">auto-import</tt> nous permet d'utiliser,
		par d&eacute;faut, des noms de classe non qualifi&eacute;s dans le langage de requ&ecirc;te.
            </p><div class="programlistingco"><pre class="programlisting">&lt;hibernate-mapping
         schema="nomDeSchema"                         <span class="co">(1)</span>
         default-cascade="none|save-update"           <span class="co">(2)</span>
         auto-import="true|false"                     <span class="co">(3)</span>
         package="nom.de.package"                     <span class="co">(4)</span>
 /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                             <tt class="literal">schema</tt> (optionnel): Le nom du sch&eacute;ma de base de donn&eacute;es.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                             <tt class="literal">default-cascade</tt> (optionnel - par d&eacute;faut = <tt class="literal">none</tt>): 
                             Un style de cascade par d&eacute;faut.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                             <tt class="literal">auto-import</tt> (optionnel - par d&eacute;faut = <tt class="literal">true</tt>):
                             Sp&eacute;cifie si l'on peut utiliser des noms de classes non qualifi&eacute;s (pour les classes 
			     de ce mapping) dans le langage de requ&ecirc;te.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                             <tt class="literal">package</tt> (optionnel): Sp&eacute;cifie un pr&eacute;fixe de package &agrave; prendre en 
			     compte pour les noms de classes non qualifi&eacute;es dans le mapping courant.
                         </p></td></tr></table></div></div><p>
                 Si vous avez deux classes persistantes avec le m&ecirc;me nom (non qualifi&eacute;), vous devriez
		 utiliser <tt class="literal">auto-import="false"</tt>. Hibernate lancera une exception si 
		 vous essayez d'assigner deux classes au m&ecirc;me nom "import&eacute;".
             </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-class"></a>5.1.3.&nbsp;class</h3></div></div><div></div></div><p>
                Vous pouvez d&eacute;clarer une classe persistante en utilisant l'&eacute;l&eacute;ment <tt class="literal">class</tt>:
            </p><div class="programlistingco"><pre class="programlisting">&lt;class
        name="NomDeClasse"                            <span class="co">(1)</span>
        table="NomDeTable"                            <span class="co">(2)</span>
        discriminator-value="valeur_de_discriminant"  <span class="co">(3)</span>
        mutable="true|false"                          <span class="co">(4)</span>
        schema="proprietaire"                         <span class="co">(5)</span>
        proxy="InterfaceDeProxy"                      <span class="co">(6)</span>
        dynamic-update="true|false"                   <span class="co">(7)</span>
        dynamic-insert="true|false"                   <span class="co">(8)</span>
        select-before-update="true|false"             <span class="co">(9)</span>
        polymorphism="implicit|explicit"              <span class="co">(10)</span>
        where="condition SQL where quelconque"        <span class="co">(11)</span>
        persister="ClasseDePersistance"               <span class="co">(12)</span>
        batch-size="N"                                <span class="co">(13)</span>
        optimistic-lock="none|version|dirty|all"      <span class="co">(14)</span>
        lazy="true|false"                             <span class="co">(15)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> : Le nom de classe enti&egrave;rement qualifi&eacute; pour la classe (ou 
			    l'interface) persistante.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">table</tt> : Le nom de sa table en base de donn&eacute;es.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">discriminator-value</tt> (optionnel - valeur par d&eacute;faut = nom de la classe) : 
			    Une valeur qui distingue les classes filles, utilis&eacute; pour le comportement polymorphique. 
			    Sont aussi autoris&eacute;es les valeurs <tt class="literal">null</tt> et <tt class="literal">not null</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">mutable</tt> (optionnel, valeur par d&eacute;faut = <tt class="literal">true</tt>) : Sp&eacute;cifie 
                            qu'une instance de classe est (ou n'est pas) mutable.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">schema</tt> (optionnel) : Surcharge le nom de sch&eacute;ma d&eacute;fini par l'&eacute;l&eacute;ment racine
			    <tt class="literal">&lt;hibernate-mapping&gt;</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">proxy</tt> (optionnel) : Sp&eacute;cifie une interface &agrave; utiliser pour initialiser tardivement (lazy)
			    les proxies. Vous pouvez sp&eacute;cifier le nom de la classe elle-m&ecirc;me.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">dynamic-update</tt> (optionnel, valeur par d&eacute;faut = <tt class="literal">false</tt>): 
                            Sp&eacute;cifie si l'ordre SQL <tt class="literal">UPDATE</tt> doit &ecirc;tre g&eacute;n&eacute;r&eacute; &agrave; l'ex&eacute;cution et ne contenir 
			    que les colonnes dont les valeurs ont chang&eacute;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">dynamic-insert</tt> (optionnel, valeur par d&eacute;faut = <tt class="literal">false</tt>): 
                            Sp&eacute;cifie si l'ordre SQL <tt class="literal">INSERT</tt> doit &ecirc;tre g&eacute;n&eacute;r&eacute; &agrave; l'ex&eacute;cution et ne contenir 
			    que les colonnes dont les valeurs ne sont pas null.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                            <tt class="literal">select-before-update</tt> (optionnel, valeur par d&eacute;faut = <tt class="literal">false</tt>): 
                            Sp&eacute;cifie qu'Hibernate ne doit <span class="emphasis"><em>jamais</em></span> effectuer un <tt class="literal">UPDATE</tt>
			    SQL &agrave; moins d'&ecirc;tre certain qu'un objet ait r&eacute;ellement &eacute;t&eacute; modifi&eacute;. Dans certains cas (en fait,
			    lorsqu'un objet transiant a &eacute;t&eacute; associ&eacute; &agrave; une nouvelle session en utilisant <tt class="literal">update()</tt>),
                            cela signifie qu'Hibernate effectuera un <tt class="literal">SELECT</tt> SQL suppl&eacute;mentaire pour d&eacute;terminer
			    si un <tt class="literal">UPDATE</tt> est r&eacute;ellement requis.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                            <tt class="literal">polymorphism</tt> (optionnel, par d&eacute;faut = <tt class="literal">implicit</tt>): 
                            D&eacute;termine si, pour cette classe, une requ&ecirc;te polymorphique implicite ou explicite est utilis&eacute;e.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(11)</td><td valign="top" align="left"><p>
                            <tt class="literal">where</tt> (optionnel) sp&eacute;cifie une clause SQL <tt class="literal">WHERE</tt> 
                            &agrave; utiliser lorsque l'on r&eacute;cup&egrave;re des objets de cette classe.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(12)</td><td valign="top" align="left"><p>
                            <tt class="literal">persister</tt> (optionnel): Sp&eacute;cifie un <tt class="literal">ClassPersister</tt> particulier.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(13)</td><td valign="top" align="left"><p>
                            <tt class="literal">batch-size</tt> (optionnel, par d&eacute;faut = <tt class="literal">1</tt>) sp&eacute;cifie une taille de batch 
                            pour remplir les instances de cette classe par identifiant en une seule requ&ecirc;te.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(14)</td><td valign="top" align="left"><p>
                            <tt class="literal">optimistic-lock</tt> (optionnel, par d&eacute;faut = <tt class="literal">version</tt>): 
                            D&eacute;termine la strat&eacute;gie de verrou optimiste.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(15)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optionnel): D&eacute;clarer <tt class="literal">lazy="true"</tt> est un raccourci
			    pour sp&eacute;cifier le nom de la classe comme &eacute;tant l'interface <tt class="literal">proxy</tt>.
                        </p></td></tr></table></div></div><p>
                Il est parfaitement acceptable pour une classe persistante nomm&eacute;e, d'&ecirc;tre une interface. Vous
		devriez alors d&eacute;clarer les classes impl&eacute;mentant cette interface via l'&eacute;l&eacute;ment <tt class="literal">&lt;subclass&gt;</tt>.
		Vous pouvez persister n'importe quelle classe interne <span class="emphasis"><em>statique</em></span>.
		Vous devriez sp&eacute;cifier le nom de classe en utilisant la forme standard : <tt class="literal">eg.Foo$Bar</tt>.
            </p><p>
                Les classes non mutables, <tt class="literal">mutable="false"</tt>, ne peuvent &ecirc;tre modifi&eacute;es ou effac&eacute;es par
		l'application. Cela permet &agrave; Hibernate d'effectuer quelques optimisations de performance mineures.
            </p><p>
                L'attribut optionnel <tt class="literal">proxy</tt> active l'initialisation tardive des instances persistantes
		de la classe. Hibernate retournera d'abord des proxies CGLIB qui impl&eacute;mentent l'interface d&eacute;finie.
		Les objets persistants r&eacute;els seront charg&eacute;s lorsqu'une m&eacute;thode du proxy est invoqu&eacute;e. Voir
		"Proxies pour initialisation tardive" ci dessous.
            </p><p>
	    	Le polymorphisme <span class="emphasis"><em>implicite</em></span> signifie que les instances de la classe seront
		retourn&eacute;es par une requ&ecirc;te qui utilise les noms de la classe ou de chacunes de ses superclasses 
		ou encore des interfaces impl&eacute;ment&eacute;es par cette classe ou ses superclasses. Les instances des classes filles 
        seront retourn&eacute;es par une requ&ecirc;te qui utilise le nom de la classe elle m&ecirc;me.
		Le polymorphisme <span class="emphasis"><em>explicite</em></span> signifie que les instances de la classe ne seront retourn&eacute;es 
		que par une requ&ecirc;te qui utilise explicitement son nom et que seules les instances des classes filles 
		d&eacute;clar&eacute;es dans les &eacute;l&eacute;ments <tt class="literal">&lt;subclass&gt;</tt> ou <tt class="literal">&lt;joined-subclass&gt;</tt>
		seront retourn&eacute;es. Dans la majorit&eacute;s des cas la valeur par d&eacute;faut, <tt class="literal">polymorphism="implicit"</tt>, 
		est appropri&eacute;e. Le polymorphisme explicite est utile lorsque deux classes diff&eacute;rentes sont mapp&eacute;es
		&agrave; la m&ecirc;me table (ceci permet d'&eacute;crire une classe "l&eacute;g&egrave;re" qui ne contient qu'une partie des colonnes
		de la table - voir la partie design pattern du site communautaire).
            </p><p>
                L'attribut <tt class="literal">persister</tt> vous permet de customiser la strat&eacute;gie de persistance utilis&eacute;e
		pour la classe. Vous pouvez, par exemple, sp&eacute;cifier votre propre classe fille de
                <tt class="literal">net.sf.hibernate.persister.EntityPersister</tt> ou vous pouvez m&ecirc;me fournir une nouvelle
		impl&eacute;mentation de l'interface <tt class="literal">net.sf.hibernate.persister.ClassPersister</tt> 
		qui impl&eacute;mente la persistance via, par exemple, des appels &agrave; une proc&eacute;dure stock&eacute;e, la
		s&eacute;rialisation dans des fichiers plats ou dans un LDAP. Voir
		<tt class="literal">net.sf.hibernate.test.CustomPersister</tt> pour un exemple simple (de "persistance"
                dans une <tt class="literal">Hashtable</tt>).
            </p><p>
                Notez que les param&egrave;tres <tt class="literal">dynamic-update</tt> et <tt class="literal">dynamic-insert</tt>
                ne sont pas h&eacute;rit&eacute;s par les classes filles et peuvent donc &ecirc;tre sp&eacute;cifi&eacute;s dans les &eacute;l&eacute;ments
                <tt class="literal">&lt;subclass&gt;</tt> ou <tt class="literal">&lt;joined-subclass&gt;</tt>. 
                Ces param&egrave;tres peuvent accro&icirc;tre les performances dans certains cas, mais peuvent aussi &ecirc;tre
		plus lourds dans d'autres cas. A utiliser de mani&egrave;re judicieuse.
            </p><p>
                L'utilisation de <tt class="literal">select-before-update</tt> fera g&eacute;n&eacute;ralement baisser les performances. Il est cependant
		tr&egrave;s pratique lorsque l'on veut emp&ecirc;cher un trigger de base de donn&eacute;es qui se d&eacute;clenche sur un update d'&ecirc;tre appel&eacute; inutilement.
            </p><p>
            	Si vous activez <tt class="literal">dynamic-update</tt>, vous aurez le choix entre les strat&eacute;gies de verrou optimiste suivantes:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
            			<tt class="literal">version</tt> v&eacute;rifie les colonnes version/timestamp
            		</p></li><li><p>
            			<tt class="literal">all</tt> v&eacute;rifie toutes les colonnes
            		</p></li><li><p>
            			<tt class="literal">dirty</tt> v&eacute;rifie les colonnes modifi&eacute;es
            		</p></li><li><p>
            			<tt class="literal">none</tt> n'utilise pas le verrou optimiste
            		</p></li></ul></div><p>
            	Nous vous recommandons vivement d'utiliser les colonnes version/timestamp
		pour le verrou optimiste avec Hibernate. C'est la strat&eacute;gie optimale qui respecte
		les performances et c'est la seule capable de g&eacute;rer correctement les modifications
		faites en dehors de la session (c'est-&agrave;-dire : lorsque <tt class="literal">Session.update()</tt> est utilis&eacute;e).
            	Gardez &agrave; l'esprit  qu'une propri&eacute;t&eacute; version ou timestamp ne devrait jamais &ecirc;tre nulle,
		quelle que soit la strat&eacute;gie d'<tt class="literal">unsaved-value</tt>, ou alors une instance sera 
		d&eacute;tect&eacute;e comme transiante.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-id"></a>5.1.4.&nbsp;id</h3></div></div><div></div></div><p>
                Les classes mapp&eacute;es <span class="emphasis"><em>doivent</em></span> d&eacute;clarer la colonne cl&eacute; primaire de la table.
		La plupart des classes auront aussi une propri&eacute;t&eacute;, respectant la convention JavaBean, contenant l'identifiant
		unique d'une instance. L'&eacute;l&eacute;ment <tt class="literal">&lt;id&gt;</tt> d&eacute;finit le mapping entre cette propri&eacute;t&eacute;
		et cette colonne cl&eacute; primaire.
            </p><div class="programlistingco"><pre class="programlisting">&lt;id
        name="nomDePropriete"                    <span class="co">(1)</span>
        type="nomdetype"                         <span class="co">(2)</span>
        column="nom_de_colonne"                  <span class="co">(3)</span>
        unsaved-value="any|none|null|id_value"   <span class="co">(4)</span>
        access="field|property|NomDeClasse"&gt;     <span class="co">(5)</span>

        &lt;generator class="generatorClass"/&gt;
&lt;/id&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> (optionnel) : Le nom de la propri&eacute;t&eacute; d'identifiant.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optionnel) : Le nom qui indique le type Hibernate.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optionnel - par d&eacute;faut le nom de la propri&eacute;t&eacute;) : Le nom
			    de la colonne de la cl&eacute; primaire.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">unsaved-value</tt> (optionnel - par d&eacute;faut = <tt class="literal">null</tt>) : 
                            Une valeur de la propri&eacute;t&eacute; d'identifiant qui indique que l'instance est nouvellement
			    instanci&eacute;e (non sauvegard&eacute;e), et qui la distingue des instances transiantes qui ont
			    &eacute;t&eacute; sauvegard&eacute;es ou charg&eacute;es dans une session pr&eacute;c&eacute;dente.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optionnel - par d&eacute;faut = <tt class="literal">property</tt>): La strat&eacute;gie
			    qu'Hibernate doit utiliser pour acc&eacute;der &agrave; la valeur de la propri&eacute;t&eacute;.
                        </p></td></tr></table></div></div><p>
                Si l'attribut <tt class="literal">name</tt> est manquant, on suppose que la classe n'a pas de propri&eacute;t&eacute; d'identifiant.
            </p><p>
                L'attribut <tt class="literal">unsaved-value</tt> est important ! Si la propri&eacute;t&eacute; d'identifiant de votre classe n'est pas
		nulle par d&eacute;faut, vous devriez alors sp&eacute;cifier cet attribut.
            </p><p>
                Il existe une d&eacute;claration alternative : <tt class="literal">&lt;composite-id&gt;</tt>. Elle permet d'acc&eacute;der aux donn&eacute;es
		d'une table ayant une cl&eacute; compos&eacute;e. Nous vous conseillons fortement de ne l'utiliser que pour ce cas pr&eacute;cis.
            </p><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-generator"></a>5.1.4.1.&nbsp;generator</h4></div></div><div></div></div><p>
                    L'&eacute;l&eacute;ment fils obligatoire <tt class="literal">&lt;generator&gt;</tt> d&eacute;finit la classe Java utilis&eacute;e
		    pour g&eacute;n&eacute;rer l'identifiant unique des instances d'une classe persistante. Si des param&egrave;tres sont
		    requis pour configurer ou initialiser l'instance du g&eacute;n&eacute;rateur, ils seront pass&eacute;s via l'&eacute;l&eacute;ment
                    <tt class="literal">&lt;param&gt;</tt>.
                </p><pre class="programlisting">&lt;id name="id" type="long" column="uid" unsaved-value="0"&gt;
        &lt;generator class="net.sf.hibernate.id.TableHiLoGenerator"&gt;
                &lt;param name="table"&gt;uid_table&lt;/param&gt;
                &lt;param name="column"&gt;next_hi_value_column&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><p>
                    Tous les g&eacute;n&eacute;rateurs impl&eacute;mentent l'interface <tt class="literal">net.sf.hibernate.id.IdentifierGenerator</tt>.
                    C'est une interface tr&egrave;s simple ; certaines applications peuvent choisir de fournir leur propre
		    impl&eacute;mentation sp&eacute;cifique. Cependant, Hibernate fournit plusieurs impl&eacute;mentations de mani&egrave;re native.
		    Il y a des diminutifs pour les g&eacute;n&eacute;rateurs natifs :

                    </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">increment</tt></span></dt><dd><p>
                                g&eacute;n&egrave;re des identifiants du type <tt class="literal">long</tt>, <tt class="literal">short</tt> ou
                                <tt class="literal">int</tt> qui sont uniques seulement lorsqu'aucun autre process
				n'ins&egrave;re de donn&eacute;es dans la m&ecirc;me table.
                                <span class="emphasis"><em>Ne pas utiliser dans un cluster.</em></span>
                            </p></dd><dt><span class="term"><tt class="literal">identity</tt></span></dt><dd><p>
                                supporte les colonnes identity dans DB2, MySQL, MS SQL Server, Sybase et
                                HypersonicSQL. L'identifiant retourn&eacute; est du type <tt class="literal">long</tt>,
                                <tt class="literal">short</tt> ou <tt class="literal">int</tt>.
                            </p></dd><dt><span class="term"><tt class="literal">sequence</tt></span></dt><dd><p>
                                utilise une s&eacute;quence dans DB2, PostgreSQL, Oracle, SAP DB, McKoi ou un g&eacute;n&eacute;rateur
                                dans Interbase. L'identifiant retourn&eacute; est de type <tt class="literal">long</tt>,
                                <tt class="literal">short</tt> ou <tt class="literal">int</tt>
                            </p></dd><dt><span class="term"><tt class="literal">hilo</tt></span></dt><dd><p><a name="mapping-declaration-id-hilodescription"></a>
                                utilise l'algorithme hi/lo pour g&eacute;n&eacute;rer de mani&egrave;re performante les identifiants de type
                                <tt class="literal">long</tt>, <tt class="literal">short</tt> ou <tt class="literal">int</tt>,
                                en donnant une table et une colonne (par d&eacute;faut <tt class="literal">hibernate_unique_key</tt> et
                                <tt class="literal">next_hi</tt>) comme source des valeurs "hi". L'algorithme hi/lo 
                                g&eacute;n&egrave;re des identifiants qui sont uniques pour une base de donn&eacute;es donn&eacute;e. <span class="emphasis"><em>Ne pas
                                utiliser ce g&eacute;n&eacute;rateur avec des connexions li&eacute;es &agrave; JTA ou g&eacute;r&eacute;es par l'utilisateur.</em></span>
                            </p></dd><dt><span class="term"><tt class="literal">seqhilo</tt></span></dt><dd><p>
                                utilise l'algorithme hi/lo pour g&eacute;n&eacute;rer les identifiants de type
                                <tt class="literal">long</tt>, <tt class="literal">short</tt> ou <tt class="literal">int</tt>,
                                en donnant le nom d'une s&eacute;quence de base de donn&eacute;es.
                            </p></dd><dt><span class="term"><tt class="literal">uuid.hex</tt></span></dt><dd><p>
                                utilise l'algorithme &agrave; 128-bit UUID pour g&eacute;n&eacute;rer les identifiants de type string,
                                uniques sur un r&eacute;seau donn&eacute; (l'adresse IP est utilis&eacute;e). L'UUID est encod&eacute;e comme une cha&icirc;ne
				de 32 chiffres hexad&eacute;cimaux.
                            </p></dd><dt><span class="term"><tt class="literal">uuid.string</tt></span></dt><dd><p>
                                utilise le m&ecirc;me algorithme UUID. L'UUID est encod&eacute;e comme une chaine de 16
				caract&egrave;res ASCII (n'importe lequel). <span class="emphasis"><em>Ne pas utiliser avec PostgreSQL.</em></span>
                            </p></dd><dt><span class="term"><tt class="literal">native</tt></span></dt><dd><p>
                                choisit <tt class="literal">identity</tt>, <tt class="literal">sequence</tt> ou
                                <tt class="literal">hilo</tt> en fonction des possibilit&eacute;s de la base de donn&eacute;es.
                            </p></dd><dt><span class="term"><tt class="literal">assigned</tt></span></dt><dd><p>
                                laisse l'application assigner l'identifiant de l'objet avant l'appel &agrave;
                                <tt class="literal">save()</tt>.
                            </p></dd><dt><span class="term"><tt class="literal">foreign</tt></span></dt><dd><p>
                                utilise l'identifiant d'un autre objet associ&eacute;. G&eacute;n&eacute;ralement utilis&eacute; en conjonction
				d'une association <tt class="literal">&lt;one-to-one&gt;</tt> par cl&eacute; primaire.
                            </p></dd></dl></div><p>

                </p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-hilo"></a>5.1.4.2.&nbsp;Algorithme Hi/Lo</h4></div></div><div></div></div><p>
                    Les g&eacute;n&eacute;rateurs <tt class="literal">hilo</tt> et <tt class="literal">seqhilo</tt> fournissent deux impl&eacute;mentations
		    alternatives de l'algorithme hi/lo, une approche tr&egrave;s r&eacute;pandue pour la g&eacute;n&eacute;ration d'identifiant.
		    La premi&egrave;re impl&eacute;mentation n&eacute;cessite une table "sp&eacute;ciale" pour g&eacute;rer la prochaine valeur "hi".
		    La seconde utilise une s&eacute;quence de type Oracle (si support&eacute;e).
                </p><pre class="programlisting">&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="hilo"&gt;
                &lt;param name="table"&gt;hi_value&lt;/param&gt;
                &lt;param name="column"&gt;next_value&lt;/param&gt;
                &lt;param name="max_lo"&gt;100&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><pre class="programlisting">&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="seqhilo"&gt;
                &lt;param name="sequence"&gt;hi_value&lt;/param&gt;
                &lt;param name="max_lo"&gt;100&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><p>
                    Malheureusement, vous ne pouvez utiliser <tt class="literal">hilo</tt> lorsque vous fournissez
		    manuellement votre propre <tt class="literal">Connection</tt> &agrave; Hibernate, ou lorsqu'Hibernate 
		    utilise une datasource d'un serveur d'application enrol&eacute;e dans un contexte JTA. Hibernate doit &ecirc;tre
		    capable de r&eacute;cup&eacute;rer la valeur "hi" dans une nouvelle transaction (s&eacute;par&eacute;e de la transaction courante). 
            Une approche classique dans un environnement EJB est d'impl&eacute;menter l'algorithme hi/lo en utilisant 
            un session bean stateless.
                </p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-uuid"></a>5.1.4.3.&nbsp;UUID Algorithm</h4></div></div><div></div></div><p>
                    L'UUID contient : l'adresse IP, la date de d&eacute;marrage de la JVM (arrondie au quart
		    de seconde), la date syst&egrave;me et une valeur de compteur (unique pour une JVM). 
		    Il n'est pas possible d'obtenir l'adresse MAC ou l'adresse m&eacute;moire d'un code Java,
		    ceci est donc le mieux que l'on puisse faire sans utiliser JNI.
                </p><p>
                    N'essayez pas d'utiliser <tt class="literal">uuid.string</tt> dans PostgreSQL.
                </p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-sequences"></a>5.1.4.4.&nbsp;Colonne Identity et Sequences</h4></div></div><div></div></div><p>
                    Pour les bases de donn&eacute;es qui supportent les colonnes identity (DB2, MySQL, Sybase, SQL Server), vous
                    pouvez utiliser la g&eacute;n&eacute;ration de cl&eacute; <tt class="literal">identity</tt>. Pour les bases de donn&eacute;es qui
		    supportent les s&eacute;quences (DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB), vous pouvez
		    utiliser la g&eacute;n&eacute;ration de cl&eacute; de style <tt class="literal">sequence</tt>. Ces deux strat&eacute;gies
		    n&eacute;cessitent deux requ&ecirc;tes SQL pour ins&eacute;rer un nouvel objet.
                </p><pre class="programlisting">&lt;id name="id" type="long" column="uid"&gt;
        &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;uid_sequence&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><pre class="programlisting">&lt;id name="id" type="long" column="uid" unsaved-value="0"&gt;
        &lt;generator class="identity"/&gt;
&lt;/id&gt;</pre><p>
                    Pour le d&eacute;veloppement multi plate formes, la strat&eacute;gie <tt class="literal">native</tt>
		    choisira entre <tt class="literal">identity</tt>, <tt class="literal">sequence</tt> et
                    <tt class="literal">hilo</tt>, en fonction des possiblit&eacute;s de la base de donn&eacute;es utilis&eacute;e.
                </p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-assigned"></a>5.1.4.5.&nbsp;Identifiants assign&eacute;s</h4></div></div><div></div></div><p>
                    Si vous souhaitez que l'application assigne les identifiants (en opposition
		    &agrave; la g&eacute;n&eacute;ration faite par Hibernate), utilisez le g&eacute;n&eacute;rateur <tt class="literal">assigned</tt>.
                    Ce g&eacute;n&eacute;rateur sp&eacute;cial utilisera la valeur de l'identifiant d&eacute;j&agrave; assign&eacute; &agrave; la propri&eacute;t&eacute;
		    d'identifiant de l'objet. Attention lorsque vous utilisez cette possibilit&eacute;, il faut
		    utiliser des cl&eacute;s avec un sens m&eacute;tier (ce qui est toujours de design discutable).
                </p><p>
                    A cause de leur nature m&ecirc;me, les entit&eacute;s qui utilisent ce g&eacute;n&eacute;rateur ne peuvent &ecirc;tre
		    sauv&eacute;es via la m&eacute;thode saveOrUpdate de la session. Vous devez sp&eacute;cifier vous m&ecirc;me
		    si l'objet doit &ecirc;tre sauv&eacute; ou mis &agrave; jour en appelant soit <tt class="literal">save()</tt> 
		    soit <tt class="literal">update()</tt> sur la session.
                </p></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-compositeid"></a>5.1.5.&nbsp;composite-id</h3></div></div><div></div></div><pre class="programlisting">&lt;composite-id
        name="nomDePropriete"
        class="NomDeClasse"
        unsaved-value="any|none"
        access="field|property|NomdeClasse"&gt;

        &lt;key-property name="nomDePropriete" type="nomdetype" column="nom_de_colonne"/&gt;
        &lt;key-many-to-one name="NomDePropriete" class="NomDeClasse" column="nom_de_colonne"/&gt;
        ......
&lt;/composite-id&gt;</pre><p>
                Pour une table avec cl&eacute; compos&eacute;e, vous pouvez mapper plusieurs propri&eacute;t&eacute;s de la
		classe comme propri&eacute;t&eacute;s identifiantes. L'&eacute;l&eacute;ment <tt class="literal">&lt;composite-id&gt;</tt> 
                accepte des mappings de propri&eacute;t&eacute;s  via <tt class="literal">&lt;key-property&gt;</tt> et des mappings
		d'&eacute;l&eacute;ments fils via <tt class="literal">&lt;key-many-to-one&gt;</tt>.
            </p><pre class="programlisting">&lt;composite-id&gt;
        &lt;key-property name="medicareNumber"/&gt;
        &lt;key-property name="dependent"/&gt;
&lt;/composite-id&gt;</pre><p>
                Votre classe persistante <span class="emphasis"><em>doit</em></span> surcharger <tt class="literal">equals()</tt>
                et <tt class="literal">hashCode()</tt> pour impl&eacute;menter l'&eacute;galit&eacute; des identifiants compos&eacute;s. Elle
		doit aussi impl&eacute;menter <tt class="literal">Serializable</tt>.
            </p><p>
                Malheureusement, cette approche avec identifiant compos&eacute;e signifie qu'un objet persistant
		est son propre identifiant. Il n'y a pas d'autres "clients" potentiels que l'objet 
		persistant lui m&ecirc;me. Vous devez instancier une instance de la classe persistante,
		renseigner ses propri&eacute;t&eacute;s identifiantes avant de pouvoir charger (<tt class="literal">load()</tt>) l'&eacute;tat
		persistant associ&eacute; &agrave; la cl&eacute; compos&eacute;e. Nous d&eacute;crirons une m&eacute;thode plus pratique
		o&ugrave; la cl&eacute; compos&eacute;e est impl&eacute;ment&eacute;e dans une classe distincte dans <a href="#components-compositeid" title="7.4.&nbsp;composants en tant qu'identifiants compos&eacute;s">Section&nbsp;7.4, &laquo;&nbsp;composants en tant qu'identifiants compos&eacute;s&nbsp;&raquo;</a>. 
		Les attributs d&eacute;cris ci dessous s'appliquent uniquement &agrave; l'approche alternative:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        <tt class="literal">name</tt> (optionnel) : Une propri&eacute;t&eacute; de type composant qui contient
			l'identifiant compos&eacute; (voir section suivante).
                    </p></li><li><p>
                        <tt class="literal">class</tt> (optionnel - par d&eacute;faut = le type de la propri&eacute;t&eacute; d&eacute;termin&eacute; 
			par r&eacute;flexion) : La classe composant utilis&eacute;e comme identifiant compos&eacute; (voir section suivante).
                    </p></li><li><p>
                        <tt class="literal">unsaved-value</tt> (optionnel - par d&eacute;faut = <tt class="literal">none</tt>) : 
                        Indique qu'une instance transiante doit &ecirc;tre consid&eacute;r&eacute;e comme nouvellement instanci&eacute;e,
			si param&eacute;tr&eacute; &agrave; <tt class="literal">any</tt>.
                    </p></li></ul></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-discriminator"></a>5.1.6.&nbsp;discriminator</h3></div></div><div></div></div><p>
                L'&eacute;l&eacute;ment <tt class="literal">&lt;discriminator&gt;</tt> est requis pour la persistance polymorphique
		dans le cadre de la strat&eacute;gie de mapping "table par hi&eacute;rarchie de classe" (table-per-class-hierarchy)
		et sp&eacute;cifie une colonne discriminatrice de la table. La colonne discriminatrice contient une valeur
		qui indique &agrave; la couche de persistance quelle classe fille doit &ecirc;tre instanci&eacute;e pour un enregistrement
		particulier. Un ensemble restreint de types peut &ecirc;tre utilis&eacute; : 
                <tt class="literal">string</tt>, <tt class="literal">character</tt>, <tt class="literal">integer</tt>, 
                <tt class="literal">byte</tt>, <tt class="literal">short</tt>, <tt class="literal">boolean</tt>, 
                <tt class="literal">yes_no</tt>, <tt class="literal">true_false</tt>.
            </p><div class="programlistingco"><pre class="programlisting">&lt;discriminator
        column="colonne_du_discriminateur"       <span class="co">(1)</span>
        type="type_du_discriminateur"            <span class="co">(2)</span>
        force="true|false"                       <span class="co">(3)</span>
        insert="true|false"                      <span class="co">(4)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optionnel - par d&eacute;faut = <tt class="literal">class</tt>) : le nom
			    de la colonne discriminatrice.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optionnel - par d&eacute;faut = <tt class="literal">string</tt>) : un nom 
			    qui indique le type Hibernate
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">force</tt> (optionnel - par d&eacute;faut = <tt class="literal">false</tt>) : 
                            "force" Hibernate &agrave; sp&eacute;cifier les valeurs discriminatrices permises m&ecirc;me lorsque
			    toutes les instances de la classe "racine" sont r&eacute;cup&eacute;r&eacute;es.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">insert</tt> (optionnel - par d&eacute;faut = <tt class="literal">true</tt>) :
                            positionner le &agrave; <tt class="literal">false</tt> si votre colonne discriminatrice fait aussi
                            partie d'un identifiant compos&eacute; mapp&eacute;.
                        </p></td></tr></table></div></div><p>
                Les diff&eacute;rentes valeurs de la colonne discriminatrice sont sp&eacute;cifi&eacute;es par l'attribut
                <tt class="literal">discriminator-value</tt> des &eacute;l&eacute;ments <tt class="literal">&lt;class&gt;</tt> et
                <tt class="literal">&lt;subclass&gt;</tt>.
            </p><p>
                L'attribut <tt class="literal">force</tt> est utile si la table contient des lignes avec d'autres
		valeurs qui ne sont pas mapp&eacute;es &agrave; une classe persistante. Ce qui ne sera g&eacute;n&eacute;ralement pas le cas.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-version"></a>5.1.7.&nbsp;version (optionnel)</h3></div></div><div></div></div><p>
                L'&eacute;l&eacute;ment <tt class="literal">&lt;version&gt;</tt> est optionnel est indique que la table contient
		des donn&eacute;es versionn&eacute;es. Ceci est particuli&egrave;rement utile si vous pr&eacute;voyez d'utiliser des
		transations longues (voir plus loin).
            </p><div class="programlistingco"><pre class="programlisting">&lt;version
        column="colonne_de_version"                        <span class="co">(1)</span>
        name="nomDePropriete"                              <span class="co">(2)</span>
        type="nomdetype"                                   <span class="co">(3)</span>
        access="field|property|NomDeClasse"                <span class="co">(4)</span>
        unsaved-value="null|negative|undefined"            <span class="co">(5)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optionnel - par d&eacute;faut = le nom de la propri&eacute;t&eacute;) : Le nom
			    de la colonne contenant le num&eacute;ro de version.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> : Le nom de la propri&eacute;t&eacute; de classe persistante.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optionnel - par d&eacute;faut = <tt class="literal">integer</tt>) : 
                            Le type du num&eacute;ro de version.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optionnel - par d&eacute;faut = <tt class="literal">property</tt>) : La
			    strat&eacute;gie qu'Hibernate doit utiliser pour acc&eacute;der &agrave; la valeur de la propri&eacute;t&eacute;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">unsaved-value</tt> (optionnel - par d&eacute;faut =  <tt class="literal">undefined</tt>) : 
                            Une valeur de la propri&eacute;t&eacute; "version" qui indique qu'une instance est nouvellement instanci&eacute;e
			    (non sauvegard&eacute;e), qui la distingue des instances transiantes qui ont &eacute;t&eacute; charg&eacute;es ou
			    sauvegard&eacute;es dans une session pr&eacute;c&eacute;dente (<tt class="literal">undefined</tt> sp&eacute;cifie que la propri&eacute;t&eacute;
			    d'identifiant doit &ecirc;tre utilis&eacute;e).
                        </p></td></tr></table></div></div><p>
                Les num&eacute;ros de version peuvent &ecirc;tre de type <tt class="literal">long</tt>, <tt class="literal">integer</tt>,
                <tt class="literal">short</tt>, <tt class="literal">timestamp</tt> ou <tt class="literal">calendar</tt>.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-timestamp"></a>5.1.8.&nbsp;timestamp (optionnel)</h3></div></div><div></div></div><p>
                L'&eacute;l&eacute;ment optionnel <tt class="literal">&lt;timestamp&gt;</tt> indique que la table contient des donn&eacute;es
		"timestamp&eacute;es". C'est une alternative au versioning. Les timestamps sont par nature
                une impl&eacute;mentation moins s&ucirc;re du verrou optimiste. Cependant, l'application peut parfois
		utiliser les timestamps dans d'autres buts.
            </p><div class="programlistingco"><pre class="programlisting">&lt;timestamp
        column="colonne_de_timestamp"       <span class="co">(1)</span>
        name="nomDePropriete"               <span class="co">(2)</span>
        access="field|property|NomDeClasse" <span class="co">(3)</span>
        unsaved-value="null|undefined"      <span class="co">(4)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optionnel - par d&eacute;faut = le nom de la propri&eacute;t&eacute;) : Le nom
                            de la colonne contenant le timestamp.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: Le nom de la propri&eacute;t&eacute; de type  
			    Java <tt class="literal">Date</tt> ou <tt class="literal">Timestamp</tt> dans la classe
			    persistante.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optionnel - par d&eacute;faut =  <tt class="literal">property</tt>) : La
			    strat&eacute;gie qu'Hibernate doit utiliser pour acc&eacute;der &agrave; la propri&eacute;t&eacute;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">unsaved-value</tt> (optionnel - par d&eacute;faut = <tt class="literal">null</tt>) : 
 			    Une valeur de la propri&eacute;t&eacute; "version" qui indique qu'une instance est nouvellement instanci&eacute;e
			    (non sauvegard&eacute;e), qui la distingue des instances transiantes qui ont &eacute;t&eacute; charg&eacute;es ou
			    sauvegard&eacute;es dans une session pr&eacute;c&eacute;dente (<tt class="literal">undefined</tt> sp&eacute;cifie que la propri&eacute;t&eacute;
			    d'identifiant doit &ecirc;tre utilis&eacute;e).
                        </p></td></tr></table></div></div><p>
                Notez que <tt class="literal">&lt;timestamp&gt;</tt> est &eacute;quivalent &agrave; 
                <tt class="literal">&lt;version type="timestamp"&gt;</tt>.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-property"></a>5.1.9.&nbsp;property</h3></div></div><div></div></div><p>
                L'&eacute;l&eacute;ment <tt class="literal">&lt;property&gt;</tt> d&eacute;clare une propri&eacute;t&eacute; persistante de la classe, 
                respectant la convention JavaBean.
            </p><div class="programlistingco"><pre class="programlisting">&lt;property
        name="nomDePropriete"               <span class="co">(1)</span>
        column="nom_de_colonne"             <span class="co">(2)</span>
        type="nomdetype"                    <span class="co">(3)</span>
        update="true|false"                 <span class="co">(4)</span>
        insert="true|false"                 <span class="co">(4)</span>
        formula="expression SQL quelconque" <span class="co">(5)</span>
        access="field|property|NomDeClasse" <span class="co">(6)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> : Le nom de la propri&eacute;t&eacute;, l'initiale &eacute;tant en
			    minuscule (cf conventions JavaBean).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optionnel - par d&eacute;faut = le nom de la propri&eacute;t&eacute;) : le nom de la
			    colonne de base de donn&eacute;es mapp&eacute;e.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optionnel) : un nom indiquant le type Hibernate.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">update, insert</tt> (optionnel - par d&eacute;faut = <tt class="literal">true</tt>) :
                            sp&eacute;cifie que les colonnes mapp&eacute;es doivent &ecirc;tre incluses dans l'ordre SQL
			    <tt class="literal">UPDATE</tt> et/ou <tt class="literal">INSERT</tt>. Param&eacute;trer les deux &agrave;
			    <tt class="literal">false</tt> permet &agrave; la propri&eacute;t&eacute; d'&ecirc;tre "d&eacute;riv&eacute;e", sa valeur &eacute;tant 
			    initialis&eacute;e par une autre propri&eacute;t&eacute; qui mappe la(les) m&ecirc;me(s) colonne(s),
			    par un trigger ou par une autre application.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">formula</tt> (optionnel) : une expression SQL qui d&eacute;finit une valeur pour
			    une propri&eacute;t&eacute; <span class="emphasis"><em>calcul&eacute;e</em></span>. Les propri&eacute;t&eacute;s n'ont pas de colonne
			    mapp&eacute;e.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optionnel - par d&eacute;faut =  <tt class="literal">property</tt>) : La
			    strat&eacute;gie qu'Hibernate doit utiliser pour acc&eacute;der &agrave; la propri&eacute;t&eacute;.
                        </p></td></tr></table></div></div><p>
                <span class="emphasis"><em>typename</em></span> peut &ecirc;tre :
            </p><div class="orderedlist"><ol type="1" compact><li><p>
                        Le nom d'un type Hibernate basique (ex. <tt class="literal">integer, string, character,
                        date, timestamp, float, binary, serializable, object, blob</tt>).
                    </p></li><li><p>
                        Le nom d'une classe Java avec un type basique par d&eacute;faut (eg. <tt class="literal">int, float,
                        char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</tt>).
                    </p></li><li><p>
                        Le nom d'une classe fille de <tt class="literal">PersistentEnum</tt> (ex. <tt class="literal">eg.Color</tt>).
                    </p></li><li><p>
                        Le nom d'une classe Java serialisable.
                    </p></li><li><p>
                        Le nom d'une classe Java impl&eacute;mentant un type personnalis&eacute; (ex. <tt class="literal">com.illflow.type.MyCustomType</tt>).
                    </p></li></ol></div><p>
                Si vous ne sp&eacute;cifiez pas de type, Hibernate utilisera la r&eacute;flexion sur la propri&eacute;t&eacute;
		d&eacute;finie pour trouver la bonne correspondance avec le type Hibernate. Hibernate
		essaiera d'interpr&eacute;ter le nom de la classe retourn&eacute;e par le getter de la propri&eacute;t&eacute;
		en utilisant successivement les r&egrave;gles 2, 3, 4. Cependant, cela ne suffit pas toujours.
		Dans certains cas, vous aurez toujours besoin d'un attribut <tt class="literal">type</tt>
		(Par exemple, pour distinguer <tt class="literal">Hibernate.DATE</tt> de
                <tt class="literal">Hibernate.TIMESTAMP</tt>, ou pour sp&eacute;cifier un type personnalis&eacute;).
            </p><p>
            	L'attribut <tt class="literal">access</tt> vous permet de contr&ocirc;ler la mani&egrave;re avec
                laquelle Hibernate acc&egrave;de
		&agrave; la propri&eacute;t&eacute; &agrave; l'ex&eacute;cution. Par d&eacute;faut, Hibernate utilisera les accesseurs de l'attribut. 
        Si vous sp&eacute;cifiez <tt class="literal">access="field"</tt>, Hibernate court circuitera
		les accesseurs et acc&eacute;dera directement &agrave; l'attribut, en utilisant la r&eacute;flexion.
		Vous pouvez sp&eacute;cifier votre propre strat&eacute;gie en nommant une classe qui impl&eacute;mente
		l'interface <tt class="literal">net.sf.hibernate.property.PropertyAccessor</tt>.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-manytoone"></a>5.1.10.&nbsp;many-to-one</h3></div></div><div></div></div><p>
                Une association simple vers une autre classe persistante est d&eacute;clarable
		en utilisant un &eacute;l&eacute;ment <tt class="literal">many-to-one</tt>. Le mod&egrave;le
		relationnel est une association many-to-one (Il s'agit au sens propre de la 
		r&eacute;f&eacute;rence &agrave; un objet).
            </p><div class="programlistingco"><pre class="programlisting">&lt;many-to-one
        name="nomDePropriete"                              <span class="co">(1)</span>
        column="nom_de_colonne"                            <span class="co">(2)</span>
        class="NomDeClasse"                                <span class="co">(3)</span>
        cascade="all|none|save-update|delete"              <span class="co">(4)</span>
        outer-join="true|false|auto"                       <span class="co">(5)</span>
        update="true|false"                                <span class="co">(6)</span>
        insert="true|false"                                <span class="co">(6)</span>
        property-ref="nomDeProprieteDUneClasseAssociee"    <span class="co">(7)</span>
        access="field|property|NomDeClasse"                <span class="co">(8)</span>
        unique="true|false"                                <span class="co">(9)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> : Le nom de la propri&eacute;t&eacute;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optionnel) : Le nom de la colonne.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> (optionnel - par d&eacute;faut = au type de la propri&eacute;t&eacute;
			    d&eacute;termin&eacute; par r&eacute;flexion) : Le nom de la classe associ&eacute;e.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">cascade</tt> (optional) : Sp&eacute;cifie quelles op&eacute;rations
			    doivent &ecirc;tre effectu&eacute;es en cascade de l'objet parent vers l'objet
			    associ&eacute;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">outer-join</tt> (optionnel - par d&eacute;faut =  <tt class="literal">auto</tt>) : 
                            active le chargement par outer-join lorsque 
                            <tt class="literal">hibernate.use_outer_join</tt> est activ&eacute;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">update, insert</tt> (optionnel - par d&eacute;faut = <tt class="literal">true</tt>) :
                            sp&eacute;cifie que les colonnes mapp&eacute;es doivent &ecirc;tre incluses dans l'ordre SQL
			    <tt class="literal">UPDATE</tt> et/ou <tt class="literal">INSERT</tt>. Param&eacute;trer les deux &agrave;
			    <tt class="literal">false</tt> permet &agrave; la propri&eacute;t&eacute; d'&ecirc;tre "d&eacute;riv&eacute;e", sa valeur &eacute;tant 
			    initialis&eacute;e par une autre propri&eacute;t&eacute; qui mappe la(les) m&ecirc;me(s) colonne(s),
			    par un trigger ou par une autre application.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">property-ref</tt> : (optionnel) Le nom de la propri&eacute;t&eacute; de la classe
			    associ&eacute;e qui est li&eacute;e &agrave; cette cl&eacute; &eacute;trang&egrave;re. Si non sp&eacute;cifi&eacute;e, la cl&eacute; primaire
			    de la classe associ&eacute;e est utilis&eacute;e.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optionnel - par d&eacute;faut = <tt class="literal">property</tt>) : La
                            strat&eacute;gie qu'Hibernate doit utiliser pour acc&eacute;der &agrave; la valeur de la propri&eacute;t&eacute;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
				<tt class="literal">unique</tt> (optionnel) : Active la g&eacute;n&eacute;ration DDL d'une contrainte
				unique pour la colonne cl&eacute;-&eacute;trang&egrave;re.
			</p></td></tr></table></div></div><p>
                L'attribut <tt class="literal">cascade</tt> autorise les valeurs suivantes : 
                <tt class="literal">all</tt>, <tt class="literal">save-update</tt>, <tt class="literal">delete</tt>,
                <tt class="literal">none</tt>. Fixer une valeur diff&eacute;rente de <tt class="literal">none</tt>
                propagera certaines op&eacute;rations &agrave; l'objet (fils) associ&eacute;. Voir "Cycle de vie de
		l'objet" ci dessous.
            </p><p>
                L'attribut <tt class="literal">outer-join</tt> accepte trois valeurs diff&eacute;rentes :
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        <tt class="literal">auto</tt> (par d&eacute;faut) : Charge l'association en utilisant une
			jointure ouverte si la classe associ&eacute;e n'a pas de proxy.
                    </p></li><li><p>
                        <tt class="literal">true</tt> : Charge toujours l'association en utilisant une 
                        jointure ouverte.
                    </p></li><li><p>
                        <tt class="literal">false</tt> : Ne charge jamais l'association en utilisant une
                        jointure ouverte.
                    </p></li></ul></div><p>
                Une d&eacute;claration typique de <tt class="literal">many-to-one</tt> est aussi simple que
            </p><pre class="programlisting">&lt;many-to-one name="product" class="Product" column="PRODUCT_ID"/&gt;</pre><p>
                L'attribut <tt class="literal">property-ref</tt> ne devrait &ecirc;tre utilis&eacute; que pour mapper des donn&eacute;es
		d'un syst&egrave;me h&eacute;rit&eacute; (lecagy system) o&ugrave; une cl&eacute; &eacute;trang&egrave;re fait r&eacute;f&eacute;rence &agrave; une autre cl&eacute; unique de la table associ&eacute;e.
		Ce genre de mod&egrave;le relationnel peut &ecirc;tre qualifi&eacute; de... laid. Par example, supposez que la classe <tt class="literal">Product</tt> 
		a un num&eacute;ro de s&eacute;rie unique, qui n'est pas la cl&eacute; primaire (L'attribut <tt class="literal">unique</tt>
		contr&ocirc;le la g&eacute;n&eacute;ration DDL d'Hibernate avec l'outil SchemaExport).
            </p><pre class="programlisting">&lt;property name="serialNumber" unique="true" type="string" column="SERIAL_NUMBER"/&gt;</pre><p>
                Voici le mapping que <tt class="literal">OrderItem</tt> pourrait utiliser:
            </p><pre class="programlisting">&lt;many-to-one name="product" property-ref="serialNumber" column="PRODUCT_SERIAL_NUMBER"/&gt;</pre><p>
                Cela n'est clairement pas encourag&eacute;.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-onetoone"></a>5.1.11.&nbsp;one-to-one</h3></div></div><div></div></div><p>
                Une association one-to-one vers une autre classe persistante est d&eacute;clar&eacute;e en utilisant
		un &eacute;l&eacute;ment <tt class="literal">one-to-one</tt>.
            </p><div class="programlistingco"><pre class="programlisting">&lt;one-to-one
        name="nomDePropriete"                              <span class="co">(1)</span>
        class="NomDeClasse"                                <span class="co">(2)</span>
        cascade="all|none|save-update|delete"              <span class="co">(3)</span>
        constrained="true|false"                           <span class="co">(4)</span>
        outer-join="true|false|auto"                       <span class="co">(5)</span>
        property-ref="nomDeProprieteDUneClasseAssociee"    <span class="co">(6)</span>
        access="field|property|NomDeClasse"                <span class="co">(7)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> : Le nom de la propri&eacute;t&eacute;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> (optionnel - par d&eacute;faut = le type de la propri&eacute;t&eacute;
			    d&eacute;termin&eacute;e par r&eacute;flexion) : le nom de la classe associ&eacute;e.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">cascade</tt> (optionnel) : sp&eacute;cifie quelles op&eacute;rations doivent
			    &ecirc;tre r&eacute;alis&eacute;es en cascade de l'objet parent vers l'objet associ&eacute;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">constrained</tt> : (optionnel) sp&eacute;cifie qu'une contrainte sur la cl&eacute;
			    primaire de la table mapp&eacute;e fait r&eacute;f&eacute;rence &agrave; la table de la classe associ&eacute;e.
			    Cette option affecte l'ordre dans lequel <tt class="literal">save()</tt> et
                            <tt class="literal">delete()</tt> sont effectu&eacute;s en cascade (elle est aussi utilis&eacute;e dans
			    l'outil schema export).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">outer-join</tt> (optionnel - par d&eacute;faut = <tt class="literal">auto</tt>) : 
                            Active le chargement par jointure ouverte de l'association lorsque
                            <tt class="literal">hibernate.use_outer_join</tt> est activ&eacute;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">property-ref</tt>: (optionnel) : Le nom de la propri&eacute;t&eacute; de la classe
			    associ&eacute;e qui est li&eacute;e &agrave; cette cl&eacute; &eacute;trang&egrave;re. Si non sp&eacute;cifi&eacute;, la cl&eacute; primaire
			    de la classe associ&eacute;e est utilis&eacute;e.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optionnel - par d&eacute;faut = <tt class="literal">property</tt>) : La
                            strat&eacute;gie qu'Hibernate doit utiliser pour acc&eacute;der &agrave; la valeur de la propri&eacute;t&eacute;.
                        </p></td></tr></table></div></div><p>
                Il y a deux types d'association one-to-one:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                les associations sur cl&eacute; primaire
            </p></li><li><p>
                les associations sur cl&eacute; &eacute;trang&egrave;re unique
            </p></li></ul></div><p>
                Les associations sur cl&eacute; primaire ne n&eacute;cessitent pas de colonne suppl&eacute;mentaire dans la
		table ; si deux enregistrements sont li&eacute;s par l'association alors les deux enregistrements
		partagent la m&ecirc;me valeur de cl&eacute; primaire. Ainsi, si vous souhaitez que deux objets soient
		li&eacute;s par association sur cl&eacute; primaire, vous devez vous assurer qu'ils aient la
		m&ecirc;me valeur d'identifiant !
            </p><p>
                Pour une association par cl&eacute; primaire, ajoutez les mappings suivant &agrave; <tt class="literal">Employee</tt> 
		et <tt class="literal">Person</tt>, respectivement:
            </p><pre class="programlisting">&lt;one-to-one name="person" class="Person"/&gt;</pre><pre class="programlisting">&lt;one-to-one name="employee" class="Employee" constrained="true"/&gt;</pre><p>
                Assurez vous que les cl&eacute;s primaires des lignes associ&eacute;es dans les tables PERSON et
		EMPLOYEE sont &eacute;gales. Nous utilisons, dans ce cas, une strat&eacute;gie de g&eacute;n&eacute;ration
		d'identifiant Hibernate sp&eacute;ciale, appel&eacute;e <tt class="literal">foreign</tt>:
            </p><pre class="programlisting">&lt;class name="person" table="PERSON"&gt;
    &lt;id name="id" column="PERSON_ID"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"&gt;employee&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    ...
    &lt;one-to-one name="employee"
        class="Employee"
        constrained="true"/&gt;
&lt;/class&gt;</pre><p>
                Une nouvelle instance de <tt class="literal">Person</tt> voit alors son identifiant 
                assign&eacute; &agrave; la m&ecirc;me valeur de cl&eacute; primaire
		que l'instance d'<tt class="literal">Employee</tt> r&eacute;f&eacute;renc&eacute;e par la propri&eacute;t&eacute; <tt class="literal">employee</tt>
                de cette <tt class="literal">Person</tt>.
            </p><p>
                Par ailleurs, une cl&eacute; &eacute;trang&egrave;re avec une contrainte d'unicit&eacute;, d'<tt class="literal">Employee</tt> vers 
                <tt class="literal">Person</tt>, peut etre d&eacute;clar&eacute;e comme :
            </p><pre class="programlisting">&lt;many-to-one name="person" class="Person" column="PERSON_ID" unique="true"/&gt;</pre><p>
                Et cette association peut &ecirc;tre bidirectionnelle en ajoutant ceci dans le mapping
		de <tt class="literal">Person</tt>:
            </p><pre class="programlisting">&lt;one-to-one name"employee" class="Employee" property-ref="person"/&gt;</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-component"></a>5.1.12.&nbsp;component, dynamic-component</h3></div></div><div></div></div><p>
                L'&eacute;l&eacute;ment <tt class="literal">&lt;component&gt;</tt> mappe des propri&eacute;t&eacute;s d'un objet 
		fils &agrave; des colonnes de la table de la classe parent. Les composants peuvent eux aussi
		d&eacute;clarer leurs propres propri&eacute;t&eacute;s, composants ou collections. Voir "Components" plus tard.
            </p><div class="programlistingco"><pre class="programlisting">&lt;component 
        name="nomDePropriete"               <span class="co">(1)</span>
        class="NomDeClasse"                 <span class="co">(2)</span>
        insert="true|false"                 <span class="co">(3)</span>
        upate="true|false"                  <span class="co">(4)</span>
        access="field|property|NomDeCLasse"&gt;<span class="co">(5)</span>
        
        &lt;property ...../&gt;
        &lt;many-to-one .... /&gt;
        ........
&lt;/component&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: Le nom de la propri&eacute;t&eacute;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
				<tt class="literal">class</tt> (optionnel - par d&eacute;faut = le type de la propri&eacute;t&eacute; d&eacute;termin&eacute; 
				par r&eacute;flexion) : Le nom de la classe du composant (fils).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">insert</tt> : Est ce que la colonne mapp&eacute;e apparait dans 
                            l'<tt class="literal">INSERT</tt> SQL?
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">update</tt> : Est ce que la colonne mapp&eacute;e apparait dans 
                            l'<tt class="literal">UPDATE</tt> SQL?
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optionnel - par d&eacute;faut = <tt class="literal">property</tt>) : La
                            strat&eacute;gie qu'Hibernate doit utiliser pour acc&eacute;der &agrave; la valeur de la propri&eacute;t&eacute;.
                        </p></td></tr></table></div></div><p>
                Les tags <tt class="literal">&lt;property&gt;</tt> fils mappent les propri&eacute;t&eacute;s de la classe fille
		aux colonnes de la table.
            </p><p>
                L'&eacute;l&eacute;ment <tt class="literal">&lt;component&gt;</tt> accepte un sous &eacute;l&eacute;ment <tt class="literal">&lt;parent&gt;</tt>
                qui mappe une propri&eacute;t&eacute; du composant comme r&eacute;f&eacute;rence vers l'entit&eacute; contenante.
            </p><p>
                L'&eacute;l&eacute;ment <tt class="literal">&lt;dynamic-component&gt;</tt> accepte qu'une <tt class="literal">Map</tt> soit
		mapp&eacute;e comme un composant, o&ugrave; les noms des propri&eacute;t&eacute;s font r&eacute;f&eacute;rence aux cl&eacute;s de la map.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-subclass"></a>5.1.13.&nbsp;subclass</h3></div></div><div></div></div><p>
                Enfin, les requ&ecirc;tes polymorphiques n&eacute;cessitent une d&eacute;claration explicite 
                de chaque classe h&eacute;rit&eacute;e de la classe racine. Pour la strat&eacute;gie de mapping (recommand&eacute;e) 
		table par hi&eacute;rarchie de classes (table-per-class-hierarchy), la d&eacute;claration <tt class="literal">&lt;subclass&gt;</tt> est
		utilis&eacute;e.
            </p><div class="programlistingco"><pre class="programlisting">&lt;subclass
        name="NomDeClasse"                            <span class="co">(1)</span>
        discriminator-value="valeur_de_discriminant"  <span class="co">(2)</span>
        proxy="InterfaceDeProxy"                      <span class="co">(3)</span>
        lazy="true|false"                             <span class="co">(4)</span>
        dynamic-update="true|false"
        dynamic-insert="true|false"&gt;

        &lt;property .... /&gt;
        .....
&lt;/subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> : Le nom complet de la classe fille.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">discriminator-value</tt> (optionnel - par d&eacute;faut le nom de la classe) : Une
			    valeur qui permet de distinguer individuellement les classes filles.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">proxy</tt> (optionnel) : Sp&eacute;cifie une classe ou une interface &agrave; utiliser
			    pour le chargement tardif par proxies.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optionnel) : Param&eacute;ter <tt class="literal">lazy="true"</tt> est &eacute;quivalent
			    &agrave; d&eacute;finir la classe elle-m&ecirc;me comme &eacute;tant son interface de <tt class="literal">proxy</tt>.
                        </p></td></tr></table></div></div><p>
                Chaque classe fille peut d&eacute;clarer ses propres propri&eacute;t&eacute;s persistantes et
		classes filles. Les propri&eacute;t&eacute;s <tt class="literal">&lt;version&gt;</tt> et <tt class="literal">&lt;id&gt;</tt> 
		sont suppos&eacute;es &ecirc;tre h&eacute;rit&eacute;es de la classe racine. Chaque classe fille dans la
		hi&eacute;rarchie doit d&eacute;finir une <tt class="literal">discriminator-value</tt> unique. Si aucune
		n'est sp&eacute;cifi&eacute;e, le nom complet de la classe java est utilis&eacute;.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-joinedsubclass"></a>5.1.14.&nbsp;joined-subclass</h3></div></div><div></div></div><p>
                D'autre part, une classe fille qui est persist&eacute;e dans sa propre table (strat&eacute;gie
		de mapping table par sous-classe - table-per-subclass) est d&eacute;clar&eacute;e en utilisant un &eacute;l&eacute;ment
		<tt class="literal">&lt;joined-subclass&gt;</tt>.
            </p><div class="programlistingco"><pre class="programlisting">&lt;joined-subclass
        name="NomDeClasse"                  <span class="co">(1)</span>
        proxy="InterfaceDeProxy"            <span class="co">(2)</span>
        lazy="true|false"                   <span class="co">(3)</span>
        dynamic-update="true|false"
        dynamic-insert="true|false"&gt;

        &lt;key .... &gt;

        &lt;property .... /&gt;
        .....
&lt;/subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> : Le nom complet de la classe fille.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">proxy</tt> (optionnel) : Sp&eacute;cifie une classe ou interface &agrave; utiliser
			    pour le chargement tardif par proxy.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optionnel) : Fixer la valeur &agrave; <tt class="literal">lazy="true"</tt> est &eacute;quivalent
			    &agrave; sp&eacute;cifier le nom de la classe comme &eacute;tant l'interface de <tt class="literal">proxy</tt>.
                        </p></td></tr></table></div></div><p>
                Il n'y a pas de colonne discriminante pour cette strat&eacute;gie de mapping. Chaque classe fille
		doit, cependant, d&eacute;clarer une colonne de table contenant l'identifiant de l'objet
		en utilisant l'&eacute;l&eacute;ment <tt class="literal">&lt;key&gt;</tt>. Le mapping &eacute;crit en d&eacute;but de chapitre
		serait r&eacute;&eacute;crit comme:
            </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

        &lt;class name="Cat" table="CATS"&gt;
                &lt;id name="id" column="uid" type="long"&gt;
                        &lt;generator class="hilo"/&gt;
                &lt;/id&gt;
                &lt;property name="birthdate" type="date"/&gt;
                &lt;property name="color" not-null="true"/&gt;
                &lt;property name="sex" not-null="true"/&gt;
                &lt;property name="weight"/&gt;
                &lt;many-to-one name="mate"/&gt;
                &lt;set name="kittens"&gt;
                        &lt;key column="MOTHER"/&gt;
                        &lt;one-to-many class="Cat"/&gt;
                &lt;/set&gt;
                &lt;joined-subclass name="DomesticCat" table="DOMESTIC_CATS"&gt;
                	&lt;key column="CAT"/&gt;
                        &lt;property name="name" type="string"/&gt;
                &lt;/joined-subclass&gt;
        &lt;/class&gt;

        &lt;class name="eg.Dog"&gt;
                &lt;!-- le mapping de Dog pourrait &ecirc;tre ici --&gt;
        &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-collections"></a>5.1.15.&nbsp;map, set, list, bag</h3></div></div><div></div></div><p>
                Les collections sont d&eacute;crites plus loin.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-import"></a>5.1.16.&nbsp;import</h3></div></div><div></div></div><p>
                Supposez que votre application poss&egrave;de deux classes persistantes avec le m&ecirc;me nom et que vous ne
		souhaitiez pas sp&eacute;cifier le nom qualifi&eacute; (package) dans les requ&ecirc;tes Hibernate. Les classes
		peuvent &ecirc;tre import&eacute;es explicitement, plut&ocirc;t que de compter sur <tt class="literal">auto-import="true"</tt>. 
		Vous pouvez m&ecirc;me importer les classes qui ne sont pas explicitement mapp&eacute;es.
            </p><pre class="programlisting">&lt;import class="java.lang.Object" rename="Universe"/&gt;</pre><div class="programlistingco"><pre class="programlisting">&lt;import
        class="NomDeClasse"            <span class="co">(1)</span>
        rename="Alias"                 <span class="co">(2)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> : Le nom complet de n'importe quelle classe.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">rename</tt> (optionnel - par d&eacute;faut = le nom de la classe sans son package) :
			    Un nom pouvant servir dans le langage de requ&ecirc;te.
                        </p></td></tr></table></div></div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-types"></a>5.2.&nbsp;Types Hibernate</h2></div></div><div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-entitiesvalues"></a>5.2.1.&nbsp;Entit&eacute;s et valeurs</h3></div></div><div></div></div><p>
                Pour comprendre le comportement des diff&eacute;rents objets (au sens java), dans le contexte
		d'un service de persistance, nous devons les s&eacute;parer en deux groupes :
            </p><p>
                Une <span class="emphasis"><em>entit&eacute;</em></span> existe ind&eacute;pendamment de n'importe quel objet contenant une 
		r&eacute;f&eacute;rence &agrave; l'entit&eacute;. Ceci est contradictoire avec le mod&egrave;le java habituel o&ugrave; un objet non
		r&eacute;f&eacute;renc&eacute; est un candidat pour le garbage collector. Les entit&eacute;s peuvent &ecirc;tre explicitement sauv&eacute;es
		et effac&eacute;es (&agrave; l'exception que la sauvegarde et l'effacement peuvent &ecirc;tre fait en cascade
		d'un objet parent vers ses enfants). C'est diff&eacute;rent du mod&egrave;le ODMG de persistance par atteignabilit&eacute;
		- et correspond plus g&eacute;n&eacute;ralement &agrave; la fa&ccedil;on d'utiliser les objets dans les grands syst&egrave;mes.
		Les entit&eacute;s supportent les r&eacute;f&eacute;rences partag&eacute;es et circulaires. Elles peuvent aussi &ecirc;tre
		versionn&eacute;es.
            </p><p>
                Un &eacute;tat persistant d'une entit&eacute; est constitu&eacute; de r&eacute;f&eacute;rences vers d'autres entit&eacute;s et instances
		de types <span class="emphasis"><em>valeur</em></span>. Les valeurs sont des types primitifs, des collections,
		des composants et certains objets immuables. Contrairement aux entit&eacute;s, les valeurs (sp&eacute;cialement
		les collections et les composants) sont persist&eacute;es et supprim&eacute;es par atteignabilit&eacute;. Puisque les
		objets de type valeur (et primitifs) sont persist&eacute;s et effac&eacute;s avec les entit&eacute;s qui les
		contiennent, ils ne peuvent pas &ecirc;tre versionn&eacute;s ind&eacute;pendamment. Les valeurs n'ont pas d'identifiant
		ind&eacute;pendant, elles ne peuvent donc pas &ecirc;tre partag&eacute;es entre deux entit&eacute;s ou collections.		
            </p><p>
                Tous les types Hibernate, &agrave; l'exception des collections, supportent la s&eacute;mantique null.
            </p><p>
                Jusqu'&agrave; pr&eacute;sent, nous avons utilis&eacute; le terme "classes persistantes" pour faire r&eacute;f&eacute;rence
		aux entit&eacute;s. Nous allons continuer de le faire. Cependant, dans l'absolu, toutes les
		classes persistantes d&eacute;finies par un utilisateur, et ayant un &eacute;tat persistant, ne sont
		pas des entit&eacute;s. Un <span class="emphasis"><em>composant</em></span> est une classe d&eacute;finie par l'utilisateur
		avec la s&eacute;mantique d'une valeur.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-basictypes"></a>5.2.2.&nbsp;Les types de valeurs basiques</h3></div></div><div></div></div><p>
                Les <span class="emphasis"><em>types basiques</em></span> peuvent etre grossi&egrave;rement s&eacute;par&eacute;s en

                </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">integer, long, short, float, double, character, byte,
                            boolean, yes_no, true_false</tt></span></dt><dd><p>
                                Les types effectuant le mapping entre des types primitifs Java 
                (ou leur classes d'encapsulation) et les types de colonnes SQL appropri&eacute;s 
                (sp&eacute;cifique au vendeur).
				<tt class="literal">boolean, yes_no</tt> et <tt class="literal">true_false</tt> 
				sont des encodages possibles pour les <tt class="literal">boolean</tt> Java
				ou <tt class="literal">java.lang.Boolean</tt>, sa classe encapsulante.
                            </p></dd><dt><span class="term"><tt class="literal">string</tt></span></dt><dd><p>
                                Un type effectuant le mapping entre <tt class="literal">java.lang.String</tt> et
                                <tt class="literal">VARCHAR</tt> (ou <tt class="literal">VARCHAR2</tt> pour Oracle).
                            </p></dd><dt><span class="term"><tt class="literal">date, time, timestamp</tt></span></dt><dd><p>
                                Des types effectuant le mapping entre <tt class="literal">java.util.Date</tt> 
                                (et ses classes filles) 
                                et  les types SQL <tt class="literal">DATE</tt>, <tt class="literal">TIME</tt> et
                                <tt class="literal">TIMESTAMP</tt> (ou &eacute;quivalent).
                            </p></dd><dt><span class="term"><tt class="literal">calendar, calendar_date</tt></span></dt><dd><p>
                                Des types effectuant le mapping entre <tt class="literal">java.util.Calendar</tt> et
                                les types SQL <tt class="literal">TIMESTAMP</tt> et <tt class="literal">DATE</tt>
                                (ou &eacute;quivalent).
                            </p></dd><dt><span class="term"><tt class="literal">big_decimal</tt></span></dt><dd><p>
                                Un type effectuant le mapping entr <tt class="literal">java.math.BigDecimal</tt> et
                                <tt class="literal">NUMERIC</tt> (ou <tt class="literal">NUMBER</tt> pour Oracle).
                            </p></dd><dt><span class="term"><tt class="literal">locale, timezone, currency</tt></span></dt><dd><p>
                                Des types effetuant le mapping entre d'une part
                                <tt class="literal">java.util.Locale</tt>,
                                <tt class="literal">java.util.TimeZone</tt> et 
                                <tt class="literal">java.util.Currency</tt> 
                                et d'autre part <tt class="literal">VARCHAR</tt> (ou 
                                <tt class="literal">VARCHAR2</tt> pour Oracle).
                                Les instances de <tt class="literal">Locale</tt> et <tt class="literal">Currency</tt> sont 
                                mapp&eacute;es &agrave; leurs codes ISO. Les instances de <tt class="literal">TimeZone</tt> sont
                                mapp&eacute;es &agrave; leur <tt class="literal">ID</tt>. 
                            </p></dd><dt><span class="term"><tt class="literal">class</tt></span></dt><dd><p>
                                Un type effectuant le mapping entre <tt class="literal">java.lang.Class</tt> et
                                <tt class="literal">VARCHAR</tt> (ou <tt class="literal">VARCHAR2</tt> pour Oracle).
                                Une <tt class="literal">Class</tt> est mapp&eacute;e &agrave; son nom enti&egrave;rement qualifi&eacute;.
                            </p></dd><dt><span class="term"><tt class="literal">binary</tt></span></dt><dd><p>
                                Mappe un tableau de byte vers un type binaire SQL appropri&eacute;.
                            </p></dd><dt><span class="term"><tt class="literal">text</tt></span></dt><dd><p>
                                Mappe de longues cha&icirc;nes Java vers un type SQL <tt class="literal">CLOB</tt> 
                                ou <tt class="literal">TEXT</tt>.
                            </p></dd><dt><span class="term"><tt class="literal">serializable</tt></span></dt><dd><p>
                                Mappe les types java s&eacute;rialisables vers un type binaire SQL appropri&eacute;. 
				Vous pouvez aussi indiquer le type Hibernate <tt class="literal">serializable</tt>
				avec le nom de la classe java s&eacute;rialisable ou d'une interface qui ne fait
				ni r&eacute;f&eacute;rence &agrave; un type basique ni n'impl&eacute;mente <tt class="literal">PersistentEnum</tt>.
                            </p></dd><dt><span class="term"><tt class="literal">clob, blob</tt></span></dt><dd><p>
                                Mappe les types de classes JDBC <tt class="literal">java.sql.Clob</tt> et
                                <tt class="literal">java.sql.Blob</tt>. Ces types peuvent &ecirc;tre inopportun 
				pour certaines applications, dans la mesure o&ugrave; les objets blob et clob ne peuvent
				&ecirc;tre r&eacute;utilis&eacute;s en dehors d'une transaction (de plus, le support des drivers
				est plut&ocirc;t in&eacute;gal et imparfait).
                            </p></dd></dl></div><p>
            
            </p><p>
                Les identifiants des entit&eacute;s et collections peuvent &ecirc;tre de tout type basique except&eacute;
                <tt class="literal">binary</tt>, <tt class="literal">blob</tt> and <tt class="literal">clob</tt> 
                (Les identifiants compos&eacute;s sont aussi admis, voir plus loin).
            </p><p>
                Les types de valeurs basiques ont des contantes <tt class="literal">Type</tt> correspondant dans
                <tt class="literal">net.sf.hibernate.Hibernate</tt>. Par exemple, <tt class="literal">Hibernate.STRING</tt>
                repr&eacute;sente le type <tt class="literal">string</tt>.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-enum"></a>5.2.3.&nbsp;Type persistant d'enum&eacute;ration</h3></div></div><div></div></div><p>
                Un type <span class="emphasis"><em>enum</em></span> est un concept java classique o&ugrave; une classe contient un
		(petit) nombre constant d'instances immuables. Vous pouvez cr&eacute;er un type enum en
		impl&eacute;mentant <tt class="literal">net.sf.hibernate.PersistentEnum</tt>,
                d&eacute;finissant les op&eacute;rations <tt class="literal">toInt()</tt> et <tt class="literal">fromInt()</tt> :
            </p><pre class="programlisting">package eg;
import net.sf.hibernate.PersistentEnum;

public class Color implements PersistentEnum {
    private final int code;
    private Color(int code) {
        this.code = code;
    }
    public static final Color TABBY = new Color(0);
    public static final Color GINGER = new Color(1);
    public static final Color BLACK = new Color(2);

    public int toInt() { return code; }

    public static Color fromInt(int code) {
        switch (code) {
            case 0: return TABBY;
            case 1: return GINGER;
            case 2: return BLACK;
            default: throw new RuntimeException("Unknown color code");
        }
    }
}</pre><p>
                Le nom du type Hibernate est simplement le nom de la classe &eacute;num&eacute;r&eacute;e, dans
                le cas pr&eacute;sent <tt class="literal">eg.Color</tt>.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-custom"></a>5.2.4.&nbsp;Types de valeurs personnalis&eacute;s</h3></div></div><div></div></div><p>
                Il est relativement facile pour les d&eacute;veloppeurs de cr&eacute;er leurs propres types de valeurs.
		Par exemple, vous voulez persister des propri&eacute;t&eacute;s du type <tt class="literal">java.lang.BigInteger</tt>
                vers des colonnes <tt class="literal">VARCHAR</tt>. Hibernate ne fournit pas nativement un type
		pour cela. Les types personnalis&eacute;s ne sont pas restreints &agrave; mapper une propri&eacute;t&eacute;
		(ou un &eacute;l&eacute;ment de collection) &agrave; une simple colonne de table. Vous pouvez, par exemple,
		avoir une propri&eacute;t&eacute; Java <tt class="literal">getName()</tt>/<tt class="literal">setName()</tt> de type
                <tt class="literal">java.lang.String</tt> qui est persist&eacute;e dans les colonnes 
                <tt class="literal">FIRST_NAME</tt>, <tt class="literal">INITIAL</tt>, <tt class="literal">SURNAME</tt>. 
            </p><p>
                Pour impl&eacute;menter un type personnalis&eacute;, impl&eacute;mentez soit <tt class="literal">net.sf.hibernate.UserType</tt>, 
                ou <tt class="literal">net.sf.hibernate.CompositeUserType</tt> et d&eacute;clarer, dans les propri&eacute;t&eacute;s l'utilisant,
		le nom complet (avec package) de la classe dans l'&eacute;lement type. Voir 
                <tt class="literal">net.sf.hibernate.test.DoubleStringType</tt> pour comprendre ce qu'il
                est possible de faire.
            </p><pre class="programlisting">&lt;property name="twoStrings" type="net.sf.hibernate.test.DoubleStringType"&gt;
    &lt;column name="first_string"/&gt;
    &lt;column name="second_string"/&gt;
&lt;/property&gt;</pre><p>
                Notez l'utilisation des tags <tt class="literal">&lt;column&gt;</tt> pour mapper vers plusieurs
		colonnes.
            </p><p>
                Hibernate fournit un large &eacute;ventail de types natifs et supporte les composants, vous ne 
		devrez avoir besoin d'un type personnalis&eacute; que dans de rares cas. N&eacute;anmoins, il est bon
		d'utiliser les types personnalis&eacute;s pour des classes (non-entit&eacute;) qui reviennent souvent dans
		votre application. Par exemple une classe <tt class="literal">MonetoryAmount</tt> est un bon 
		candidat pour un <tt class="literal">CompositeUserType</tt>, puisqu'elle pourrait facilement
		&ecirc;tre mapp&eacute;e comme composant. Un des arguments en faveur de ce choix  est l'abstraction. 
        Avec les types personnalis&eacute;s
		vos documents de mappings n'auraient pas &agrave; &ecirc;tre modifi&eacute;s lors de possibles modifications 
        sur la d&eacute;finition des valeurs mon&eacute;taires.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-anymapping"></a>5.2.5.&nbsp;Type de mappings "Any"</h3></div></div><div></div></div><p>
                Il y a un dernier type de mapping de propri&eacute;t&eacute;. L'&eacute;l&eacute;ment <tt class="literal">&lt;any&gt;</tt> d&eacute;finit 
                une association polymorphique vers des classes de plusieurs tables. Ce type de mapping demande
		toujours plus d'une colonne. La premi&egrave;re colonne contient le type de l'entit&eacute; associ&eacute;e. Les
		colonnes restantes contiennent l'identifiant. Il est impossible de sp&eacute;cifier une contrainte de
		cl&eacute; &eacute;trang&egrave;re pour ce type d'association, il ne faut donc pas retenir cette option comme un
		moyen usuel de mapper des associations polymorphiques. Vous ne devez utiliser ceci que dans 
		des cas tr&egrave;s sp&eacute;cifiques (audit logs, donn&eacute;es de session utilisateur, etc).
            </p><pre class="programlisting">&lt;any name="anyEntity" id-type="long" meta-type="eg.custom.Class2TablenameType"&gt;
    &lt;column name="table_name"/&gt;
    &lt;column name="id"/&gt;
&lt;/any&gt;</pre><p>
                 L'attribut <tt class="literal">meta-type</tt> laisse l'application sp&eacute;cifier un type personnalis&eacute;
		 qui mappe les valeurs des colonnes de base de donn&eacute;es &agrave; des classes persistances qui ont comme
         type de propri&eacute;t&eacute; d'identifiant le type sp&eacute;cifi&eacute; par <tt class="literal">id-type</tt>. Si le meta-type retourne
		 une instance de <tt class="literal">java.lang.Class</tt>, rien d'autre n'est requis. Mais si meta-id fait 
         r&eacute;f&eacute;rence &agrave; un type basique comme <tt class="literal">string</tt> ou <tt class="literal">character</tt>, 
		 vous devez sp&eacute;cifier explicitement le mapping entre les valeurs et les classes.
            </p><pre class="programlisting">&lt;any name="anyEntity" id-type="long" meta-type="string"&gt;
    &lt;meta-value value="TBL_ANIMAL" class="Animal"/&gt;
    &lt;meta-value value="TBL_HUMAN" class="Human"/&gt;
    &lt;meta-value value="TBL_ALIEN" class="Alien"/&gt;
    &lt;column name="table_name"/&gt;
    &lt;column name="id"/&gt;
&lt;/any&gt;</pre><div class="programlistingco"><pre class="programlisting">&lt;any
        name="nomDepropriete"                    <span class="co">(1)</span>
        id-type="nomdutypedidentifiant"          <span class="co">(2)</span>
        meta-type="nomdumetatype"                <span class="co">(3)</span>
        cascade="none|all|save-update"           <span class="co">(4)</span>
        access="field|property|NomDeClasse"      <span class="co">(5)</span>
&gt;
        &lt;meta-value ... /&gt;
        &lt;meta-value ... /&gt;
        .....
        &lt;column .... /&gt;
        &lt;column .... /&gt;
        .....
&lt;/any&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> : le nom de la propri&eacute;t&eacute;.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">id-type</tt> : le type de l'identifiant.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">meta-type</tt> (optionnel - par d&eacute;faut = <tt class="literal">class</tt>) : 
                            un type qui mappe <tt class="literal">java.lang.Class</tt> &agrave; une seule colonne, ou
			    un type admis pour un mapping de discrimination.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">cascade</tt> (optionnel - par d&eacute;faut = <tt class="literal">none</tt>) : 
                            le style de cascade.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optionnel - par d&eacute;faut = <tt class="literal">property</tt>) : La
			    strat&eacute;gie qu'Hibernate doit utiliser pour acc&eacute;der &agrave; la valeur de la propri&eacute;t&eacute;.
                        </p></td></tr></table></div></div><p>
                L'ancien type <tt class="literal">object</tt> qui avait un r&ocirc;le similaire dans Hibernate 1.2 est toujours
		support&eacute;, mais est d&eacute;sormais semi-d&eacute;pr&eacute;ci&eacute;.
            </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-quotedidentifiers"></a>5.3.&nbsp;identificateur SQL mis entre guillemets</h2></div></div><div></div></div><p>
	        Vous pouvez forcer Hibernate &agrave; placer, dans le SQL g&eacute;n&eacute;r&eacute;, les noms des tables et des colonnes
		entre guillemets en incluant la table ou 
		le nom de colonne entre guillemets simples dans le document de configuration. 
        Hibernate utilisera la syntaxe
		appropri&eacute;e dans le SQL g&eacute;n&eacute;r&eacute; en fonction du <tt class="literal">Dialect</tt> 
        (g&eacute;n&eacute;ralement des guillemets doubles, mais
		des crochets pour SQL Server et des guillemets invers&eacute;s pour MySQL).
            </p><pre class="programlisting">&lt;class name="LineItem" table="`Line Item`"&gt;
    &lt;id name="id" column="`Item Id`"/&gt;&lt;generator class="assigned"/&gt;&lt;/id&gt;
    &lt;property name="itemNumber" column="`Item #`"/&gt;
    ...
&lt;/class&gt;</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-modularfiles"></a>5.4.&nbsp;Fichiers de mapping modulaires</h2></div></div><div></div></div><p>
            Il est possible de d&eacute;finir les mappings <tt class="literal">subclass</tt> et <tt class="literal">joined-subclass</tt>
            dans des documents de mappings s&eacute;par&eacute;s, directement en dessous de <tt class="literal">hibernate-mapping</tt>.
            Ceci vous permet d'&eacute;tendre une hi&eacute;rarchie de classes en ajoutant simplement un fichier de mapping.
	    Vous devez sp&eacute;cifier l'attribut <tt class="literal">extends</tt> du mapping de la classe fille, nommant une
	    classe m&egrave;re d&eacute;j&agrave; d&eacute;finie. L'utilisation de cette option rend l'ordre des documents de 
	    mapping important !
        </p><pre class="programlisting">
&lt;hibernate-mapping&gt;
        &lt;subclass name="eg.subclass.DomesticCat" extends="eg.Cat" discriminator-value="D"&gt;
             &lt;property name="name" type="string"/&gt;
        &lt;/subclass&gt;
&lt;/hibernate-mapping&gt;</pre></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="collections"></a>Chapitre&nbsp;6.&nbsp;Mapping des Collections</h2></div></div><div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-persistent"></a>6.1.&nbsp;Collections persistantes</h2></div></div><div></div></div><p>
            Cette section ne contient pas beaucoup d'exemples Java. Nous supposons que vous
	    savez d&eacute;j&agrave; utiliser le framework de collections Java. Il n'y a donc pas grand chose
	    de plus &agrave; savoir - avec quelques d&eacute;finitions, vous pouvez utiliser les collections
	    Java de la m&ecirc;me mani&egrave;re que vous l'avez toujours fait.
        </p><p>
            Hibernate peut persister des instances de
            <tt class="literal">java.util.Map</tt>,
            <tt class="literal">java.util.Set</tt>,
            <tt class="literal">java.util.SortedMap</tt>,
            <tt class="literal">java.util.SortedSet</tt>,
            <tt class="literal">java.util.List</tt>,
            et tous les tableaux d'entit&eacute;s et valeurs persistantes. Les propri&eacute;t&eacute;s de
            <tt class="literal">java.util.Collection</tt> ou
            <tt class="literal">java.util.List</tt>
            peuvent aussi &ecirc;tre persist&eacute;es avec la s&eacute;mantique de sac (bag).
        </p><p>
            A savoir: les collections persistantes ne conservent pas de s&eacute;mantique suppl&eacute;mentaire
            introduite par les impl&eacute;mentations de l'interface Collection (ex: l'ordre d'it&eacute;ration d'une
	     <tt class="literal">LinkedHashSet</tt>).
            Les collections persistantes agissent respectivement comme
            <tt class="literal">HashMap</tt>,
            <tt class="literal">HashSet</tt>,
            <tt class="literal">TreeMap</tt>,
            <tt class="literal">TreeSet</tt> et
            <tt class="literal">ArrayList</tt>
            Par ailleurs, le type java de la propri&eacute;t&eacute; contenant la collection doit &ecirc;tre du type
	    de l'interface (ex: <tt class="literal">Map</tt>, <tt class="literal">Set</tt> ou <tt class="literal">List</tt> ;
	    jamais <tt class="literal">HashMap</tt>, <tt class="literal">TreeSet</tt> ou <tt class="literal">ArrayList</tt>). 
	    Cette restriction existe parce qu'Hibernate remplace dasn votre dos vos instances de <tt class="literal">Map</tt>, 
	    <tt class="literal">Set</tt> et <tt class="literal">List</tt> par des instances de ses propres impl&eacute;mentations
	    de <tt class="literal">Map</tt>, <tt class="literal">Set</tt> ou <tt class="literal">List</tt> (A ce titre, fa&icirc;tes 
        attention &agrave; l'utilisation de <tt class="literal">==</tt> sur vos collections).
        </p><pre class="programlisting">Cat cat = new DomesticCat();
Cat kitten = new DomesticCat();
....
Set kittens = new HashSet();
kittens.add(kitten);
cat.setKittens(kittens);
session.save(cat);
kittens = cat.getKittens(); //Okay, la collection kittens est un Set
(HashSet) cat.getKittens(); //Erreur !</pre><p>
            Les collections ob&eacute;issent aux r&egrave;gles auxquelles sont soumises les types valeurs :
	    pas de r&eacute;f&eacute;rences partag&eacute;es, les collections sont cr&eacute;&eacute;es ou effac&eacute;es en m&ecirc;me temps que 
        l'entit&eacute; contenante. A cause de la nature du mod&egrave;le relationnel,
        elles ne supportent pas la s&eacute;mantique nulle; Hibernate ne distingue
	    pas une collection nulle d'une collection vide.
        </p><p>
            Les collections sont automatiquement persist&eacute;es lorsqu'elles sont r&eacute;f&eacute;renc&eacute;es
	    par un objet persistant et automatiquement effac&eacute;es lorsqu'elles sont d&eacute;r&eacute;f&eacute;renc&eacute;es.
	    Si une collection est pass&eacute;e d'un objet persistant &agrave; un autre, ses &eacute;l&eacute;ments
	    devrait &ecirc;tre d&eacute;plac&eacute;s d'une table vers une autre. Vous ne devriez pas vous soucier 
	    beaucoup de cela. Vous n'avez qu'&agrave; utiliser les collections Hibernate
	    de la m&ecirc;me fa&ccedil;on que les collections Java ordinaires, mais vous devez &ecirc;tre
	    certains de comprendre les d&eacute;finitions des associations bidirectionnelles
	    (discut&eacute;es plus tard) avant de les utiliser.
        </p><p>
            Les instances de collections se diff&eacute;rencient en base de donn&eacute;es par une cl&eacute; &eacute;trang&egrave;re vers
	    l'entit&eacute; contenante. Cette cl&eacute; &eacute;trang&egrave;re est appel&eacute;e <span class="emphasis"><em>cl&eacute; de collection</em></span>. 
	    La cl&eacute; de collection est mapp&eacute;e par l'&eacute;l&eacute;ment <tt class="literal">&lt;key&gt;</tt>.
        </p><p>
            Les collections peuvent contenir d'autres types que ceux d'Hibernate, y compris tous
	    les types de base, les types entit&eacute;s et les composants. Ceci est une d&eacute;finition importante :
	    un objet dans une collection peut &ecirc;tre trait&eacute; soit avec la s&eacute;mantique d'un "passage par valeur"
	    (elle d&eacute;pendra alors du propri&eacute;taire de la collection) soit &ecirc;tre une r&eacute;f&eacute;rence
	    &agrave; une autre entit&eacute; ayant son propre cycle de vie. Les collections ne peuvent contenir
	    d'autres collections. Le type contenu est appel&eacute; <span class="emphasis"><em>type d'&eacute;l&eacute;ment de collection</em></span>.
	    Les &eacute;l&eacute;ments de collection sont mapp&eacute;s gr&acirc;ce &agrave; <tt class="literal">&lt;element&gt;</tt>, 
	    <tt class="literal">&lt;composite-element&gt;</tt>, <tt class="literal">&lt;one-to-many&gt;</tt>,
	    <tt class="literal">&lt;many-to-many&gt;</tt> ou <tt class="literal">&lt;many-to-any&gt;</tt>. 
	    Les deux premiers mappent des &eacute;l&eacute;ments avec la s&eacute;mantique de valeur, les trois autres
	    sont utilis&eacute;s pour mapper des associations avec des entit&eacute;s.
        </p><p>
            Toutes les collections, &agrave; l'exception de <tt class="literal">Set</tt> et Bag ont une colonne
	    <span class="emphasis"><em>index</em></span> - une colonne qui mappe vers l'index d'un tableau, d'une <tt class="literal">List</tt>
	    ou une cl&eacute; de <tt class="literal">Map</tt>. L'index de <tt class="literal">Map</tt> peut &ecirc;tre de
	    n'importe quel type de base, type entit&eacute; ou m&ecirc;me type composite (il ne peut &ecirc;tre une collection).
	    L'index d'un tableau ou d'une list est toujours de type <tt class="literal">integer</tt>. Les index sont mapp&eacute;s
	    en utilisant <tt class="literal">&lt;index&gt;</tt>, <tt class="literal">&lt;index-many-to-many&gt;</tt>,
            <tt class="literal">&lt;composite-index&gt;</tt> ou <tt class="literal">&lt;index-many-to-any&gt;</tt>.
        </p><p>
            Il existe beaucoup de mappings diff&eacute;rents pour les collections, couvrant plusieurs
	    mod&egrave;les relationnels. Nous vous conseillons d'essayer l'outil de g&eacute;n&eacute;ration de
	    sch&eacute;ma pour assimiler comment ces d&eacute;clarations se traduissent en base de donn&eacute;es.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-mapping"></a>6.2.&nbsp;Mapper une Collection</h2></div></div><div></div></div><p>
            Les collections sont mapp&eacute;es par les &eacute;l&eacute;ments
            <tt class="literal">&lt;set&gt;</tt>,
            <tt class="literal">&lt;list&gt;</tt>,
            <tt class="literal">&lt;map&gt;</tt>,
            <tt class="literal">&lt;bag&gt;</tt>,
            <tt class="literal">&lt;array&gt;</tt> et
            <tt class="literal">&lt;primitive-array&gt;</tt>.
            <tt class="literal">&lt;map&gt;</tt> est repr&eacute;sentatif :
        </p><div class="programlistingco"><pre class="programlisting">&lt;map
    name="nomDePropriete"                                       <span class="co">(1)</span>
    table="nom_de_table"                                        <span class="co">(2)</span>
    schema="nom_de_schema"                                      <span class="co">(3)</span>
    lazy="true|false"                                           <span class="co">(4)</span>
    inverse="true|false"                                        <span class="co">(5)</span>
    cascade="all|none|save-update|delete|all-delete-orphan"     <span class="co">(6)</span>
    sort="unsorted|natural|ClassDeComparateur"                  <span class="co">(7)</span>
    order-by="nom_de_colonne asc|desc"                          <span class="co">(8)</span>
    where="clause SQL where quelconque"                         <span class="co">(9)</span>
    outer-join="true|false|auto"                                <span class="co">(10)</span>
    batch-size="N"                                              <span class="co">(11)</span>
    access="field|property|NomDeClasse"                         <span class="co">(12)</span>
&gt;

    &lt;key .... /&gt;
    &lt;index .... /&gt;
    &lt;element .... /&gt;
&lt;/map&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">name</tt> : le nom de la prorpi&eacute;t&eacute; contenant la collection
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">table</tt> (optionnel - par d&eacute;faut = nom de la propri&eacute;t&eacute;) : le
			nom de la table de la collection (non utilis&eacute; pour les associations one-to-many)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">schema</tt> (optionnel) : le nom du sch&eacute;ma pour surcharger le
			sch&eacute;ma d&eacute;clar&eacute; dans l'&eacute;l&eacute;ment racine
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                        <tt class="literal">lazy</tt> (optionnel - par d&eacute;faut = <tt class="literal">false</tt>) :
                        active l'initialisation tardive (non utilis&eacute; pour les tableaux)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                        <tt class="literal">inverse</tt> (optionnel - par d&eacute;faut = <tt class="literal">false</tt>) :
                        d&eacute;finit cette collection comme l'extr&ecirc;mit&eacute; "inverse" de l'association 
			bidirectionnelle.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                        <tt class="literal">cascade</tt> (optionnel - par d&eacute;faut = <tt class="literal">none</tt>) :
                        active les op&eacute;rations de cascade vers les entit&eacute;s filles
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                        <tt class="literal">sort</tt> (optionnel) : sp&eacute;cifie une collection tri&eacute;e via un ordre
			de tri <tt class="literal">naturel</tt>, ou via une classe comparateur donn&eacute;e (impl&eacute;mentant Comparator)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                        <tt class="literal">order-by</tt> (optionnel, seulement &agrave; partir du JDK1.4) :
                        sp&eacute;cifie une colonne de table 
			(ou des colonnes) qui d&eacute;finit l'ordre d'it&eacute;ration de <tt class="literal">Map</tt>, <tt class="literal">Set</tt>
                        ou Bag, avec en option <tt class="literal">asc</tt> ou <tt class="literal">desc</tt>
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                        <tt class="literal">where</tt> (optionnel) : sp&eacute;cifie une condition SQL arbitraire <tt class="literal">WHERE</tt>
                        &agrave; utiliser au chargement ou &agrave; la suppression d'une collection (utile si la collection 
			ne doit contenir qu'un sous ensemble des donn&eacute;es disponibles)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                        <tt class="literal">outer-join</tt> (optionnel) : sp&eacute;cifie que la collection doit &ecirc;tre charg&eacute;e
			en utilisant une jointure ouverte, lorsque c'est possible. Seule une collection (par <tt class="literal">SELECT</tt> SQL)
			pour &ecirc;tre charg&eacute;e avec une jointure ouverte.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(11)</td><td valign="top" align="left"><p>
                        <tt class="literal">batch-size</tt> (optionnel, par d&eacute;faut = <tt class="literal">1</tt>) : une taille
			de batch (batch size) utilis&eacute;e pour charger plusieurs instances de cette collection en 
            initialisation tardive.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(12)</td><td valign="top" align="left"><p>
                        <tt class="literal">access</tt> (optionnel - par d&eacute;faut = <tt class="literal">property</tt>) : La
			strat&eacute;gie qu'Hibernate doit utiliser pour acc&eacute;der &agrave; la valeur de la propri&eacute;t&eacute;.
                    </p></td></tr></table></div></div><p>
            Le mapping d'une <tt class="literal">List</tt> ou d'un tableau n&eacute;cessite une colonne &agrave; part pour contenir
	    l'index du tableau ou de la list (le <tt class="literal">i</tt> dans <tt class="literal">foo[i]</tt>). Si votre mod&egrave;le
	    relationnel n'a pas de colonne index, (par exemple si vous travaillez avec une base de donn&eacute;es sur laquelle
        vous n'avez pas la main), utilisez
	    alors un <tt class="literal">Set</tt> non ordonn&eacute;. Cela semble aller &agrave; l'encontre de beaucoup de personnes qui 
        pensent qu'une  <tt class="literal">List</tt> est un moyen pratique d'acc&eacute;der &agrave; une collection d&eacute;sordonn&eacute;e. 
	    Les collections Hibernate ob&eacute;issent strictement aux s&eacute;mantiques des interfaces des collections
	    <tt class="literal">Set</tt>, <tt class="literal">List</tt> et <tt class="literal">Map</tt>. Les &eacute;l&eacute;ments de <tt class="literal">List</tt> 
	    ne se r&eacute;arrangent pas spontan&eacute;ment !
        </p><p>
            D'un autre c&ocirc;t&eacute;, les personnes qui veulent utiliser une <tt class="literal">List</tt> pour &eacute;muler le
	    comportement d'un <span class="emphasis"><em>bag</em></span> (sac) ont une raison l&eacute;gitime. Un bag (sac) est une collection
	    non tri&eacute;e, non ordonn&eacute;e qui peut contenir le m&ecirc;me &eacute;l&eacute;ment plusieurs fois. Le framework de collections Java
	    ne dispose pas d'une interface <tt class="literal">Bag</tt>, ainsi vous devez l'&eacute;muler avec
	    une <tt class="literal">List</tt>. Hibernate vous permet de mapper des propri&eacute;t&eacute;s de type <tt class="literal">List</tt>
            ou <tt class="literal">Collection</tt> avec l'&eacute;l&eacute;ment <tt class="literal">&lt;bag&gt;</tt>. Notez que la d&eacute;finition
	    de bag ne fait pas partie du contrat <tt class="literal">Collection</tt> et qu'elle est m&ecirc;me en conflit
	    avec certains aspects de la d&eacute;finition du contrat d'une <tt class="literal">List</tt> (vous pouvez, cependant,
        trier un bag (sac) de mani&egrave;re aritraire, nous en discuterons plus tard).
        </p><p>
            Note : Les bags Hibernate volumineux mapp&eacute; avec <tt class="literal">inverse="false"</tt> ne sont pas efficaces et
	    doivent &ecirc;tre &eacute;vit&eacute;s ; Hibernate ne peut cr&eacute;er, effacer ou mettre &agrave; jour individuellement les enregistrements,
	    puisqu'il n'y a pas de cl&eacute; pouvant servir &agrave; identifier un enregistrement particulier.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-ofvalues"></a>6.3.&nbsp;Collections de valeurs et associations Plusieurs-vers-Plusieurs</h2></div></div><div></div></div><p>
            Une table de collection est requise pour toute collection de valeurs et toute collection
	    de r&eacute;f&eacute;rences vers d'autres entit&eacute;s mapp&eacute;es avec une association plusieurs-vers-plusieurs 
        (la d&eacute;finition naturelle d'une collection Java). La table a besoin de d'une(de) cl&eacute;(s) 
        &eacute;trang&egrave;re(s), d'une(de) colonne(s) &eacute;l&eacute;ment et si possible d'une(de) colonne(s) index.
        </p><p>
            La cl&eacute; &eacute;trang&egrave;re d'une table de collection vers la table de l'entit&eacute; propri&eacute;taire
            est d&eacute;clar&eacute;e en utilisant l'&eacute;l&eacute;ment <tt class="literal">&lt;key&gt;</tt>.
        </p><div class="programlistingco"><pre class="programlisting">&lt;key column="nom_de_colonne"/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (requis) : Le nom de la colonne cl&eacute; &eacute;trang&egrave;re
                    </p></td></tr></table></div></div><p>
            Pour les collections index&eacute;es comme les lists et les maps, nous avons besoin d'un &eacute;l&eacute;ment
	    <tt class="literal">&lt;index&gt;</tt>. Pour les lists, cette colonne contient des entiers num&eacute;rot&eacute;s
	    &agrave; partir de z&eacute;ro. Soyez certains que votre index commence bien par z&eacute;ro (surtout si vous travaillez
	    avec une base de donn&eacute;es existante). Pour les maps, la colonne peut contenir des valeurs de chacun des
	    types Hibernate.
        </p><div class="programlistingco"><pre class="programlisting">&lt;index
        column="nom_de_colonne"             <span class="co">(1)</span>
        type="nomdetype"                    <span class="co">(2)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (requis) : Le nom de la colonne contenant les
			valeurs de l'index de la collection.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">type</tt> (optionnel, par d&eacute;faut = <tt class="literal">integer</tt>) :
                        Le type de l'index de la collection.
                    </p></td></tr></table></div></div><p>
            Alternativement, une map peut &ecirc;tre index&eacute;e par des objets de type entit&eacute;.
	    Nous utilisons alors l'&eacute;l&eacute;ment <tt class="literal">&lt;index-many-to-many&gt;</tt>.
        </p><div class="programlistingco"><pre class="programlisting">&lt;index-many-to-many
        column="nom_de_colonne"             <span class="co">(1)</span>
        class="NomDeClasse"                 <span class="co">(2)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (requis): Le nom de la colonne contenant
            la cl&eacute; &eacute;trang&egrave;re vers l'entit&eacute; index de la collection.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">class</tt> (requis) : La classe entit&eacute; utilis&eacute;e comme
			index de collection.
                    </p></td></tr></table></div></div><p>
            Pour une collection de valeurs, nous utilisons l'element <tt class="literal">&lt;element&gt;</tt>.
        </p><div class="programlistingco"><pre class="programlisting">&lt;element
        column="nom_de_colonne"             <span class="co">(1)</span>
        type="nomdetype"                    <span class="co">(2)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (requis) : Le nom de la colonne contenant les valeurs
			des &eacute;l&eacute;ments de la collection.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">type</tt> (requis) : Le type d'un &eacute;l&eacute;ment de la colleciton.
                    </p></td></tr></table></div></div><p>
            Une collection d'entit&eacute;s avec sa propre table correspond &agrave; la notion relationnelle
	    d'une <span class="emphasis"><em>association plusieurs-vers-plusieurs</em></span>. Une association plusieurs vers plusieurs 
	    est le mapping le plus naturel pour une collection Java mais n'est g&eacute;n&eacute;ralement pas
	    le meilleur mod&egrave;le relationnel.
        </p><div class="programlistingco"><pre class="programlisting">&lt;many-to-many
        column="nom_de_colonne"                            <span class="co">(1)</span>
        class="NomDeClasse"                                <span class="co">(2)</span>
        outer-join="true|false|auto"                       <span class="co">(3)</span>
    /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (requis) : Le nom de la colonne contenant
                        la cl&eacute; &eacute;trang&egrave;re de l'entit&eacute;
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">class</tt> (requis) : Le nom de la classe associ&eacute;e.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">outer-join</tt> (optionnel - par d&eacute;faut =  <tt class="literal">auto</tt>) :
                        active le chargement par jointure ouverte pour cette association lorsque
			<tt class="literal">hibernate.use_outer_join</tt> est activ&eacute;.
                    </p></td></tr></table></div></div><p>
            Quelques exemple, d'abord un set de String :
        </p><pre class="programlisting">&lt;set name="names" table="NAMES"&gt;
    &lt;key column="GROUPID"/&gt;
    &lt;element column="NAME" type="string"/&gt;
&lt;/set&gt;</pre><p>
            Un bag contenant des integers (avec un ordre d'it&eacute;ration d&eacute;termin&eacute; par
	    l'attribut <tt class="literal">order-by</tt>) :
        </p><pre class="programlisting">&lt;bag name="sizes" table="SIZES" order-by="SIZE ASC"&gt;
    &lt;key column="OWNER"/&gt;
    &lt;element column="SIZE" type="integer"/&gt;
&lt;/bag&gt;</pre><p>
            Un tableau d'entit&eacute;s - dans ce cas une association many to many (notez que
	    les entit&eacute;s ont un cycle de vie, <tt class="literal">cascade="all"</tt>):
        </p><pre class="programlisting">&lt;array name="foos" table="BAR_FOOS" cascade="all"&gt;
    &lt;key column="BAR_ID"/&gt;
    &lt;index column="I"/&gt;
    &lt;many-to-many column="FOO_ID" class="org.hibernate.Foo"/&gt;
&lt;/array&gt;</pre><p>
           Une map d'index de String vers des Date:
        </p><pre class="programlisting">&lt;map name="holidays" table="holidays" schema="dbo" order-by="hol_name asc"&gt;
    &lt;key column="id"/&gt;
    &lt;index column="hol_name" type="string"/&gt;
    &lt;element column="hol_date" type="date"/&gt;
&lt;/map&gt;</pre><p>
            Une List de composants (d&eacute;crits dans le prochain chapitre):
        </p><pre class="programlisting">&lt;list name="carComponents" table="car_components"&gt;
    &lt;key column="car_id"/&gt;
    &lt;index column="posn"/&gt;
    &lt;composite-element class="org.hibernate.car.CarComponent"&gt;
            &lt;property name="price" type="float"/&gt;
            &lt;property name="type" type="org.hibernate.car.ComponentType"/&gt;
            &lt;property name="serialNumber" column="serial_no" type="string"/&gt;
    &lt;/composite-element&gt;
&lt;/list&gt;</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-onetomany"></a>6.4.&nbsp;Associations Un-vers-Plusieurs</h2></div></div><div></div></div><p>
            Une <span class="emphasis"><em>association un vers plusieurs</em></span> lie les tables de deux classes
            <span class="emphasis"><em>directement</em></span>, sans table de collection interm&eacute;diaire
            (Ceci impl&eacute;mente un mod&egrave;le relationnel <span class="emphasis"><em>un-vers-plusieurs</em></span>). Ce
	    mod&egrave;le relationnel perd quelques unes des s&eacute;mantiques des collections Java:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Il ne peut y avoir de valeur nulle contenue dans map, set ou list
                </p></li><li><p>
                    Une instance de la classe entit&eacute; contenue ne peut appartenir &agrave; plus
		    d'une instance de la collection
                </p></li><li><p>
                    Une instance de la classe entit&eacute; contenue ne peut apparaitre dans plus
		    d'une valeur de l'index de la collection
                </p></li></ul></div><p>
            Une association de <tt class="literal">Foo</tt> vers <tt class="literal">Bar</tt> n&eacute;cessite l'ajout
	    d'une colonne cl&eacute; et si possible d'une colonne index vers la table de la classe entit&eacute; 
	    contenue, <tt class="literal">Bar</tt>. Ces colonnes sont mapp&eacute;es en utilisant les &eacute;l&eacute;ments
            <tt class="literal">&lt;key&gt;</tt> et <tt class="literal">&lt;index&gt;</tt> d&eacute;crits pr&eacute;c&eacute;demment.
        </p><p>
            Le tag <tt class="literal">&lt;one-to-many&gt;</tt> indique une assocation un vers plusieurs.
        </p><div class="programlistingco"><pre class="programlisting">&lt;one-to-many class="NomDeClasse"/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">class</tt> (requis) : Le nom de la classe associ&eacute;e.
                    </p></td></tr></table></div></div><p>
            Exemple :
        </p><pre class="programlisting">&lt;set name="bars"&gt;
    &lt;key column="foo_id"/&gt;
    &lt;one-to-many class="org.hibernate.Bar"/&gt;
&lt;/set&gt;</pre><p>
            Notez que l'&eacute;l&eacute;ment <tt class="literal">&lt;one-to-many&gt;</tt> n'a pas besoin de d&eacute;clarer
	    de colonne. Il n'est pas non plus n&eacute;cessaire de d&eacute;clarer un nom de table ou quoique ce soit.
        </p><p>
            <span class="emphasis"><em>Note importante :</em></span> Si la colonne <tt class="literal">&lt;key&gt;</tt>
            d'une association <tt class="literal">&lt;one-to-many&gt;</tt> est d&eacute;clar&eacute;e
            <tt class="literal">NOT NULL</tt>, Hibernate peut provoquer des violations de contraintes
	    lorsqu'il cr&eacute;&eacute; ou met &agrave; jour l'association. Pour &eacute;viter ce probl&egrave;me,
            <span class="emphasis"><em>vous devez utiliser une association bidirectionnelle</em></span> avec 
	    l'extr&eacute;mit&eacute; plusieurs (set ou bag) marqu&eacute;z comme <tt class="literal">inverse="true"</tt>.
            Voir la discussion sur les associations bidirectionnelles plus tard.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-lazy"></a>6.5.&nbsp;Initialisation tardive</h2></div></div><div></div></div><p>
            Les collections (autres que les tableaux) peuvent &ecirc;tre initialis&eacute;e de mani&egrave;re
	    tardives, ce qui signifie qu'elles ne chargent leur &eacute;tat de la base de donn&eacute;es que lorsque
	    l'application a besoin d'y acc&eacute;der. L'initialisation intervient de mani&egrave;re 
	    transparente pour l'utilisateur, l'application n'a donc pas &agrave; se soucier
	    de cela (en fait, l'initialisation transparente est la principale raison
	    pour laquelle Hibernate a besoin de ses propres impl&eacute;mentations de collection).
	    Ainsi, si l'application essaie quelque chose comme :
        </p><pre class="programlisting">s = sessions.openSession();
User u = (User) s.find("from User u where u.name=?", userName, Hibernate.STRING).get(0);
Map permissions = u.getPermissions();
s.connection().commit();
s.close();

Integer accessLevel = (Integer) permissions.get("accounts");  // Erreur !</pre><p>
            Il arrivera une mauvaise surprise. Dans la mesure o&ugrave; les collections 
            "permissions" n'ont
	    pas &eacute;t&eacute; initialis&eacute;es avant que la <tt class="literal">Session</tt> soit commit&eacute;e,
	    la collection ne sera jamais capable de charger son &eacute;tat. Pour corriger le cas
	    pr&eacute;c&eacute;dent, il faut d&eacute;placer la ligne qui lit la collection juste avant le commit
	    (Il existe d'autres moyens avanc&eacute;s de r&eacute;sourdre ce probl&egrave;me).
        </p><p>
            Une autre fa&ccedil;on de faire est d'utilisez une collection initialis&eacute;e imm&eacute;diatement. 
            Puisque l'initialisation tardive
	    peut mener &agrave; des bogues comme le pr&eacute;c&eacute;dent, l'initialisation imm&eacute;diate
        est le comportement par d&eacute;faut.
	    Cependant, il est pr&eacute;f&eacute;rable d'utiliser l'initialisation tardive pour la plupart
	    des collections, sp&eacute;cialement pour les collections d'entit&eacute;s (pour des raisons
	    de performances).
        </p><p>
            Les exceptions qui arrivent lors d'une initialisation tardive sont encapsul&eacute;es
            dans une <tt class="literal">LazyInitializationException</tt>.
        </p><p>
            D&eacute;clarer une collection comme tardive en utilisant l'attribut optionnel <tt class="literal">lazy</tt> :
        </p><pre class="programlisting">&lt;set name="names" table="NAMES" lazy="true"&gt;
    &lt;key column="group_id"/&gt;
    &lt;element column="NAME" type="string"/&gt;
&lt;/set&gt;</pre><p>
            Dans certaines architectures applicatives, particuli&egrave;rement quand le code qui acc&egrave;de
	    aux donn&eacute;es et celui qui les utilise ne se trouvent pas dans la m&ecirc;me couche, on
	    peut avoir un probl&egrave;me pour garantir que la session est ouverte pour l'initialisation
	    de la collection. Il y a deux moyens clzssiques de r&eacute;soudre ce probl&egrave;me :
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    Dans une application web, un filtre de servlet peut &ecirc;tre utilis&eacute; pour
		    ne fermer la <tt class="literal">Session</tt> qu'&agrave; la fin de la requ&ecirc;te
		    de l'utilisateur, une fois que la vue a &eacute;t&eacute; rendue. Bien entendu, cela
		    n&eacute;cessite de mettre en place une gestion rigoureuse des exceptions de
		    l'infrastructure applicative. Il est vital que la <tt class="literal">Session</tt>
                    soit ferm&eacute;e et la transaction achev&eacute;e avant le retour vers l'utilisateur,
		    m&ecirc;me si une exception survient pendant le rendement de la vue. Le filtre
		    de servlet doit pouvoir acc&eacute;der &agrave; la <tt class="literal">Session</tt> pour cette approche.
            Nous recommandons d'utiliser une variable <tt class="literal">ThreadLocal</tt> pour garder
		    la <tt class="literal">Session</tt> courante (voir chapitre 1, pour un exemple
		    d'impl&eacute;mentation).<a href="#quickstart-playingwithcats" title="1.4.&nbsp;Jouer avec les chats">Section&nbsp;1.4, &laquo;&nbsp;Jouer avec les chats&nbsp;&raquo;</a>).
                </p></li><li><p>
                    Dans une application avec une couche m&eacute;tier s&eacute;par&eacute;e, la logique m&eacute;tier doit
		    "pr&eacute;parer" toutes les collections qui seront requises par la couche web
		    avant d'effectuer le retour. Cela signifie que la couce m&eacute;tier doit
		    charger toutes les donn&eacute;es nacessaires au cas d'utilisation qui nous occupe
            et les retourner &agrave; la couche de pr&eacute;sentation/web. G&eacute;n&eacute;ralement, l'application
		    invoque <tt class="literal">Hibernate.initialize()</tt> pour chaque collection qui
		    sera requise par l'&eacute;tage web (cet appel doit &ecirc;tre effectu&eacute; avant la
		    fermeture de la session) ou charg la collection via une requ&ecirc;te en utilisant
		    une clause <tt class="literal">FETCH</tt>.
                </p></li><li><p>
                    Vous pouvez aussi attacher un objet pr&eacute;c&eacute;demment charg&eacute; &agrave; une nouvelle 
            <tt class="literal">Session</tt> en utilisant <tt class="literal">update()</tt> ou 
            <tt class="literal">lock()</tt> avant 
		    d'acc&eacute;der aux collections non initialis&eacute;es (ou autres proxys). Hibernate ne 
		    peut le faire automatiquement, cela introduirait une s&eacute;mantique de transaction !
                </p></li></ul></div><p>
            Vous pouvez utiliser la m&eacute;thode <tt class="literal">filter()</tt> de l'API Session d'Hibernate
	    pour avoir la taille de la collection sans l'initialiser :
        </p><pre class="programlisting">( (Integer) s.filter( collection, "select count(*)" ).get(0) ).intValue()</pre><p>
            <tt class="literal">filter()</tt> ou <tt class="literal">createFilter()</tt> sont aussi utilis&eacute;s pour
	    r&eacute;cup&eacute;rer de mani&egrave;re efficace un sous ensemble d'une collection sans avoir &agrave; l'initialiser
	    enti&egrave;rement.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-sorted"></a>6.6.&nbsp;Collections tri&eacute;es</h2></div></div><div></div></div><p>
            Hibernate supporte les collections qui impl&eacute;mentent <tt class="literal">java.util.SortedMap</tt> et
            <tt class="literal">java.util.SortedSet</tt>. Vous devez sp&eacute;cifier un comparateur dans le fichier de mapping :
        </p><pre class="programlisting">&lt;set name="aliases" table="person_aliases" sort="natural"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="string"/&gt;
&lt;/set&gt;

&lt;map name="holidays" sort="my.custom.HolidayComparator" lazy="true"&gt;
    &lt;key column="year_id"/&gt;
    &lt;index column="hol_name" type="string"/&gt;
    &lt;element column="hol_date type="date"/&gt;
&lt;/map&gt;</pre><p>
            Les valeurs de l'attribut <tt class="literal">sort</tt> sont <tt class="literal">unsorted</tt>,
            <tt class="literal">natural</tt> et le nom d'une classe impl&eacute;mentant
            <tt class="literal">java.util.Comparator</tt>.
        </p><p>
            Les collections tri&eacute;es se comportent comme <tt class="literal">java.util.TreeSet</tt> ou
            <tt class="literal">java.util.TreeMap</tt>.
        </p><p>
            Si vous souhaitez que la base de donn&eacute;es trie elle m&ecirc;me les &eacute;l&eacute;ments d'une collection, utilisez
	    l'attribut <tt class="literal">order-by</tt> des mappings de <tt class="literal">set</tt>, <tt class="literal">bag</tt>
            ou <tt class="literal">map</tt>. Cette solution n'est disponible qu'&agrave; partir du
            JDK 1.4 ou plus (elle est impl&eacute;ment&eacute;e via les <tt class="literal">LinkedHashSet</tt> ou
            <tt class="literal">LinkedHashMap</tt>). Ceci effectue un tri dans la requ&ecirc;te SQL, et non
	    en m&eacute;moire dans la JVM.
        </p><pre class="programlisting">&lt;set name="aliases" table="person_aliases" order-by="name asc"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="string"/&gt;
&lt;/set&gt;

&lt;map name="holidays" order-by="hol_date, hol_name" lazy="true"&gt;
    &lt;key column="year_id"/&gt;
    &lt;index column="hol_name" type="string"/&gt;
    &lt;element column="hol_date type="date"/&gt;
&lt;/map&gt;</pre><p>
            Notez que la valeur de l'attribut <tt class="literal">order-by</tt> est un tri SQL et non HQL !
        </p><p>
            Les associations peuvent aussi &ecirc;tre tri&eacute;es &agrave; l'ex&eacute;cution par des crit&egrave;res arbitraires
	    en utilisant <tt class="literal">filter()</tt>.
        </p><pre class="programlisting">sortedUsers = s.filter( group.getUsers(), "order by this.name" );</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-idbag"></a>6.7.&nbsp;<tt class="literal">Utiliser un &lt;idbag&gt;</tt></h2></div></div><div></div></div><p>
            Si, comme nous, vous &ecirc;tes compl&ecirc;tement d'accord sur le fait
        que les cl&eacute;s composites sont une mauvaise id&eacute;e et que
	    les entit&eacute;s devraient avoir des identifiants synth&eacute;tiques (cl&eacute;s techniques), alors
	    vous devez trouver &eacute;trange que les associations plusieurs vers plusieurs et les collections
	    de valeurs que nous avons montr&eacute;es jusqu'&agrave; pr&eacute;sent soient toutes mapp&eacute;es 
	    dans des tables poss&eacute;dant des cl&eacute;s composites ! En fait, ce point est discutable ;
	    une table d'association pure ne semble pas tirer b&eacute;n&eacute;fice d'une cl&eacute; technique
	    (bien qu'une collection de valeurs compos&eacute;es le pourrait). N&eacute;anmoins, Hibernate propose
	    une fonctionnalit&eacute; (un peu exp&eacute;rimentale) qui vous permet de mapper des associations
	    many to many et des collections de valeurs vers une table ayant une cl&eacute; technique.
        </p><p>
            L'&eacute;l&eacute;ment <tt class="literal">&lt;idbag&gt;</tt> vous permet de mapper une <tt class="literal">List</tt>
            (ou <tt class="literal">Collection</tt>) avec les caract&eacute;ristiques d'un bag.
        </p><pre class="programlisting">&lt;idbag name="lovers" table="LOVERS" lazy="true"&gt;
    &lt;collection-id column="ID" type="long"&gt;
        &lt;generator class="hilo"/&gt;
    &lt;/collection-id&gt;
    &lt;key column="PERSON1"/&gt;
    &lt;many-to-many column="PERSON2" class="eg.Person" outer-join="true"/&gt;
&lt;/idbag&gt;</pre><p>
            Comme vous pouvez le voir, un <tt class="literal">&lt;idbag&gt;</tt> poss&egrave;de un g&eacute;n&eacute;rateur d'id 
	    synth&eacute;tique, tout comme une classe entit&eacute; ! Une cl&eacute; technique diff&eacute;rente est assign&eacute;e &agrave; chaque
	    enregistrement de la collection. Hibernate ne fournit cependant pas de m&eacute;canisme pour trouver
	    la valeur de la cl&eacute; technique d'un enregistrement particulier.
        </p><p>
            Notez que la performance de mise &agrave; jour pour un <tt class="literal">&lt;idbag&gt;</tt> est
	    <span class="emphasis"><em>nettement</em></span> meilleure que pour un <tt class="literal">&lt;bag&gt;</tt> !
            Hibernate peut localiser les enregistrements individuellement et les mettre 
	    &agrave; jour ou les effacer individuellement, comme dans une list, une map ou un set.
        </p><p>
            Dans l'impl&eacute;mentation courante, la g&eacute;n&eacute;ration d'identifiant <tt class="literal">identity</tt>
	    n'est pas support&eacute;e pour les identifiants de collection <tt class="literal">&lt;idbag&gt;</tt>.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-bidirectional"></a>6.8.&nbsp;Associations Bidirectionnelles</h2></div></div><div></div></div><p>
            Une <span class="emphasis"><em>association bidirectionnelle</em></span> permet de naviguer &agrave; partir
	    des deux extr&eacute;mit&eacute;s de l'association. Les deux types d'association bidirectionnelles
	    support&eacute;es sont :

            </p><div class="variablelist"><dl><dt><span class="term">un-vers-plusieurs</span></dt><dd><p>
                            un set ou un bag d'un c&ocirc;t&eacute;, un simple entit&eacute; de l'autre
                        </p></dd><dt><span class="term">plusieurs-vers-plusieurs</span></dt><dd><p>
                            un set ou un bag de chaque c&ocirc;t&eacute;
                        </p></dd></dl></div><p>

        </p><p>
            Notez qu'Hibernate ne supporte pas les associations bidirectionnelles avec une
	    collection index&eacute;e (list, map or array), vous devez utiliser un mapping set ou bag.
        </p><p>
            Vous pouvez sp&eacute;cifier une association plusieurs-vers-plusieurs bidirectionnelle, 
        en mappant simplement deux associations plusieurs-vers-plusieurs &agrave; la m&ecirc;me table 
        d'association de la base de donn&eacute;es et en d&eacute;clarant
	    une extr&eacute;mit&eacute; <span class="emphasis"><em>inverse</em></span> (celle de votre choix). Voici un exemple
	    d'association bidirectionnelle d'une classe vers <span class="emphasis"><em>elle-m&ecirc;me</em></span>
            (chaque categorie peut avoir plusieurs items et chaque item peut &ecirc;tre dans plusieurs
	    categories):
        </p><pre class="programlisting">&lt;class name="org.hibernate.auction.Category"&gt;
    &lt;id name="id" column="ID"/&gt;
    ...
    &lt;bag name="items" table="CATEGORY_ITEM" lazy="true"&gt;
        &lt;key column="CATEGORY_ID"/&gt;
        &lt;many-to-many class="org.hibernate.auction.Item" column="ITEM_ID"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;

&lt;class name="org.hibernate.auction.Item"&gt;
    &lt;id name="id" column="ID"/&gt;
    ...

    &lt;!-- inverse end --&gt;
    &lt;bag name="categories" table="CATEGORY_ITEM" inverse="true" lazy="true"&gt;
        &lt;key column="ITEM_ID"/&gt;
        &lt;many-to-many class="org.hibernate.auction.Category" column="CATEGORY_ID"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;</pre><p>
            Les changement effectu&eacute;s uniquement sur l'extr&ecirc;mit&eacute; inverse ne sont <span class="emphasis"><em>pas</em></span>
            persist&eacute;s. Ceci signifie qu'Hibernate poss&egrave;de deux repr&eacute;sentations en m&eacute;moire
	    pour chaque association bidirectionnelle, un lien de A vers B et l'autre de B vers A.
	    Ceci est plus facile &agrave; comprendre si vous penser au mod&egrave;le objet Java et comment
	    l'on cr&eacute;&eacute; une relation plusieurs-vers-plusieurs en Java:
        </p><pre class="programlisting">
category.getItems().add(item);          // La cat&eacute;gorie connait d&eacute;sormais la relation
item.getCategories().add(category);     // L'Item connait d&eacute;sormais la relation

session.update(item);                     // Aucun effet, rien n'est persist&eacute; !
session.update(category);                 // La relation est persist&eacute;e</pre><p>
            Le c&ocirc;t&eacute; non-inverse est utilis&eacute; pour sauvegarder la r&eacute;pr&eacute;sentation m&eacute;moire 
        de la relation en base de donn&eacute;es.
	    Nous aurions un INSERT/UPDATE inutile et provoquerions probalement une violation
	    de contrainte de cl&eacute; &eacute;trang&egrave;re si les deux c&ocirc;t&eacute;s d&eacute;clenchaient la mise &agrave; jour ! 
        Ceci est &eacute;galement vrai pour les associations un-vers-plusieurs bidirectionnelles.
        </p><p>
        Vous pouvez mapper une association un-vers-plusieurs bidirectionnelle en mappant une
	    association un-vers-plusieurs vers la(les) m&ecirc;me(s) colonne(s) de table 
        que sa relation inverse plusieurs-vers-une et en d&eacute;clarant l'extr&ecirc;mit&eacute; 
	    plisieurs avec <tt class="literal">inverse="true"</tt>.
        </p><pre class="programlisting">&lt;class name="eg.Parent"&gt;
    &lt;id name="id" column="id"/&gt;
    ....
    &lt;set name="children" inverse="true" lazy="true"&gt;
        &lt;key column="parent_id"/&gt;
        &lt;one-to-many class="eg.Child"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="eg.Child"&gt;
    &lt;id name="id" column="id"/&gt;
    ....
    &lt;many-to-one name="parent" class="eg.Parent" column="parent_id"/&gt;
&lt;/class&gt;</pre><p>
            Mapper un c&ocirc;t&eacute; d'une association avec <tt class="literal">inverse="true"</tt> n'impacte pas
	    les op&eacute;rations de cascade, ce sont deux concepts diff&eacute;rents !
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-ternary"></a>6.9.&nbsp;Associations ternaires</h2></div></div><div></div></div><p>
            Il y a deux approches pour mapper une association ternaire. La premi&egrave;re est d'utiliser
	    des &eacute;l&eacute;ments composites (voir ci-dessous). La seconde est d'utiliser une <tt class="literal">Map</tt> 
        ayant une association comme index :
        </p><pre class="programlisting">&lt;map name="contracts" lazy="true"&gt;
    &lt;key column="employer_id"/&gt;
    &lt;index-many-to-many column="employee_id" class="Employee"/&gt;
    &lt;one-to-many column="contract_id" class="Contract"/&gt;
&lt;/map&gt;</pre><pre class="programlisting">&lt;map name="connections" lazy="true"&gt;
    &lt;key column="node1_id"/&gt;
    &lt;index-many-to-many column="node2_id" class="Node"/&gt;
    &lt;many-to-many column="connection_id" class="Connection"/&gt;
&lt;/map&gt;</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-heterogeneous"></a>6.10.&nbsp;Associations h&eacute;t&eacute;rog&egrave;nes</h2></div></div><div></div></div><p>
	        Les &eacute;l&eacute;ments <tt class="literal">&lt;many-to-any&gt;</tt> et <tt class="literal">&lt;index-many-to-any&gt;</tt>
	    fournissent de vraies associations h&eacute;t&eacute;rog&egrave;nes. Ces &eacute;l&eacute;ments de mapping fonctionnnent 
		comme l'&eacute;l&eacute;ment <tt class="literal">&lt;any&gt;</tt> - et ne devraient &ecirc;tre utilis&eacute;s
		que tr&egrave;s rarement.
	    </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-example"></a>6.11.&nbsp;Exemples de collection</h2></div></div><div></div></div><p>
            Les sections pr&eacute;c&eacute;dentes sont un peu confuses. Regardons un exemple, cette
	    classe :
        </p><pre class="programlisting">package eg;
import java.util.Set;

public class Parent {
    private long id;
    private Set children;

    public long getId() { return id; }
    private void setId(long id) { this.id=id; }

    private Set getChildren() { return children; }
    private void setChildren(Set children) { this.children=children; }

    ....
    ....
}</pre><p>
            poss&egrave;de une collection d'instances de <tt class="literal">eg.Child</tt>. Si chacun des
            child (fils) poss&egrave;de au plus un parent, le mapping le plus naturel est une
	    association un-vers-plisieurs :
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="eg.Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" lazy="true"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="eg.Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="eg.Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            Ceci mappe les d&eacute;finitions suivantes :
        </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null primary key, name varchar(255), parent_id bigint )
alter table child add constraint childfk0 (parent_id) references parent</pre><p>
            Si le parent est <span class="emphasis"><em>requis</em></span>, utilisez une association un-vers-plusieurs
            bidirectionnelle :
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="eg.Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" inverse="true" lazy="true"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="eg.Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="eg.Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
        &lt;many-to-one name="parent" class="eg.Parent" column="parent_id" not-null="true"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            Notez la contrainte <tt class="literal">NOT NULL</tt> :
        </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null
                     primary key,
                     name varchar(255),
                     parent_id bigint not null )
alter table child add constraint childfk0 (parent_id) references parent</pre><p>
            D'un autre c&ocirc;t&eacute;, si le child (fils) peut avoir plusieurs parents, une association
	    plusieurs-vers-plusieurs est appropri&eacute;e :
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="eg.Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" lazy="true" table="childset"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;many-to-many class="eg.Child" column="child_id"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="eg.Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            D&eacute;finitions des tables :
        </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null primary key, name varchar(255) )
create table childset ( parent_id bigint not null,
                        child_id bigint not null,
                        primary key ( parent_id, child_id ) )
alter table childset add constraint childsetfk0 (parent_id) references parent
alter table childset add constraint childsetfk1 (child_id) references child</pre></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="components"></a>Chapitre&nbsp;7.&nbsp;Mappings des composants</h2></div></div><div></div></div><p>
        La notion de <span class="emphasis"><em>composant</em></span> est r&eacute;utilis&eacute;e dans diff&eacute;rents
        contextes et pour diff&eacute;rents buts dans Hibernate.
    </p><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-dependentobjects"></a>7.1.&nbsp;Objets d&eacute;pendants</h2></div></div><div></div></div><p>
            Une composant est un objet contenu et qui est persist&eacute; comme un type de valeur,
            pas comme une entit&eacute;. Le terme "composant" fait r&eacute;f&eacute;rence &agrave; la notion de composition
            en programmation Orient&eacute;e Objet (pas aux composants architecturaux). Par exemple, 
            vous pourriez mod&eacute;liser une personne de cette fa&ccedil;on :
        </p><pre class="programlisting">public class Person {
    private java.util.Date birthday;
    private Name name;
    private String key;
    public String getKey() {
        return key;
    }
    private void setKey(String key) {
        this.key=key;
    }
    public java.util.Date getBirthday() {
        return birthday;
    }
    public void setBirthday(java.util.Date birthday) {
        this.birthday = birthday;
    }
    public Name getName() {
        return name;
    }
    public void setName(Name name) {
        this.name = name;
    }
    ......
    ......
}</pre><pre class="programlisting">public class Name {
    char initial;
    String first;
    String last;
    public String getFirst() {
        return first;
    }
    void setFirst(String first) {
        this.first = first;
    }
    public String getLast() {
        return last;
    }
    void setLast(String last) {
        this.last = last;
    }
    public char getInitial() {
        return initial;
    }
    void setInitial(char initial) {
        this.initial = initial;
    }
}</pre><p>
            <tt class="literal">Name</tt> peut &ecirc;tre persist&eacute; en tant que composant
            de <tt class="literal">Person</tt>. Notez que <tt class="literal">Name</tt> d&eacute;finit des
            m&eacute;thodes getter/setter pour ses propri&eacute;t&eacute;s persistantes, mais n'a ni besoin 
            de d&eacute;clarer d'interface particuli&egrave;re, ni besoin d'une propri&eacute;t&eacute; d'identifiant.
        </p><p>
            Notre mapping hibernate ressemblera &agrave; :
        </p><pre class="programlisting">&lt;class name="eg.Person" table="person"&gt;
    &lt;id name="Key" column="pid" type="string"&gt;
        &lt;generator class="uuid.hex"/&gt;
    &lt;/id&gt;
    &lt;property name="birthday" type="date"/&gt;
    &lt;component name="Name" class="eg.Name"&gt; &lt;!-- attribut class optionnel --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/component&gt;
&lt;/class&gt;</pre><p>
            La table personne contient les colonnes <tt class="literal">pid</tt>,
            <tt class="literal">birthday</tt>,
            <tt class="literal">initial</tt>,
            <tt class="literal">first</tt> et
            <tt class="literal">last</tt>.
        </p><p>
            Comme tous les types de valeur, les composants ne supportent par les 
            r&eacute;f&eacute;rences partag&eacute;es. La s&eacute;mantique de la valeur nulle d'un composant 
            est <span class="emphasis"><em>intrins&egrave;que</em></span>. Lorsque l'on recharge l'objet contenu, 
            Hibernate consid&egrave;rera que si toutes les colonnes du composant sont nulles, 
            alors le composant dans son ensemble est nul. 
            Ce comportement devrait &ecirc;tre appripri&eacute; dans la plupart des cas.
        </p><p>
            Les propri&eacute;t&eacute;s d'un composant peuvent &ecirc;tre de n'importe quel type Hibernate
            (collections, association plusieurs-vers-un, autres composants, etc). Les
            composants dans des composants ne devraient <span class="emphasis"><em>pas</em></span> &ecirc;tre
            consid&eacute;r&eacute;s comme exotiques. Hibernate est fait pour supporter un mod&egrave;le
            objet tr&egrave;s fin.
        </p><p>
            L'&eacute;l&eacute;ment <tt class="literal">&lt;component&gt;</tt> accepte un sous-&eacute;l&eacute;ment
            <tt class="literal">&lt;parent&gt;</tt> qui mappe une propri&eacute;t&eacute; de la classe
            du composant vers une r&eacute;f&eacute;rence &agrave; l'entit&eacute; contenant l'&eacute;l&eacute;ment.
        </p><pre class="programlisting">&lt;class name="eg.Person" table="person"&gt;
    &lt;id name="Key" column="pid" type="string"&gt;
        &lt;generator class="uuid.hex"/&gt;
    &lt;/id&gt;
    &lt;property name="birthday" type="date"/&gt;
    &lt;component name="Name" class="eg.Name"&gt;
        &lt;parent name="namedPerson"/&gt; &lt;!-- reference vers Person --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/component&gt;
&lt;/class&gt;</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-incollections"></a>7.2.&nbsp;Collections d'objets dependants</h2></div></div><div></div></div><p>
            Les collections d'objets d&eacute;pendants sont support&eacute;es (ex un tableau
            de type <tt class="literal">Name</tt>). D&eacute;clarez votre collection de 
            composants en rempla&ccedil;ant la balise <tt class="literal">&lt;element&gt;</tt>
            par une balise <tt class="literal">&lt;composite-element&gt;</tt>.
        </p><pre class="programlisting">&lt;set name="someNames" table="some_names" lazy="true"&gt;
    &lt;key column="id"/&gt;
    &lt;composite-element class="eg.Name"&gt; &lt;!-- attribut class requis --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/composite-element&gt;
&lt;/set&gt;</pre><p>
            Note : si vous utilisez un <tt class="literal">Set</tt> d'&eacute;l&eacute;ments compos&eacute;s, il
            est tr&egrave;s important d'impl&eacute;menter <tt class="literal">equals()</tt> et 
            <tt class="literal">hashCode()</tt> correctement.
        </p><p>
            Les &eacute;l&eacute;ments compos&eacute;s peuvent eux-m&ecirc;mes contenir des composants mais
            pas de collection. Si votre composant contient d'autres composants,
            utiliser la balise <tt class="literal">&lt;nested-composite-element&gt;</tt>.
            C'est un cas plut&ocirc;t exotique - une collection de composants qui eux-m&ecirc;mes
            ont des composants. Face &agrave; cette situation vous devriez vous demander si
            une association un-&agrave;-plusieurs n'est pas plus adapt&eacute;e. Essayez de remodeler
            l'&eacute;l&eacute;ment compos&eacute; en une entit&eacute; - mais notez que bien que le mod&egrave;le Java
            restera identique, le mod&egrave;le relationnel et la s&eacute;mantique de persistance
            &eacute;tant l&eacute;g&egrave;rement diff&eacute;rents.
        </p><p>
            Notez qu'un mapping d'&eacute;l&eacute;ments composites ne supporte pas les propri&eacute;t&eacute;s
            nullables lorsque vous utilisez un <tt class="literal">&lt;set&gt;</tt>. 
            Hibernate doit utiliser chaque valeur de colonnes pour identifier un enregistrement
            lorsqu'il supprime les objets (il n'y a pas de colonne s&eacute;par&eacute;e faisant office de
            cl&eacute; primaire dans la table des &eacute;l&eacute;ments composites), et ce n'est pas possible
            avec des valeurs nulles. Vou devez donc soit vous limiter &agrave; des propri&eacute;t&eacute;s non-nulles,
            soit choisir <tt class="literal">&lt;list&gt;</tt>, <tt class="literal">&lt;map&gt;</tt>,
            <tt class="literal">&lt;bag&gt;</tt> ou <tt class="literal">&lt;idbag&gt;</tt> lors de
            vos mappings d'&eacute;l&eacute;ments composites.
        </p><p>
            Un cas particulier d'&eacute;l&eacute;ment composite est un &eacute;l&eacute;ment composite contenant
            un &eacute;l&eacute;ment <tt class="literal">&lt;many-to-one&gt;</tt>. Un tel mapping vous 
            permet de mapper les colonnes suppl&eacute;mentaires d'une table d'association
            plusieurs-vers-plusieurs et de les rendre accessibles dans la classe de l'&eacute;l&eacute;ment
            composite. L'exemple suivant est une association plusieurs-vers-plusieurs
            entre une <tt class="literal">Order</tt> (commande) et un <tt class="literal">Item</tt>
            (article) o&ugrave; <tt class="literal">purchaseDate</tt>, <tt class="literal">price</tt> et
            <tt class="literal">quantity</tt> sont des propri&eacute;t&eacute;s de l'association :
        </p><pre class="programlisting">&lt;class name="eg.Order" .... &gt;
    ....
    &lt;set name="purchasedItems" table="purchase_items" lazy="true"&gt;
        &lt;key column="order_id"&gt;
        &lt;composite-element class="eg.Purchase"&gt;
            &lt;property name="purchaseDate"/&gt;
            &lt;property name="price"/&gt;
            &lt;property name="quantity"/&gt;
            &lt;many-to-one name="item" class="eg.Item"/&gt; &lt;!-- l'attribut classe est optionnel --&gt;
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>De la m&ecirc;me fa&ccedil;on les associations ternaires (ou quaternaires, etc...) 
        sont possibles :</p><pre class="programlisting">&lt;class name="eg.Order" .... &gt;
    ....
    &lt;set name="purchasedItems" table="purchase_items" lazy="true"&gt;
        &lt;key column="order_id"&gt;
        &lt;composite-element class="eg.OrderLine"&gt;
            &lt;many-to-one name="purchaseDetails class="eg.Purchase"/&gt;
            &lt;many-to-one name="item" class="eg.Item"/&gt;
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
            Les &eacute;l&eacute;ments composites peuvent faire partie des requ&ecirc;tes en utilisant
            la m&ecirc;me syntaxe que celle utilis&eacute;e pour les associations entre entit&eacute;s.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-asmapindex"></a>7.3.&nbsp;Composants pour les indexes de Map</h2></div></div><div></div></div><p>
            L'&eacute;l&eacute;ment <tt class="literal">&lt;composite-index&gt;</tt> vous permet de mapper
            une classe composant en tant que cl&eacute; d'une <tt class="literal">Map</tt>. V&eacute;rifier
            que vous avez bien surcharg&eacute; <tt class="literal">hashCode()</tt> et 
            <tt class="literal">equals()</tt> dans la classe composant.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-compositeid"></a>7.4.&nbsp;composants en tant qu'identifiants compos&eacute;s</h2></div></div><div></div></div><p>
            Vous pouvez utiliser un composant comme identifiant d'une classe d'entit&eacute;.
            Votre composant doit satisfaire certains crit&egrave;res :
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Il doit impl&eacute;menter <tt class="literal">java.io.Serializable</tt>.
                </p></li><li><p>
                    Il doit r&eacute;impl&eacute;menter  <tt class="literal">equals()</tt> et
                    <tt class="literal">hashCode()</tt> de mani&egrave;re consistante avec la
                    notion d'&eacute;galit&eacute; d'une cl&eacute; composite dans la base de donn&eacute;es.
                </p></li></ul></div><p>
            Vous ne pouvez pas utiliser d'<tt class="literal">IdentifierGenerator</tt> pour g&eacute;n&eacute;rer de
            cl&eacute;s compos&eacute;es. L'application doit au contraire assigner ses propres identifiants
        </p><p>
            Dans la mesure ou un identifiant compos&eacute; doit &ecirc;tre assign&eacute; avant de pouvoir
            sauver l'objet, on ne peut pas utiliser la propri&eacute;t&eacute; <tt class="literal">unsaved-value</tt>
            de l'identifiant pour distinguer les instances nouvelles des instances sauv&eacute;es
            dans une pr&eacute;d&eacute;dente session.
        </p><p>
            Vous pouvez &agrave; la place impl&eacute;menter <tt class="literal">Interceptor.isUnsaved()</tt>
            si vous souhaitez tout de m&ecirc;me utiliser <tt class="literal">saveOrUpdate()</tt>
            ou la sauvegarde / mise &agrave; jour en cascade. Vous pouvez &eacute;galement positionner
            l'attribut <tt class="literal">unsaved-value</tt> sur l'&eacute;l&eacute;ment 
            <tt class="literal">&lt;version&gt;</tt> (ou <tt class="literal">&lt;timestamp&gt;</tt>)
            pour sp&eacute;cifier une valeur qui indique une nouvelle instance transiante.
            Dans ce cas, la version de l'entit&eacute; est utilis&eacute;e &agrave; la place de l'identifiant
            (assign&eacute;), et vous n'avez pas &agrave; impl&eacute;menter vous-m&ecirc;me
             <tt class="literal">Interceptor.isUnsaved()</tt>.
        </p><p>
            Utilisez l'&eacute;l&eacute;ment <tt class="literal">&lt;composite-id&gt;</tt> (m&ecirc;mes attributs et
            &eacute;l&eacute;ments que <tt class="literal">&lt;component&gt;</tt>) au lieu de
            <tt class="literal">&lt;id&gt;</tt> pour la d&eacute;claration d'une classe identifiant 
            compos&eacute; :
        </p><pre class="programlisting">&lt;class name="eg.Foo" table"FOOS"&gt;
    &lt;composite-id name="compId" class="eg.FooCompositeID"&gt;
        &lt;key-property name="string"/&gt;
        &lt;key-property name="short"/&gt;
        &lt;key-property name="date" column="date_" type="date"/&gt;
    &lt;/composite-id&gt;
    &lt;property name="name"/&gt;
    ....
&lt;/class&gt;</pre><p>
            En cons&eacute;quence, chaque cl&eacute; &eacute;trang&egrave;re vers la table <tt class="literal">FOOS</tt> 
            est aussi compos&eacute;e. Vous devez d&eacute;clarez ceci dans les mappings de et vers
            les autres classes. Une association vers  <tt class="literal">Foo</tt> 
            serait d&eacute;clar&eacute;e comme :
        </p><pre class="programlisting">&lt;many-to-one name="foo" class="eg.Foo"&gt;
&lt;!-- l'attribut class est optionnel, comme d'habitude --&gt;
    &lt;column name="foo_string"/&gt;
    &lt;column name="foo_short"/&gt;
    &lt;column name="foo_date"/&gt;
&lt;/many-to-one&gt;</pre><p>
        Le nouvel &eacute;l&eacute;ment <tt class="literal">&lt;column&gt;</tt> est aussi utilis&eacute; par les 
        types personnalis&eacute;s &agrave; multiple colonnes.
        C'est une alternative &agrave; l'attribut <tt class="literal">column</tt>. Une collection
	avec des &eacute;l&eacute;ments de type <tt class="literal">Foo</tt> utiliserait :
    </p><pre class="programlisting">&lt;set name="foos"&gt;
    &lt;key column="owner_id"/&gt;
    &lt;many-to-many class="eg.Foo"&gt;
        &lt;column name="foo_string"/&gt;
        &lt;column name="foo_short"/&gt;
        &lt;column name="foo_date"/&gt;
    &lt;/many-to-many&gt;
&lt;/set&gt;</pre><p>
            Comme d'habitude, <tt class="literal">&lt;one-to-many&gt;</tt>, ne d&eacute;clare pas de colonne.
        </p><p>
            Si <tt class="literal">Foo</tt> contient lui m&ecirc;me des collections, elles auront 
            aussi besoin d'une cl&eacute; &eacute;trang&egrave;re compos&eacute;e.
        </p><pre class="programlisting">&lt;class name="eg.Foo"&gt;
    ....
    ....
    &lt;set name="dates" lazy="true"&gt;
        &lt;key&gt;   &lt;!-- une collection h&eacute;rite du type de cl&eacute; composite --&gt;
            &lt;column name="foo_string"/&gt;
            &lt;column name="foo_short"/&gt;
            &lt;column name="foo_date"/&gt;
        &lt;/key&gt;
        &lt;element column="foo_date" type="date"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-dynamic"></a>7.5.&nbsp;Composants dynamiques</h2></div></div><div></div></div><p>
            Vous pouvez m&ecirc;me mapper une propri&eacute;t&eacute; de type <tt class="literal">Map</tt>:
        </p><pre class="programlisting">&lt;dynamic-component name="userAttributes"&gt;
    &lt;property name="foo" column="FOO"/&gt;
    &lt;property name="bar" column="BAR"/&gt;
    &lt;many-to-one name="baz" class="eg.Baz" column="BAZ"/&gt;
&lt;/dynamic-component&gt;</pre><p>
            La d&eacute;finition d'un mapping de <tt class="literal">&lt;dynamic-component&gt;</tt> est identique
            &agrave; <tt class="literal">&lt;component&gt;</tt>. L'avantage de ce type de mapping est la
	    possibilit&eacute; de d&eacute;terminer les propri&eacute;t&eacute;s r&eacute;elles du bean au moment du d&eacute;ploiement,
	    en &eacute;ditant simplement le document de mapping (la manipulation &agrave; l'&eacute;x&eacute;cution du 
	    document de mapping est aussi possible, via un parseur DOM).
        </p></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="inheritance"></a>Chapitre&nbsp;8.&nbsp;Mapping de l'h&eacute;ritage de classe</h2></div></div><div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="inheritance-strategies"></a>8.1.&nbsp;Les trois strat&eacute;gies</h2></div></div><div></div></div><p>
            Hibernate supporte les trois strat&eacute;gies d'h&eacute;ritage de base.
        </p><div class="itemizedlist"><ul type="disc"><li><p>
            une table par hi&eacute;rarchie de classe (table per class hierarchy)
        </p></li><li><p>
            une table par classe fille (table per subclass)
        </p></li><li><p>
            une table par classe concr&ecirc;te (table per concrete class, avec limitations)
        </p></li></ul></div><p>
            Il est m&ecirc;me possible d'utiliser diff&eacute;rentes strat&eacute;gies de mapping pour
	    diff&eacute;rentes branches d'une m&ecirc;me hi&eacute;rarchie d'h&eacute;ritage, mais les m&ecirc;mes
	    limitations, que celle rencontr&eacute;es dans la strat&eacute;gie une table par classe
        concr&egrave;te, s'appliquent.
	    Hibernate ne supporte pas le m&eacute;lange des mappings <tt class="literal">&lt;subclass&gt;</tt> 
	    et <tt class="literal">&lt;joined-subclass&gt;</tt> dans un m&ecirc;me &eacute;l&eacute;ment
            <tt class="literal">&lt;class&gt;</tt>.
        </p><p>
            Supposons que nous ayons une interface <tt class="literal">Payment</tt>, impl&eacute;ment&eacute;e
	    par <tt class="literal">CreditCardPayment</tt>, <tt class="literal">CashPayment</tt>,
            <tt class="literal">ChequePayment</tt>. La strat&eacute;gie une table par hi&eacute;rarchie serait :
        </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        ...
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
            Une seule table est requise. Une grande limitation de cette
	    strat&eacute;gie est que les colonnes d&eacute;clar&eacute;es par les classes filles ne peuvent
	    avoir de contrainte <tt class="literal">NOT NULL</tt>.
        </p><p>
            La strat&eacute;gie une table par classe fille serait :
        </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;joined-subclass name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
&lt;/class&gt;</pre><p>
            Quatre tables sont requises. Les trois tables des classes filles ont
	    une cl&eacute; primaire associ&eacute;e &agrave; la table classe m&egrave;re (le mod&egrave;le relationnel
	    est une association un-vers-un).
        </p><p>
            Notez que l'impl&eacute;mentation Hibernate de la strat&eacute;gie un table par 
        classe fille ne n&eacute;cessite pas de colonne discriminante dans la table 
        classe m&egrave;re. D'autres impl&eacute;mentations de mappers Objet/Relationnel utilisent
        une autre impl&eacute;mentation de la strat&eacute;gie une table par classe fille qui n&eacute;cessite
        une colonne de type discriminant dans la table de la classe m&egrave;re. L'approche
	    prise par Hibernate est plus difficile &agrave; impl&eacute;menter mais plus correcte
	    d'une point de vue relationnel.
        </p><p>
            Pour chacune de ces deux strat&eacute;gies de mapping, une association
	    polymorphique vers <tt class="literal">Payment</tt> est mapp&eacute;e en utilisant
            <tt class="literal">&lt;many-to-one&gt;</tt>.
        </p><pre class="programlisting">&lt;many-to-one name="payment"
    column="PAYMENT"
    class="Payment"/&gt;</pre><p>La strat&eacute;gie une table par classe concr&egrave;te est tr&egrave;s diff&eacute;rente.</p><pre class="programlisting">&lt;class name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CREDIT_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CREDIT_AMOUNT"/&gt;
    ...
&lt;/class&gt;

&lt;class name="CashPayment" table="CASH_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CASH_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CASH_AMOUNT"/&gt;
    ...
&lt;/class&gt;

&lt;class name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CHEQUE_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CHEQUE_AMOUNT"/&gt;
    ...
&lt;/class&gt;</pre><p>
            Trois tables sont requises. Notez que l'interface <tt class="literal">Payment</tt>
	    n'est jamais explicitement nomm&eacute;e. A la place, nous
	    utilisons le <span class="emphasis"><em>polymorphisme implicite</em></span> d'Hibernate.
	    Notez aussi que les propri&eacute;t&eacute;s de <tt class="literal">Payment</tt> sont
	    mapp&eacute;es dans chacune des classes filles.
        </p><p>
            Dans ce cas, une association polymorphique vers <tt class="literal">Payment</tt>
            est mapp&eacute;e en utilisant <tt class="literal">&lt;any&gt;</tt>.
        </p><pre class="programlisting">&lt;any name="payment"
        meta-type="class"
        id-type="long"&gt;
    &lt;column name="PAYMENT_CLASS"/&gt;
    &lt;column name="PAYMENT_ID"/&gt;
&lt;/any&gt;</pre><p>
            Il serait plus judicieux de d&eacute;finir un <tt class="literal">UserType</tt>
            comme <tt class="literal">meta-type</tt>, pour g&eacute;rer le mapping
	    entre une cha&icirc;ne de caract&egrave;re discriminante et les
	    classes filles de <tt class="literal">Payment</tt>.
        </p><pre class="programlisting">&lt;any name="payment"
        meta-type="PaymentMetaType"
        id-type="long"&gt;
    &lt;column name="PAYMENT_TYPE"/&gt; &lt;!-- CREDIT, CASH or CHEQUE --&gt;
    &lt;column name="PAYMENT_ID"/&gt;
&lt;/any&gt;</pre><p>
            Il y a une autre chose &agrave; savoir sur ce mapping.
	    Dans la mesure o&ugrave; chaque classe fille est mapp&eacute;e dans leur
	    propre &eacute;l&eacute;ment <tt class="literal">&lt;class&gt;</tt>  
	    (et puisque <tt class="literal">Payment</tt> n'est qu'une interface), 
	    chacune des classes filles peut facilement faire partie
	    d'une autre strat&eacute;gie d'h&eacute;ritage que cela soit une table par hi&eacute;rarchie 
	    ou une table par classe fille ! (et vous pouvez toujours utiliser
	    des requ&ecirc;tes polymorphiques vers l'interface)
            <tt class="literal">Payment</tt>).
       </p><pre class="programlisting">&lt;class name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CREDIT_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="CREDIT_CARD" type="string"/&gt;
    &lt;property name="amount" column="CREDIT_AMOUNT"/&gt;
    ...
    &lt;subclass name="MasterCardPayment" discriminator-value="MDC"/&gt;
    &lt;subclass name="VisaPayment" discriminator-value="VISA"/&gt;
&lt;/class&gt;

&lt;class name="NonelectronicTransaction" table="NONELECTRONIC_TXN"&gt;
    &lt;id name="id" type="long" column="TXN_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    ...
    &lt;joined-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="amount" column="CASH_AMOUNT"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="amount" column="CHEQUE_AMOUNT"/&gt;
        ...
    &lt;/joined-subclass&gt;
&lt;/class&gt;</pre><p>
            Encore une fois, nous ne mentionnons pas explicitement <tt class="literal">Payment</tt>. 
	    Si nous ex&eacute;cutons une requ&ecirc;te sur l'interface <tt class="literal">Payment</tt> - par
            exemple, <tt class="literal">from Payment</tt> - Hibernate retournera
	    automatiquement les instances de <tt class="literal">CreditCardPayment</tt>
            (et ses classes filles puisqu'elles impl&eacute;mentent aussi <tt class="literal">Payment</tt>),
            <tt class="literal">CashPayment</tt> et <tt class="literal">ChequePayment</tt> mais pas
	    les instances de <tt class="literal">NonelectronicTransaction</tt>.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="inheritance-limitations"></a>8.2.&nbsp;Limitations</h2></div></div><div></div></div><p>
            Hibernate suppose qu'une association mappe exactement une colonne cl&eacute; &eacute;trang&egrave;re.
	    Plusieurs associations par cl&eacute; &eacute;trang&egrave;re sont tol&eacute;r&eacute;es (vous pouvez avoir besoin
	    de sp&eacute;cifier <tt class="literal">inverse="true"</tt> ou <tt class="literal">insert="false" update="false"</tt>),
            mais il n'est pas possible de mapper chaque association vers plusieurs cl&eacute;s
	    &eacute;trang&egrave;res. Ceci signifie que :
        </p><div class="itemizedlist"><ul type="disc"><li><p>
            quand une association est modifi&eacute;e, c'est toujours la m&ecirc;me cl&eacute; &eacute;trang&egrave;re qui
	    est mise &agrave; jour
        </p></li><li><p>
            quand une association est charg&eacute;e de mani&egrave;re tardive, une seule requ&ecirc;te
	    &agrave; la base de donn&eacute;es est utilis&eacute;e
        </p></li><li><p>
            quand une association est charg&eacute;e imm&eacute;diatement, elle peut l'&ecirc;tre en
            utilisant une simple jointure ouverte
        </p></li></ul></div><p>
            Ceci implique que les associations polymorphiques un-vers-plusieurs vers des
	    classes mapp&eacute;es en utilisant la strat&eacute;gie une table par classe concr&egrave;te
            <span class="emphasis"><em>ne sont pas support&eacute;es</em></span> (charger ces associations
	    n&eacute;cessiterait de multiples requ&ecirc;tes ou jointures ouverte).
        </p><p>
            Le tableau montre les limitations des mappings une table par classe concr&egrave;te,
            et du polymorphique implicite, avec Hibernate.
        </p><div class="table"><a name="d0e5766"></a><p class="title"><b>Tableau&nbsp;8.1.&nbsp;Caract&eacute;ristiques des strat&eacute;gies d'h&eacute;ritages</b></p><table summary="Caract&eacute;ristiques des strat&eacute;gies d'h&eacute;ritages" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Strat&eacute;gie d'h&eacute;ritage</th><th align="left">Plusieurs-vers-un polymorphiques</th><th align="left">Un-vers-un polymorphiques</th><th align="left">Un-vers-plusieurs polymorphiques</th><th align="left">Plusieurs-vers-plusieurs polymorphiques</th><th align="left"><tt class="literal">load()/get()</tt> polymorphiques</th><th align="left">Requ&ecirc;tes polymorphiques</th><th align="left">Jointures polymorphiques</th><th align="left">Jointures ouvertes polymorphiques</th></tr></thead><tbody><tr><td align="left">une table par hi&eacute;rarchie de classe</td><td align="left"><tt class="literal">&lt;many-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-many&gt;</tt></td><td align="left"><tt class="literal">&lt;many-to-many&gt;</tt></td><td align="left"><tt class="literal">s.get(Payment.class, id)</tt></td><td align="left"><tt class="literal">from Payment p</tt></td><td align="left"><tt class="literal">from Order o join o.payment p</tt></td><td align="left"><span class="emphasis"><em>support&eacute;es</em></span></td></tr><tr><td align="left">une table par classe fille</td><td align="left"><tt class="literal">&lt;many-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-many&gt;</tt></td><td align="left"><tt class="literal">&lt;many-to-many&gt;</tt></td><td align="left"><tt class="literal">s.get(Payment.class, id)</tt></td><td align="left"><tt class="literal">from Payment p</tt></td><td align="left"><tt class="literal">from Order o join o.payment p</tt></td><td align="left"><span class="emphasis"><em>support&eacute;es</em></span></td></tr><tr><td align="left">une table par classe concr&egrave;te (polymorphisme implicite)</td><td align="left"><tt class="literal">&lt;any&gt;</tt></td><td align="left"><span class="emphasis"><em>non support&eacute;s</em></span></td><td align="left"><span class="emphasis"><em>non support&eacute;s</em></span></td><td align="left"><tt class="literal">&lt;many-to-any&gt;</tt></td><td align="left"><span class="emphasis"><em>utiliser un requ&ecirc;te</em></span></td><td align="left"><tt class="literal">from Payment p</tt></td><td align="left"><span class="emphasis"><em>non support&eacute;es</em></span></td><td align="left"><span class="emphasis"><em>non support&eacute;es</em></span></td></tr></tbody></table></div></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="manipulatingdata"></a>Chapitre&nbsp;9.&nbsp;Manipuler les donn&eacute;es persistantes</h2></div></div><div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-creating"></a>9.1.&nbsp;Cr&eacute;ation d'un objet persistant</h2></div></div><div></div></div><p>
            Un objet (une instance entit&eacute;) est <span class="emphasis"><em>transiant</em></span> ou
            <span class="emphasis"><em>persistant</em></span> pour une <tt class="literal">Session</tt> donn&eacute;e. 
	    Les objets nouvellement instanci&eacute;s sont bien s&ucirc;r transiants. La session offre 
        les services de sauvegarde (de persistence) des instances transiantes :
        </p><pre class="programlisting">DomesticCat fritz = new DomesticCat();
fritz.setColor(Color.GINGER);
fritz.setSex('M');
fritz.setName("Fritz");
Long generatedId = (Long) sess.save(fritz);</pre><pre class="programlisting">DomesticCat pk = new DomesticCat();
pk.setColor(Color.TABBY);
pk.setSex('F');
pk.setName("PK");
pk.setKittens( new HashSet() );
pk.addKitten(fritz);
sess.save( pk, new Long(1234) );</pre><p>
            <tt class="literal">save()</tt> avec un seul argument, g&eacute;n&egrave;re et assigne un identifiant
            unique &agrave; <tt class="literal">fritz</tt>. La m&ecirc;me m&eacute;thode avec deux arguments essaie de persister
            <tt class="literal">pk</tt> en utilisant l'identifiant donn&eacute;. G&eacute;n&eacute;ralement, nous vous d&eacute;conseillons
            l'utilisation de la version &agrave; deux arguments puisqu'elle pourrait &ecirc;tre utilis&eacute;e pour cr&eacute;er
	    des cl&eacute;s primaires avec une signification m&eacute;tier. Elle est plus efficace, dans certaines situations,
	    comme l'utilisation d'Hibernate pour la persistance d'un Entity Bean BMP. 
        </p><p>
            Les objets associ&eacute;s peuvent &ecirc;tre persist&eacute;s dans l'ordre que vous voulez du moment que vous
            n'avez pas de contrainte <tt class="literal">NOT NULL</tt> sur une cl&eacute; &eacute;trang&egrave;re. 
            Il n'y a aucun risque de violation de contrainte de cl&eacute; &eacute;trang&egrave;re. Cependant, vous
            pourriez violer une contrainte <tt class="literal">NOT NULL</tt> si vous invoquiez <tt class="literal">save()</tt>
	    sur des objets dans le mauvais ordre.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-loading"></a>9.2.&nbsp;Chargement d'un objet</h2></div></div><div></div></div><p>
            La m&eacute;thode <tt class="literal">load()</tt> offerte par la <tt class="literal">Session</tt> vous permet
            de r&eacute;cup&eacute;rer une instance persistante si vous connaissez son identifiant.
            Une des versions prend comme argument un objet class et charge l'&eacute;tat dans un objet
            nouvellement instanci&eacute;. La seconde version permet d'alimenter une instance dans laquelle 
            l'&eacute;tat sera charg&eacute;. La version qui prend comme argument une instance est 
            particul&egrave;rement utile si vous pensez utiliser Hibernate avec des Entity Bean BMP,
            elle est fournie dans ce but. Vous d&eacute;couvrirez d'autres cas o&ugrave; l'utiliser
            (Pooling d'instance maison, etc.)
        </p><pre class="programlisting">Cat fritz = (Cat) sess.load(Cat.class, generatedId);</pre><pre class="programlisting">// il est n&eacute;cessaire de transformer les identifiants primitifs
long pkId = 1234;
DomesticCat pk = (DomesticCat) sess.load( Cat.class, new Long(pkId) );</pre><pre class="programlisting">Cat cat = new DomesticCat();
// charge l'&eacute;tat de pk dans cat
sess.load( cat, new Long(pkId) );
Set kittens = cat.getKittens();</pre><p>
            Il est &agrave; noter que <tt class="literal">load()</tt> l&egrave;vera une exception irr&eacute;versible 
            s'il ne trouve pas d'enregistrement correspondant en base donn&eacute;es. 
            Si la classe est mapp&eacute;e avec un proxy, <tt class="literal">load()</tt> retourne un 
            objet qui est un proxy non initialis&eacute; et n'interrogera la base de donn&eacute;es 
            qu'&agrave; la premi&egrave;re invocation d'une m&eacute;thode de l'objet. Ce comportement est tr&egrave;s 
            utile si vous voulez cr&eacute;er une association vers un objet sans r&eacute;ellement 
            le charger depuis la base de donn&eacute;es. 
        </p><p>
            Si vous n'&ecirc;tes par certain que l'enregistrement correspondant existe, vous 
            devriez utiliser la m&eacute;thode <tt class="literal">get()</tt>, qui interroge 
            imm&eacute;diatement la base de donn&eacute;es et retourne null s'il n'y a aucun
	    enregistrement correspondant. 
        </p><pre class="programlisting">Cat cat = (Cat) sess.get(Cat.class, id);
if (cat==null) {
    cat = new Cat();
    sess.save(cat, id);
}
return cat;</pre><p>
            Vous pouvez aussi charger un objet en utilisant un ordre SQL de type
        <tt class="literal">SELECT ... FOR UPDATE</tt>. R&eacute;f&eacute;rez vous &agrave; la section suivante 
        pour une pr&eacute;sentation des <tt class="literal">LockMode</tt>s d'Hibernate. 
        </p><pre class="programlisting">Cat cat = (Cat) sess.get(Cat.class, id, LockMode.UPGRADE);</pre><p>
            Notez que les instances associ&eacute;es ou collections contenues ne sont 
        <span class="emphasis"><em>pas</em></span> selectionn&eacute;es en utilisant "<tt class="literal">FOR UPDATE</tt>". 
        </p><p>
            Il est possible de recharger un objet et toutes ses collections &agrave; n'importe 
            quel moment en utilisant la m&eacute;thode <tt class="literal">refresh()</tt>. 
            Ceci est utile quand les triggers d'une base de donn&eacute;es sont utilis&eacute;s
            pour initialiser certaines propri&eacute;t&eacute;s de l'objet. 
        </p><pre class="programlisting">sess.save(cat);
sess.flush(); //force l'ordre SQL INSERT
sess.refresh(cat); //recharge l'&eacute;tat (apr&egrave;s ex&eacute;cution des triggers)</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-querying"></a>9.3.&nbsp;Requ&ecirc;tage</h2></div></div><div></div></div><p>
            Si vous ne connaissez pas le(s) identifiant(s) de l'objet (ou des objets) 
            que vous recherchez, utlisez la m&eacute;thode <tt class="literal">find()</tt> 
            offerte par la <tt class="literal">Session</tt>. Hibernate s'appuie sur
	    un langage d'interrogation, orient&eacute; objet, simple mais puissant. 
        </p><pre class="programlisting">List cats = sess.find(
    "from Cat as cat where cat.birthdate = ?",
    date,
    Hibernate.DATE
);

List mates = sess.find(
    "select mate from Cat as cat join cat.mate as mate " +
    "where cat.name = ?",
    name,
    Hibernate.STRING
);

List cats = sess.find( "from Cat as cat where cat.mate.bithdate is null" );

List moreCats = sess.find(
    "from Cat as cat where " + 
    "cat.name = 'Fritz' or cat.id = ? or cat.id = ?",
    new Object[] { id1, id2 },
    new Type[] { Hibernate.LONG, Hibernate.LONG }
);

List mates = sess.find(
    "from Cat as cat where cat.mate = ?",
    izi,
    Hibernate.entity(Cat.class)
);

List problems = sess.find(
    "from GoldFish as fish " +
    "where fish.birthday &gt; fish.deceased or fish.birthday is null"
);</pre><p>
            Le second argument de <tt class="literal">find()</tt> est un objet ou un tableau d'objets. 
	    Le troisi&egrave;me argument est un type Hibernate ou un tableau de types Hibernate. 
	    Ces types pass&eacute;s en argument sont utilis&eacute;s pour lier les objets pass&eacute;s en argument au
        <tt class="literal">?</tt> de la requ&ecirc;te (ce qui correspond aux IN parameters d'un 
        <tt class="literal">PreparedStatement</tt> JDBC). Comme en JDBC, il est pr&eacute;f&eacute;rable
        d'utiliser ce m&eacute;canisme de liaison (binding) plut&ocirc;t que la
	    manipulation de cha&icirc;ne de caract&egrave;res. 
        </p><p>
            La classe <tt class="literal">Hibernate</tt> d&eacute;finit un certain nombre de m&eacute;thodes statiques
            et de constantes, proposant l'acc&egrave;s &agrave; la plupart des types utilis&eacute;s, comme les instances
            de <tt class="literal">net.sf.hibernate.type.Type</tt>. 
        </p><p>
            Si vous pensez que votre requ&ecirc;te retournera un tr&egrave;s grand nombre d'objets, mais que vous
            n'avez pas l'intention de tous les utliser, vous pourriez am&eacute;liorer les performances en
            utilisant la m&eacute;thode <tt class="literal">iterate()</tt>, qui retourne un 
            <tt class="literal">java.util.Iterator</tt>. L'it&eacute;rateur chargera les objets 
            &agrave; la demande en utilisant les identifiants retoun&eacute;s par la requ&ecirc;te SQL 
	    initiale (ce qui fait un total de n+1 selects). 
        </p><pre class="programlisting">// it&eacute;ration sur les ids
Iterator iter = sess.iterate("from eg.Qux q order by q.likeliness"); 
while ( iter.hasNext() ) {
    Qux qux = (Qux) iter.next();  // r&eacute;cup&eacute;ration de l'objet
    // condition non d&eacute;finissable dans la requ&ecirc;te
    if ( qux.calculateComplicatedAlgorithm() ) {
        // effacez l'instance en cours
        iter.remove();
        // n'est plus n&eacute;cessaire pour faire le reste du process
        break;
    }
}</pre><p>
            Malheureusement, <tt class="literal">java.util.Iterator</tt> ne d&eacute;clare aucune exception,
            donc les exceptions SQL ou Hibernate qui seront soulev&eacute;es seront transform&eacute;es
            en <tt class="literal">LazyInitializationException</tt> 
            (une classe fille de <tt class="literal">RuntimeException</tt>).
        </p><p>
            La m&eacute;thode <tt class="literal">iterate()</tt> est &eacute;galement plus performante si
            vous pr&eacute;voyez que beaucoup d'objets soient d&eacute;j&agrave; charg&eacute;s et donc disponibles via 
            la session, ou si le r&eacute;sultat de la requ&ecirc;te retourne tr&egrave;s souvent les m&ecirc;mes objets 
	    (quand les donn&eacute;es ne sont pas en cache et ne sont pas dupliqu&eacute;s dans le r&eacute;sultat, 
        <tt class="literal">find()</tt> est presque toujours plus rapide). Voici un exemple de 
        requ&ecirc;te qui devrait &ecirc;tre appel&eacute;e via la m&eacute;thode <tt class="literal">iterate()</tt> :
        </p><pre class="programlisting">
Iterator iter = sess.iterate(
    "select customer, product " + 
    "from Customer customer, " +
    "Product product " +
    "join customer.purchases purchase " +
    "where product = purchase.product"
);</pre><p>
            Invoquer la requ&ecirc;te pr&eacute;c&eacute;dente avec <tt class="literal">find()</tt> retournerait un 
            <tt class="literal">ResultSet</tt> JDBC tr&egrave;s volumineux et contenant plusieurs
            fois les m&ecirc;mes donn&eacute;es.
        </p><p>
            Les requ&ecirc;tes Hibernate retournent parfois des tuples d'objets, 
            dans ce cas chaque tuple est retourn&eacute; sous forme de tableau (d'objets) :
        </p><pre class="programlisting">Iterator foosAndBars = sess.iterate(
    "select foo, bar from Foo foo, Bar bar " +
    "where bar.date = foo.date"
);
while ( foosAndBars.hasNext() ) {
    Object[] tuple = (Object[]) foosAndBars.next();
    Foo foo = (Foo) tuple[0]; Bar bar = (Bar) tuple[1];
    ....
}</pre><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-scalarqueries"></a>9.3.1.&nbsp;Requ&ecirc;tes scalaires</h3></div></div><div></div></div><p>
                Les requ&ecirc;tes peuvent sp&eacute;cifier une propri&eacute;t&eacute; d'une classe dans la clause <tt class="literal">select</tt>.
                Elles peuvent m&ecirc;me appeler les fonctions SQL d'aggr&eacute;gation. Ces propri&eacute;t&eacute;s ou aggr&eacute;gations sont consid&eacute;r&eacute;es
                comme des r&eacute;sultats "scalaires".
            </p><pre class="programlisting">Iterator results = sess.iterate(
        "select cat.color, min(cat.birthdate), count(cat) from Cat cat " +
        "group by cat.color"
);
while ( results.hasNext() ) {
    Object[] row = results.next();
    Color type = (Color) row[0];
    Date oldest = (Date) row[1];
    Integer count = (Integer) row[2];
    .....
}</pre><pre class="programlisting">Iterator iter = sess.iterate(
    "select cat.type, cat.birthdate, cat.name from DomesticCat cat"
);</pre><pre class="programlisting">List list = sess.find(
    "select cat, cat.mate.name from DomesticCat cat"
);</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-queryinterface"></a>9.3.2.&nbsp;L'interface de requ&ecirc;tage Query</h3></div></div><div></div></div><p>
                Si vous avez besoin de d&eacute;finir des limites sur le r&eacute;sultat d'une requ&ecirc;te (nombre 
		maximum d'enregistrements et / ou l'indice du premier r&eacute;sultat que vous souhaitez 
		r&eacute;cup&eacute;rer), utilisez une instance de <tt class="literal">net.sf.hibernate.Query</tt> :
            </p><pre class="programlisting">Query q = sess.createQuery("from DomesticCat cat");
q.setFirstResult(20);
q.setMaxResults(10);
List cats = q.list();</pre><p>
                Vous pouvez m&ecirc;me d&eacute;finir une requ&ecirc;te nomm&eacute;e dans le document de mapping. 
                N'oubliez pas qu'il faut utiliser une section <tt class="literal">CDATA</tt> 
                si votre requ&ecirc;te contient des caract&egrave;res qui pourraient &ecirc;tre interpr&eacute;t&eacute;s 
                comme un marqueur XML.
            </p><pre class="programlisting">&lt;query name="eg.DomesticCat.by.name.and.minimum.weight"&gt;&lt;![CDATA[
    from eg.DomesticCat as cat
        where cat.name = ?
        and cat.weight &gt; ?
] ]&gt;&lt;/query&gt;</pre><pre class="programlisting">Query q = sess.getNamedQuery("eg.DomesticCat.by.name.and.minimum.weight");
q.setString(0, name);
q.setInt(1, minWeight);
List cats = q.list();</pre><p>
        L'interface d'interrogation supporte l'utilisation de param&egrave;tres nomm&eacute;s. Les param&egrave;tres nomm&eacute;s
        sont des variables de la forme <tt class="literal">:name</tt> que l'on peut retrouver dans la requ&ecirc;te.
        <tt class="literal">Query</tt> dispose de m&eacute;thodes pour lier des valeurs &agrave; ces param&egrave;tres nomm&eacute;s ou
		aux param&egrave;tres <tt class="literal">?</tt> du style JDBC. <span class="emphasis"><em>Contrairement &agrave; JDBC, 
        l'indice des param&egrave;tres Hibernate d&eacute;marre de z&eacute;ro.</em></span> 
		Les avantages des param&egrave;tres nomm&eacute;s sont :
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        les param&egrave;tres nomm&eacute;s sont ind&eacute;pendants de l'ordre dans lequel 
                        ils apparaissent dans la requ&ecirc;te
                    </p></li><li><p>
                        ils peuvent &ecirc;tre pr&eacute;sents plusieurs fois dans une m&ecirc;me requ&ecirc;te
                    </p></li><li><p>
                        ils sont auto-document&eacute;s (par leur nom)
                    </p></li></ul></div><pre class="programlisting">//param&egrave;tre nomm&eacute; (pr&eacute;f&eacute;r&eacute;)
Query q = sess.createQuery("from DomesticCat cat where cat.name = :name");
q.setString("name", "Fritz");
Iterator cats = q.iterate();</pre><pre class="programlisting">//param&egrave;tre positionn&eacute;
Query q = sess.createQuery("from DomesticCat cat where cat.name = ?");
q.setString(0, "Izi");
Iterator cats = q.iterate();</pre><pre class="programlisting">//param&egrave;tre nomm&eacute; liste
List names = new ArrayList();
names.add("Izi");
names.add("Fritz");
Query q = sess.createQuery("from DomesticCat cat where cat.name in (:namesList)");
q.setParameterList("namesList", names);
List cats = q.list();</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-scrolling"></a>9.3.3.&nbsp;Iteration scrollable</h3></div></div><div></div></div><p>
                Si votre driver JDBC supporte les <tt class="literal">ResultSet</tt>s scrollables, l'interface 
		<tt class="literal">Query</tt> peut &ecirc;tre utilis&eacute;e pour obtenir des <tt class="literal">ScrollableResults</tt> 
        qui permettent une navigation plus flexible sur les r&eacute;sultats.
            </p><pre class="programlisting">Query q = sess.createQuery("select cat.name, cat from DomesticCat cat " +
                            "order by cat.name");
ScrollableResults cats = q.scroll();
if ( cats.first() ) {

    // cherche le premier 'name' de chaque page pour une liste de 'cats' tri&eacute;e par 'name'
    firstNamesOfPages = new ArrayList();
    do {
        String name = cats.getString(0);
        firstNamesOfPages.add(name);
    }
    while ( cats.scroll(PAGE_SIZE) );

    // Retourne la premi&egrave;re page de 'cats'
    pageOfCats = new ArrayList();
    cats.beforeFirst();
    int i=0;
    while( ( PAGE_SIZE &gt; i++ ) &amp;&amp; cats.next() ) pageOfCats.add( cats.get(1) );

}</pre><p>
                Le comportement de <tt class="literal">scroll()</tt> est similaire &agrave; celui d'<tt class="literal">iterate()</tt>, 
                &agrave; la diff&eacute;rence pr&egrave;s que les objets peuvent &ecirc;tre initialis&eacute;s de mani&egrave;re s&eacute;lective 
                avec <tt class="literal">get(int)</tt>, au lieu d'une initialisation compl&egrave;te d'une ligne
                de resultset.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-filtering"></a>9.3.4.&nbsp;Filtrer les collections</h3></div></div><div></div></div><p>
                Un filtre (<span class="emphasis"><em>filter</em></span>) de collection est un type 
                sp&eacute;cial de requ&ecirc;te qui peut &ecirc;tre appliqu&eacute; &agrave; une collection ou un 
                tableau persistant. La requ&ecirc;te peut faire r&eacute;f&eacute;rence &agrave; <tt class="literal">this</tt>,
                ce qui signifie "l'&eacute;l&eacute;ment de la collection courante".
            </p><pre class="programlisting">Collection blackKittens = session.filter(
    pk.getKittens(), "where this.color = ?", Color.BLACK, Hibernate.enum(Color.class)
);</pre><p>
                La collection retourn&eacute;e est consid&eacute;r&eacute;e comme un bag.
            </p><p>
                Remarquez que les filtres n'ont pas besoin de clause <tt class="literal">from</tt> 
                (bien qu'ils puissent en avoir une si n&eacute;cessaire). Les filtres ne sont pas 
                limit&eacute;s &agrave; retourner des &eacute;l&eacute;ments de la collection qu'ils filtrent.
            </p><pre class="programlisting">Collection blackKittenMates = session.filter(
    pk.getKittens(), "select this.mate where this.color = eg.Color.BLACK"
);</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-criteria"></a>9.3.5.&nbsp;Les requ&ecirc;tes par crit&egrave;res</h3></div></div><div></div></div><p>
                HQL est extr&ecirc;mement puissant mais certaines personnnes pr&eacute;f&egrave;reront 
                construire leurs requ&ecirc;tes dynamiquement, en utilisant une API orient&eacute;e 
                objet, plut&ocirc;t qu'une cha&icirc;ne de caract&egrave;res dans leur code JAVA. 
                Pour ces personnes, Hibernate fournit <tt class="literal">Criteria</tt> : 
                une API d'interrogation intuitive.
            </p><pre class="programlisting">Criteria crit = session.createCriteria(Cat.class);
crit.add( Expression.eq("color", eg.Color.BLACK) );
crit.setMaxResults(10);
List cats = crit.list();</pre><p>
                Si vous n'&ecirc;tes pas &agrave; l'aise avec les syntaxes type SQL, 
                c'est peut &ecirc;tre la mani&egrave;re la plus simple de commencer
		avec Hibernate. Cette API est aussi plus extensible que le HQL. 
        Les applications peuvent s'appuyer sur leur propre impl&eacute;mentation de 
        l'interface <tt class="literal">Criterion</tt>.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-nativesql"></a>9.3.6.&nbsp;Requ&ecirc;tes en SQL natif</h3></div></div><div></div></div><p>
                Vous pouvez construire votre requ&ecirc;te en SQL, en utilisant 
                <tt class="literal">createSQLQuery()</tt>. Il est n&eacute;cessaire
                de placer vos alias SQL entre accolades.
            </p><pre class="programlisting">List cats = session.createSQLQuery(
    "SELECT {cat.*} FROM CAT AS {cat} WHERE ROWNUM&lt;10", 
    "cat",
    Cat.class
).list();</pre><pre class="programlisting">List cats = session.createSQLQuery(
    "SELECT {cat}.ID AS {cat.id}, {cat}.SEX AS {cat.sex}, " +
           "{cat}.MATE AS {cat.mate}, {cat}.SUBCLASS AS {cat.class}, ... " +
    "FROM CAT AS {cat} WHERE ROWNUM&lt;10", 
    "cat",
    Cat.class
).list()</pre><p>
                Les requ&ecirc;tes SQL peuvent contenir des param&egrave;tres nomm&eacute;s et positionn&eacute;s, comme dans
		les requ&ecirc;tes Hibernate.
            </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-updating"></a>9.4.&nbsp;Mise &agrave; jour des objets</h2></div></div><div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-updating-insession"></a>9.4.1.&nbsp;Mise &agrave; jour dans la m&ecirc;me session</h3></div></div><div></div></div><p>
                <span class="emphasis"><em>Les instances transactionnelles persistantes</em></span> (objets charg&eacute;s, sauvegard&eacute;s, cr&eacute;&eacute;s ou
                r&eacute;sultats d'une recherche par la <tt class="literal">Session</tt>) peuvent &ecirc;tre manipul&eacute;es par l'application.
		Toute modification sur un &eacute;tat persistant sera sauvegard&eacute;e (persist&eacute;e) quand la <tt class="literal">Session</tt> 
        sera <span class="emphasis"><em>flush&eacute;e</em></span>
                (ceci sera d&eacute;crit plus tard dans ce chapitre). Le moyen le plus simple
                de modifier l'&eacute;tat d'un objet est donc de le charger (<tt class="literal">load()</tt>), 
                et de le manipuler pendant que la <tt class="literal">Session</tt> est ouverte :
            </p><pre class="programlisting">DomesticCat cat = (DomesticCat) sess.load( Cat.class, new Long(69) );
cat.setName("PK");
sess.flush();  // les modifications de 'cat' sont automatiquement d&eacute;tect&eacute;es et sauvegard&eacute;es</pre><p>
                Il arrive que cette approche ne convienne pas puisqu'elle n&eacute;cessite une m&ecirc;me session
		pour ex&eacute;cuter les deux ordres SQL <tt class="literal">SELECT</tt> (pour charger l'objet) et <tt class="literal">UPDATE</tt>
		(pour sauvegarder son &eacute;tat mis &agrave; jour) dans la m&ecirc;me session. Hibernate propose une m&eacute;thode alternative.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-updating-detached"></a>9.4.2.&nbsp;Mise &agrave; jour d'objets d&eacute;tach&eacute;s</h3></div></div><div></div></div><p>
                Certaines applications ont besoin de r&eacute;cup&eacute;rer un objet dans une transaction, de le passer
		ensuite &agrave; la couche de pr&eacute;sentation pour modification, et enfin de le sauvegarder dans
		une nouvelle transaction (les applications suivant cette approche se trouvent dans un
		contexte d'acc&egrave;s aux donn&eacute;es hautement concurrent, elles utilisent g&eacute;n&eacute;ralement des
		donn&eacute;es versionn&eacute;es pour assurer l'isolation des transactions). Cette approche
        n&eacute;cessite un mod&egrave;le de d&eacute;veloppement l&eacute;g&egrave;rement diff&eacute;rent de celui d&eacute;crit dans la 
		section pr&eacute;cedente. Hibernate supporte ce mod&egrave;le en proposant la m&eacute;thode 
        <tt class="literal">Session.update()</tt>.
            </p><pre class="programlisting">// dans la premi&egrave;re session
Cat cat = (Cat) firstSession.load(Cat.class, catId);
Cat potentialMate = new Cat();
firstSession.save(potentialMate);

// dans une couche sup&eacute;rieure de l'application
cat.setMate(potentialMate);

// plus tard, dans une nouvelle session
secondSession.update(cat);  // mise &agrave; jour de 'cat'
secondSession.update(mate); // mise &agrave; jour de  'mate'</pre><p>
                Si <tt class="literal">Cat</tt> avec l'identifiant <tt class="literal">catId</tt> avait 
                d&eacute;ja &eacute;t&eacute; charg&eacute; par <tt class="literal">secondSession</tt> au moment o&ugrave; 
                l'application essaie de le mettre &agrave; jour, une exception aurait &eacute;t&eacute; soulev&eacute;e.
            </p><p>
                L'application devrait unitairement mettre &agrave; jour (<tt class="literal">update()</tt>) les instances 
                transiantes	accessibles depuis l'instance transiante donn&eacute;e si et 
                <span class="emphasis"><em>seulement</em></span> si elle souhaite que leur &eacute;tat 
                soit aussi mis &agrave; jour (A l'exception des objets engag&eacute;s dans un cycle de vie
                dont nous parlerons	plus tard).
            </p><p>
                Les utilisateurs d'Hibernate ont &eacute;mis le souhait de pouvoir soit sauvegarder une
		instance transiante en g&eacute;n&eacute;rant un nouvel identifiant, soit mettre &agrave; jour son &eacute;tat
		en utilisant son identifiant courant. La m&eacute;thode <tt class="literal">saveOrUpdate()</tt>
                impl&eacute;mente cette fonctionnalit&eacute;.
            </p><p>
                Hibernate distingue les "nouvelles" (non sauvegard&eacute;es) instances, des instances
		existantes (sauvegard&eacute;es ou charg&eacute;es dans une session pr&eacute;c&eacute;dente) gr&acirc;ce &agrave; la valeur
		de leur propri&eacute;t&eacute; d'identifiant (ou de version, ou de timestamp). 
        L'attribut <tt class="literal">unsaved-value</tt> du mapping <tt class="literal">&lt;id&gt;</tt> 
        (ou <tt class="literal">&lt;version&gt;</tt>, ou <tt class="literal">&lt;timestamp&gt;</tt>) 
        sp&eacute;cifie quelle valeur doit &ecirc;tre interpr&eacute;t&eacute;e comme repr&eacute;sentant une "nouvelle" instance.
            </p><pre class="programlisting">&lt;id name="id" type="long" column="uid" unsaved-value="null"&gt;
    &lt;generator class="hilo"/&gt;
&lt;/id&gt;</pre><p>
                Les valeurs permises pour <tt class="literal">unsaved-value</tt> sont :
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">any</tt> - toujours sauvegarder (save)
                    </p></li><li><p>
                    <tt class="literal">none</tt> - toujours mettre &agrave; jour (update)
                    </p></li><li><p>
                    <tt class="literal">null</tt> - sauvegarder (save) quand l'identifiant est 
		    nul (valeur par d&eacute;faut)
                    </p></li><li><p>
                    une valeur valide pour l'identifiant - sauvegarder (save) quand 
		    l'identifiant est nul ou &eacute;gal &agrave; cette valeur
                    </p></li><li><p>
                    <tt class="literal">undefined</tt> - par d&eacute;faut pour <tt class="literal">version</tt> ou
                        <tt class="literal">timestamp</tt>, le contr&ocirc;le sur l'identifiant est alors utilis&eacute;
                    </p></li></ul></div><pre class="programlisting">// dans la premi&egrave;re session
Cat cat = (Cat) firstSession.load(Cat.class, catID);

// dans une couche sup&eacute;rieure de l'application
Cat mate = new Cat();
cat.setMate(mate);

// plus tard, dans une nouvelle session
secondSession.saveOrUpdate(cat);   // mise &agrave; jour de l'&eacute;tat existant (cat a un id non null)
secondSession.saveOrUpdate(mate);  // sauvegarde d'une nouvelle instance (mate a un id null)</pre><p>
                L'utilisation et la s&eacute;mantique de <tt class="literal">saveOrUpdate()</tt> semble 
                confuse pour les nouveaux utilisateurs. Tout d'abord, tant que vous n'essayez 
                pas d'utiliser une instance d'une session dans une autre session, 
                il est inutile d'utiliser <tt class="literal">update()</tt> ou
                <tt class="literal">saveOrUpdate()</tt>. De pan entiers d'applications 
                n'utiliseront aucune de ces deux m&eacute;thodes.
            </p><p>
                G&eacute;n&eacute;ralement <tt class="literal">update()</tt> ou <tt class="literal">saveOrUpdate()</tt> 
                sont utilis&eacute;s dans les sc&eacute;narii suivant:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        l'application charge un objet dans une premi&egrave;re session
                    </p></li><li><p>
                        l'objet est pass&eacute; &agrave; la couche UI
                    </p></li><li><p>
                        l'objet subit quelques modificatons
                    </p></li><li><p>
                        l'objet redescend vers la couche m&eacute;tier
                    </p></li><li><p>
                        l'application persiste ces modifications en appelant
                        <tt class="literal">update()</tt> dans une seconde session
                    </p></li></ul></div><p>
                <tt class="literal">saveOrUpdate()</tt> r&eacute;alise ce qui suit :
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        si l'objet est d&eacute;j&agrave; persistant dans la session en cours, ne fait rien
                    </p></li><li><p>
                        si l'objet n'a pas d'identifiant, elle le <tt class="literal">save()</tt>
                    </p></li><li><p>
                        si l'identifiant de l'objet corresponds au crit&egrave;re d&eacute;fini par
                        <tt class="literal">unsaved-value</tt>, elle le <tt class="literal">save()</tt>
                    </p></li><li><p>
                        si l'objet est versionn&eacute; (<tt class="literal">version</tt> ou
                        <tt class="literal">timestamp</tt>), alors la version est v&eacute;rifi&eacute;e en
			priorit&eacute; sur l'identifiant, sauf si <tt class="literal">unsaved-value="undefined"</tt> 
            (valeur par d&eacute;faut) est utilis&eacute; pour la version
                    </p></li><li><p>
                        si un autre objet associ&eacute; &agrave; la session a le m&ecirc;me identifiant, 
			une exception est soulev&eacute;e
                    </p></li></ul></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-update-lock"></a>9.4.3.&nbsp;R&eacute;associer des objets d&eacute;tach&eacute;s</h3></div></div><div></div></div><p>
                La m&eacute;thode <tt class="literal">lock()</tt> permet &agrave; l'application de r&eacute;associer
                un objet non modifi&eacute; avec une nouvelle session.
            </p><pre class="programlisting">//simple r&eacute;association :
sess.lock(fritz, LockMode.NONE);
//v&eacute;rifie la version, puis r&eacute; associe :
sess.lock(izi, LockMode.READ);
//v&eacute;rifie la version en utilisant SELECT ... FOR UPDATE, puis r&eacute;associe :
sess.lock(pk, LockMode.UPGRADE);</pre></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-deleting"></a>9.5.&nbsp;Suppression d'objets persistants</h2></div></div><div></div></div><p>
            <tt class="literal">Session.delete()</tt> supprimera l'&eacute;tat d'un objet de la base de donn&eacute;es. 
            Evidemment, votre application peut toujours contenir une r&eacute;f&eacute;rence &agrave; cet objet.
	    La meilleure fa&ccedil;on de l'apr&eacute;hender est donc de se dire que <tt class="literal">delete()</tt> 
	    transforme une instance persistante en instance transiante.
        </p><pre class="programlisting">sess.delete(cat);</pre><p>
            Vous pouvez aussi effacer plusieurs objets en passant une requ&ecirc;te Hibernante
	    &agrave; la m&eacute;thode <tt class="literal">delete()</tt>.
        </p><p>
            Vous pouvez supprimer les objets dans l'ordre que vous souhaitez, sans risque de
	    violer une contrainte de cl&eacute; &eacute;trang&egrave;re. Cependant, vous pourriez violer une contrainte 
	    <tt class="literal">NOT NULL</tt> si vous invoquiez <tt class="literal">delete()</tt> sur des objets 
        dans le mauvais ordre. 
	</p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-flushing"></a>9.6.&nbsp;Flush</h2></div></div><div></div></div><p>
            La <tt class="literal">Session</tt> ex&eacute;cute parfois les ordres SQL n&eacute;cessaires pour
	    synchroniser l'&eacute;tat de la connexion JDBC avec l'&eacute;tat des objets contenus en m&eacute;moire.
	    Ce processus, <span class="emphasis"><em>flush</em></span>, se d&eacute;clenche :
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    &agrave; certaines invocations de <tt class="literal">find()</tt> ou d'<tt class="literal">iterate()</tt>
                </p></li><li><p>
                    &agrave; l'appel de <tt class="literal">net.sf.hibernate.Transaction.commit()</tt>
                </p></li><li><p>
                    &agrave; l'appel de <tt class="literal">Session.flush()</tt>
                </p></li></ul></div><p>
            Les ordres SQL sont ex&eacute;cut&eacute;s dans cet ordre :
        </p><div class="orderedlist"><ol type="1" compact><li><p>
                    toutes les insertions d'entit&eacute;s, dans le m&ecirc;me ordre que celui 
		    utilis&eacute; pour la sauvegarde (<tt class="literal">Session.save()</tt>) 
		    des objets correpsondants
                </p></li><li><p>
                    toutes les mises &agrave; jour d'entit&eacute;s
                </p></li><li><p>
                    toutes les suppressions de collection
                </p></li><li><p>
                    toutes les suppressions, insertions, mises &agrave; jour d'&eacute;l&eacute;ments 
		    de collection
                </p></li><li><p>
                    toutes les insertions de collection
                </p></li><li><p>
                    toutes les suppressions d'entit&eacute;s, dans le m&ecirc;me ordre que celui 
		    utilis&eacute; pour la suppression (<tt class="literal">Session.delete()</tt>) 
		    des objets correpsondants
                </p></li></ol></div><p>
            (Une exception existe pour les objets utilisant les g&eacute;n&eacute;rations d'ID <tt class="literal">native</tt>
	    puisqu'ils sont ins&eacute;r&eacute;s quand ils sont sauvegard&eacute;s).
        </p><p>
            A moins d'appeler explicitement <tt class="literal">flush()</tt>, il n'y a aucune garantie
	    sur le moment <span class="emphasis"><em>o&ugrave;</em></span> la <tt class="literal">Session</tt> ex&eacute;cute les appels JDBC,
	    seul l'<span class="emphasis"><em>ordre</em></span> dans lequel ils sont appel&eacute;s est garanti.
            
	    Cependant, Hibernate garantit que les m&eacute;thodes <tt class="literal">Session.find(..)</tt>
            ne retourneront jamais de donn&eacute;es p&eacute;rim&eacute;es ; ni de donn&eacute;es &eacute;rron&eacute;es.
        </p><p>
            Il est possible de changer les comportements par d&eacute;faut pour que le flush s'ex&eacute;cute
	    moins fr&eacute;quement. La classe <tt class="literal">FlushMode</tt> d&eacute;finit trois modeds diff&eacute;rents.
	    Ceci est utile pour des transactions en lecture seule o&ugrave; il peut &ecirc;tre utlis&eacute; pour accro&icirc;tre 
	    (tr&egrave;s) l&eacute;g&egrave;rement les performances.
        </p><pre class="programlisting">sess = sf.openSession();
Transaction tx = sess.beginTransaction();
sess.setFlushMode(FlushMode.COMMIT); //autorise les requ&ecirc;tes &agrave; retourner des donn&eacute;es corrompues
Cat izi = (Cat) sess.load(Cat.class, id);
izi.setName(iznizi);
// ex&eacute;cute quelques requ&ecirc;tes....
sess.find("from Cat as cat left outer join cat.kittens kitten");
//les modifications de 'izi' ne sont sont pas flush&eacute;es!
...
tx.commit(); //flush s'ex&eacute;cute</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-endingsession"></a>9.7.&nbsp;Terminer une Session</h2></div></div><div></div></div><p>
            La fin d'une session implique quatre phases :
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    flush de la session
                </p></li><li><p>
                    commit de la transaction
                </p></li><li><p>
                    fermeture de la session
                </p></li><li><p>
                    traitement des exceptions
                </p></li></ul></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-endingsession-flushing"></a>9.7.1.&nbsp;Flusher la Session</h3></div></div><div></div></div><p>
                Si vous utilisez l'API <tt class="literal">Transaction</tt>, vous n'avez pas &agrave; vous soucier de cette
		&eacute;tape. Elle sera automatiquement r&eacute;alis&eacute;e &agrave; l'appel du commit de la transaction.
		Autrement, vous devez invoquer <tt class="literal">Session.flush()</tt> pour vous assurer que les changements
		sont synchronis&eacute;s avec la base de donn&eacute;es.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-endingsession-commit"></a>9.7.2.&nbsp;Commit de la transaction de la base de donn&eacute;es</h3></div></div><div></div></div><p>
                Si vous utilisez l'API <tt class="literal">Transaction</tt> d'Hibernate, cela donne :
            </p><pre class="programlisting">tx.commit(); // flush la Session et commit la transaction</pre><p>
                Si vous g&eacute;rez vous-m&ecirc;me les transactions JDBC, vous devez manuellement appeler la m&eacute;thode
                <tt class="literal">commit()</tt> de la connexion JDBC.
            </p><pre class="programlisting">sess.flush();
sess.connection().commit();  // pas n&eacute;cessaire pour une datasource JTA</pre><p>
                Si vous d&eacute;cidez de ne <span class="emphasis"><em>pas</em></span> committer vos modifications :
            </p><pre class="programlisting">tx.rollback();  // rollback la transaction</pre><p>
                ou :
            </p><pre class="programlisting">// pas n&eacute;cessaire pour une datasource JTA mais important dans le cas contraire 
sess.connection().rollback();</pre><p>
                Si vous faites un rollback d'une transaction vous devriez imm&eacute;diatement la fermer et
                arr&ecirc;ter d'utiliser la session courante, ceci pour assurer l'int&eacute;grit&eacute; de l'&eacute;tat 
                interne d'Hibernate.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-endingsession-close"></a>9.7.3.&nbsp;Fermeture de la Session</h3></div></div><div></div></div><p>
                Un appel de <tt class="literal">Session.close()</tt> marque la fin d'une session. La cons&eacute;quence 
		principale de <tt class="literal">close()</tt> est que la connexion JDBC est relach&eacute;e par la session.
            </p><pre class="programlisting">tx.commit();
sess.close();</pre><pre class="programlisting">sess.flush();
sess.connection().commit();  // pas n&eacute;cessaire pour une datasource JTA
sess.close();</pre><p>
                Si vous g&eacute;rez vous m&ecirc;me votre connexion, <tt class="literal">close()</tt> retourne une r&eacute;f&eacute;rence 
                &agrave; cette connexion, vous pouvez ainsi la fermer manuellement ou la rendre au pool.
		Si ce n'est pas le cas <tt class="literal">close()</tt> rend la connexion au pool.
            </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-exceptions"></a>9.8.&nbsp;Traitement des exceptions</h2></div></div><div></div></div><p>Hibernate, au cours de son utilisation, peut lever des exceptions, g&eacute;n&eacute;ralement 
            des <tt class="literal">hibernateException</tt>s. La cause &eacute;ventuelle de l'exception 
            qui peut &ecirc;tre r&eacute;cup&eacute;r&eacute;e en utilisant <tt class="literal">getCause()</tt>.</p><p>
            Si la <tt class="literal">Session</tt> l&egrave;ve une exception, 
            vous devrez imm&eacute;diatement effectuer un
            rollback de la transaction, appeler <tt class="literal">session.close()</tt>
            et ne plus utiliser l'instance courante de la <tt class="literal">Session</tt>. Certaines
            m&eacute;thodes de <tt class="literal">Session</tt> ne laisseront <span class="emphasis"><em>pas</em></span>
            la session dans un &eacute;tat consistant. Cela signifie que toutes
            les exceptions lev&eacute;es par Hibernate doivent &ecirc;tre consid&eacute;r&eacute;es comme fatales, 
            vous pourriez donc envisager de convertir l'exception non runtime 
            <tt class="literal">HibernateException</tt> en <tt class="literal">RuntimeException</tt> 
            (la solution la plus simple est de changer la clause <tt class="literal">extends</tt> 
            dans <tt class="literal">HibernateException.java</tt> et de recompiler le tout).
            Notez que le fait que l'exception ne soit pas runtime est d&ucirc; &agrave; une erreur des
            premiers ages d'Hibernate et sera corrig&eacute;e dans la prochaine version majeure.
        </p><p>
            Hibernate essaiera de convertir les <tt class="literal">SQLException</tt>s lev&eacute;es
            lors des interactions avec la base de donn&eacute;es en des sous-classes de 
            <tt class="literal">JDBCException</tt>. La <tt class="literal">SQLException</tt> 
            sous-jacente est accessible en appelant <tt class="literal">JDBCException.getCause()</tt>.
            Hibernate convertit la <tt class="literal">SQLException</tt> en une sous-classe
            appropri&eacute;e de <tt class="literal">JDBCException</tt> en s'appuyant sur le
            <tt class="literal">SQLExceptionConverter</tt> attach&eacute; &agrave; la <tt class="literal">SessionFactory</tt>.
            Par d&eacute;faut, le <tt class="literal">SQLExceptionConverter</tt> utilis&eacute; est celui
            d&eacute;fini par le dialecte ; il est cependant possible d'attacher une impl&eacute;mentation
            sp&eacute;cifique (voir la javadoc de <tt class="literal">SQLExceptionConverterFactory</tt>
            pour plus de d&eacute;tails). Les sous-types standards de <tt class="literal">JDBCException</tt>
            sont :
		</p><div class="itemizedlist"><ul type="disc" compact><li><p>
					<tt class="literal">JDBCConnectionException</tt> - indique une erreur lors
                    de la communication JDBC sous-jacente.
				</p></li><li><p>
					<tt class="literal">SQLGrammarException</tt> - indique une erreur de
                    grammaire ou de syntaxe du SQL envoy&eacute;.
				</p></li><li><p>
					<tt class="literal">ConstraintViolationException</tt> - indique une forme de
                    violation de contrainte d'int&eacute;grit&eacute;.
				</p></li><li><p>
					<tt class="literal">LockAcquisitionException</tt> - indique une erreur lors
                    de l'acquisition d'un niveau de verrou requis pour ex&eacute;cuter l'op&eacute;ration
                    demand&eacute;e.
				</p></li><li><p>
					<tt class="literal">GenericJDBCException</tt> - indique une exception g&eacute;n&eacute;rique
                    dont la cause ne tombe pas dans les cat&eacute;gories pr&eacute;c&eacute;dentes.
				</p></li></ul></div><p>
            Comme toujours, toutes les exceptions sont consid&eacute;r&eacute;es comme fatales
            &agrave; la <tt class="literal">Session</tt> et &agrave; la transaction courante.
            Le fait qu'Hibernate sache maintenant mieux distinguer les diff&eacute;rents types
            de <tt class="literal">SQLException</tt> n'implique en aucune mani&egrave;re que les 
            exceptions soient r&eacute;cup&eacute;rables du point de vue de la <tt class="literal">Session</tt>.
            La hi&eacute;rarchie typ&eacute;e des exceptions permet &agrave; l'application de 
            mieux r&eacute;agir en cat&eacute;gorisant la cause de l'exception plus simplement
            si besoin.
		</p><p>
            Il est recommand&eacute; d'effectuer le traitement des exceptions comme suit :
        </p><pre class="programlisting">Session sess = factory.openSession();
Transaction tx = null;
try {
    tx = sess.beginTransaction();
    // faire qqch
    ...
    tx.commit();
}
catch (Exception e) {
    if (tx!=null) tx.rollback();
    throw e;
}
finally {
    sess.close();
}</pre><p>
            Ou, si vous g&eacute;rez les transactions JDBC manuellement :
        </p><pre class="programlisting">Session sess = factory.openSession();
try {
    // faire qqch
    ...
    sess.flush();
    sess.connection().commit();
}
catch (Exception e) {
    sess.connection().rollback();
    throw e;
}
finally {
    sess.close();
}</pre><p>
            Ou, si vous utilisez une datasource coupl&eacute;e avec JTA :
        </p><pre class="programlisting">UserTransaction ut = .... ;
Session sess = factory.openSession();
try {
    // faire qqch
    ...
    sess.flush();
}
catch (Exception e) {
    ut.setRollbackOnly();
    throw e;
}
finally {
    sess.close();
}</pre><p>N'oubliez pas qu'un serveur d'applications (dans un environnement g&eacute;r&eacute; par JTA) 
    ne rollback les transactions automatiquement que pour les exceptions
    <tt class="literal">java.lang.RuntimeException</tt>s. Si une exception applicative 
    est lev&eacute;e (&agrave; savoir une exception non runtime <tt class="literal">HibernateException</tt>), vous
    devez appeler la m&eacute;thode <tt class="literal">setRollbackOnly()</tt> d'<tt class="literal">EJBContext</tt>
    vous-m&ecirc;me ou, comme montr&eacute; dans l'exemple pr&eacute;c&eacute;dent, l'encapsuler dans une 
    <tt class="literal">RuntimeException</tt> (par exemple <tt class="literal">EJBException</tt>
    pour un rollback automatique.
    </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-graphs"></a>9.9.&nbsp;Cycles de vie et graphes d'objets</h2></div></div><div></div></div><p>
            Pour sauvegarder ou mettre &agrave; jour tous les objets contenus dans un graphe 
            d'objets associ&eacute;s, vous pouvez soit
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    invoquer individuellement <tt class="literal">save()</tt>, <tt class="literal">saveOrUpdate()</tt> ou
                    <tt class="literal">update()</tt> sur chaque objet OU
                </p></li><li><p>
                    lier des objets en utilisant <tt class="literal">cascade="all"</tt> ou
                    <tt class="literal">cascade="save-update"</tt>.
                </p></li></ul></div><p>
            De m&ecirc;me, pour supprimer tous les objets d'un graphe, vous pouvez soit
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    invoquer individuellement <tt class="literal">delete()</tt> sur chaque objet OU
                </p></li><li><p>
                    lier des objets en utilisant <tt class="literal">cascade="all"</tt>,
                    <tt class="literal">cascade="all-delete-orphan"</tt> or
                    <tt class="literal">cascade="delete"</tt>.
                </p></li></ul></div><p>
            Recommandation :
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Si la dur&eacute;e de vie de l'objet fils est li&eacute;e &agrave; celle de l'objet p&egrave;re,
		    fa&icirc;tes en un <span class="emphasis"><em>objet li&eacute; au cycle de vie</em></span> en sp&eacute;cifiant
                    <tt class="literal">cascade="all"</tt>.
                </p></li><li><p>
                    Autrement, invoquez explicitement <tt class="literal">save()</tt> et <tt class="literal">delete()</tt> 
                    dans le code de l'application. Si vous souhaitez vraiment &eacute;viter de
                    taper du code suppl&eacute;mentaire, utilisez <tt class="literal">cascade="save-update"</tt> et
		            appeler explicitement <tt class="literal">delete()</tt>.
                </p></li></ul></div><p>
            Mapper une assocation (plusieurs-vers-une, ou une collection) avec <tt class="literal">cascade="all"</tt>
            d&eacute;finit l'association comme une relation de type <span class="emphasis"><em>parent/fils</em></span> o&ugrave; la
	    sauvegarde/mise &agrave; jour/suppression du parent engendre la sauvegarde/mise &agrave; jour/suppression 
	    du ou des fils.
            Par ailleurs, la simple r&eacute;f&eacute;rence &agrave; un fils depuis un parent persistant 
            engendrera une sauvegarde/mise &agrave; jour de l'enfant. La m&eacute;taphore est 
            cependant incompl&egrave;te. Un fils qui n'est plus r&eacute;f&eacute;renc&eacute; par son p&egrave;re
            n'est <span class="emphasis"><em>pas</em></span> automatiquement supprim&eacute;, sauf dans le cas d'une
            association <tt class="literal">&lt;one-to-many&gt;</tt> mapp&eacute;e avec 
            <tt class="literal">cascade="all-delete-orphan"</tt>. 
	    Les d&eacute;finitions pr&eacute;cises des op&eacute;rations en cascade sont les suivantes :
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Si un parent est sauvegard&eacute;, tous ces fils sont pass&eacute;s &agrave; <tt class="literal">saveOrUpdate()</tt>
                </p></li><li><p>
                    Si un parent est pass&eacute; &agrave; <tt class="literal">update()</tt> ou &agrave; <tt class="literal">saveOrUpdate()</tt>,
                    tous ces fils sont pass&eacute;s &agrave; <tt class="literal">saveOrUpdate()</tt>
                </p></li><li><p>
                    Si un fils transiant devient r&eacute;f&eacute;renc&eacute; par un parent persistant, il est pass&eacute; &agrave;
                    <tt class="literal">saveOrUpdate()</tt>
                </p></li><li><p>
                    Si le parent est supprim&eacute;, tous ces enfants sont pass&eacute;s &agrave; <tt class="literal">delete()</tt>
                </p></li><li><p>
                    Si un enfant transiant est d&eacute;r&eacute;f&eacute;renc&eacute; par un parent persistant, 
                    <span class="emphasis"><em>rien ne se passe</em></span> (l'application devra 
                    explicitement supprimer l'enfant si n&eacute;cessaire) sauf si
		    <tt class="literal">cascade="all-delete-orphan"</tt> est positionn&eacute;, 
            dans ce cas le fils "orphelin" est supprim&eacute;
                </p></li></ul></div><p>
            Hibernate n'impl&eacute;mente pas compl&egrave;tement la persistence par atteignabilit&eacute;, ce qui aurait
	    pour cons&eacute;quence (inefficace) la garbage collection des objets persistants. 
        Cependant, en raison de la demande, Hibernate supporte la notion de persistance 
        d'entit&eacute;s lorsqu'elles sont r&eacute;f&eacute;renc&eacute;es par un autre objet persistant. 
        Les associations d&eacute;finies avec <tt class="literal">cascade="save-update"</tt>
	    ont ce comportement. Si vous souhaitez utliser cette approche dans toute votre application, 
	    il est plus facile de sp&eacute;cifier l'attribut <tt class="literal">default-cascade</tt> de l'&eacute;l&eacute;ment 
	    <tt class="literal">&lt;hibernate-mapping&gt;</tt>.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-interceptors"></a>9.10.&nbsp;Intercepteurs</h2></div></div><div></div></div><p>
            L'interface <tt class="literal">Interceptor</tt> fournit des "callbacks" de la session vers 
            l'application permettant &agrave; l'application de consulter et / ou manipuler des propri&eacute;t&eacute;s d'un objet
            persistant avant qu'il soit sauvegard&eacute;, mis &agrave; jour, supprim&eacute; ou charg&eacute;. Une utilisation possible 
	    de cette fonctionnalit&eacute; est de tracer l'acc&egrave;s &agrave; l'information. Par exemple, l'<tt class="literal">Interceptor</tt> qui suit
	    va automatiquement positionner le <tt class="literal">createTimestamp</tt> quand un <tt class="literal">Auditable</tt> est cr&eacute;&eacute;
	    et mettre &agrave; jour la propri&eacute;t&eacute; <tt class="literal">lastUpdateTimestamp</tt> quand un <tt class="literal">Auditable</tt> est modifi&eacute;.
        </p><pre class="programlisting">package net.sf.hibernate.test;

import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;

import net.sf.hibernate.Interceptor;
import net.sf.hibernate.type.Type;

public class AuditInterceptor implements Interceptor, Serializable {

    private int updates;
    private int creates;

    public void onDelete(Object entity,
                         Serializable id,
                         Object[] state,
                         String[] propertyNames,
                         Type[] types) {
        // ne rien faire
    }

    public boolean onFlushDirty(Object entity, 
                                Serializable id, 
                                Object[] currentState,
                                Object[] previousState,
                                String[] propertyNames,
                                Type[] types) {

        if ( entity instanceof Auditable ) {
            updates++;
            for ( int i=0; i &lt; propertyNames.length; i++ ) {
                if ( "lastUpdateTimestamp".equals( propertyNames[i] ) ) {
                    currentState[i] = new Date();
                    return true;
                }
            }
        }
        return false;
    }

    public boolean onLoad(Object entity, 
                          Serializable id,
                          Object[] state,
                          String[] propertyNames,
                          Type[] types) {
        return false;
    }

    public boolean onSave(Object entity,
                          Serializable id,
                          Object[] state,
                          String[] propertyNames,
                          Type[] types) {
        
        if ( entity instanceof Auditable ) {
            creates++;
            for ( int i=0; i&lt;propertyNames.length; i++ ) {
                if ( "createTimestamp".equals( propertyNames[i] ) ) {
                    state[i] = new Date();
                    return true;
                }
            }
        }
        return false;
    }

    public void postFlush(Iterator entities) {
        System.out.println("Creations: " + creates + ", Updates: " + updates);
    }

    public void preFlush(Iterator entities) {
        updates=0;
        creates=0;
    }
    
    ......
    ......
    
}</pre><p>
            L'intercepteur doit &ecirc;tre sp&eacute;cifi&eacute; quand la session est cr&eacute;&eacute;e.
        </p><pre class="programlisting">Session session = sf.openSession( new AuditInterceptor() );</pre><p>
            Vous pouvez aussi activer un intercepteur pour toutes les sessions d'une
            SessionFactory, en utilisant la <tt class="literal">Configuration</tt> :
        </p><pre class="programlisting">new Configuration().setInterceptor( new AuditInterceptor() );</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-metadata"></a>9.11.&nbsp;API d'acc&egrave;s aux m&eacute;tadonn&eacute;es</h2></div></div><div></div></div><p>
            Hibernate a besoin d'un meta-mod&egrave;le tr&egrave;s riche de toutes les entit&eacute;s et types de valeurs. 
	    Parfois, ce mod&egrave;le est tr&egrave;s utile &agrave; l'application elle m&ecirc;me. Par exemple, l'application 
	    peut utiliser les m&eacute;tadonn&eacute;es d'Hibernate pour impl&eacute;menter un algorithme "intelligent" de copie
	    qui comprend quels objets doivent &ecirc;tre copi&eacute;s (valeurs de types muables) et quels objets ne 
	    peuvent l'&ecirc;tre (valeurs de types imuables, et &eacute;ventuellement les entit&eacute;s associ&eacute;es).
        </p><p>
            Hibernate expose les m&eacute;tadonn&eacute;es au travers des interfaces <tt class="literal">ClassMetadata</tt> et
            <tt class="literal">CollectionMetadata</tt> et la hi&eacute;rarchie de <tt class="literal">Type</tt>. 
	    Les instances des interfaces de m&eacute;tadonn&eacute;es peuvent &ecirc;tre obtenues depuis 
        la <tt class="literal">SessionFactory</tt>.
        </p><pre class="programlisting">Cat fritz = ......;
Long id = (Long) catMeta.getIdentifier(fritz);
ClassMetadata catMeta = sessionfactory.getClassMetadata(Cat.class);
Object[] propertyValues = catMeta.getPropertyValues(fritz);
String[] propertyNames = catMeta.getPropertyNames();
Type[] propertyTypes = catMeta.getPropertyTypes();
// retourne une Map de toutes les propri&eacute;t&eacute;s qui ne sont pas des collections ou des associations
// TODO: what about components?
Map namedValues = new HashMap();
for ( int i=0; i&lt;propertyNames.length; i++ ) {
    if ( !propertyTypes[i].isEntityType() &amp;&amp; !propertyTypes[i].isCollectionType() ) {
        namedValues.put( propertyNames[i], propertyValues[i] );
    }
}</pre></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="transactions"></a>Chapitre&nbsp;10.&nbsp;Transactions et acc&egrave;s concurrents</h2></div></div><div></div></div><p>
        Hibernate n'est pas une base de donn&eacute;es en lui m&ecirc;me. C'est un outil l&eacute;ger de mapping
	objet relationnel. La gestion des transactions est d&eacute;l&eacute;gu&eacute;e &agrave; la connexion &agrave; base de donn&eacute;es
	sous-jacente. Si la connexion est enregistr&eacute;e dans JTA, les op&eacute;rations effectu&eacute;es pas la <tt class="literal">Session</tt> 
	sont des parties atomiques de la transaction JTA. On peut voir Hibernate comme une fine surcouche
	de JDBC qui lui ajouterait les s&eacute;mantiques objet.
    </p><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-basics"></a>10.1.&nbsp;Configurations, Sessions et Fabriques (Factories)</h2></div></div><div></div></div><p>
            Une <tt class="literal">SessionFactory</tt> est un objet threadsafe, couteux &agrave; cr&eacute;er, pr&eacute;vu
	    pour &ecirc;tre partag&eacute; par tous les threads de l'application. Une <tt class="literal">Session</tt>
	    est un objet non threadsafe, non co&ucirc;teux qui ne doit &ecirc;tre utilis&eacute;
	    qu'une fois, pour un process m&eacute;tier donn&eacute;, puis d&eacute;truit. Par exemple, lorsque vous utilisez
	    Hibernate dans une application &agrave; base de servlets, les servlets peuvent obtenir
	    une <tt class="literal">SessionFactory</tt> en utilisant
        </p><pre class="programlisting">SessionFactory sf = (SessionFactory)getServletContext().getAttribute("my.session.factory");</pre><p>
	    Chaque appel de service cr&eacute;&eacute; une nouvelle <tt class="literal">Session</tt>, la <tt class="literal">flush()</tt>,
	    <tt class="literal">commit()</tt> sa connexion, la <tt class="literal">close()</tt> et finalement la lib&egrave;re 
	    (La <tt class="literal">SessionFactory</tt> peut aussi &ecirc;tre r&eacute;f&eacute;renc&eacute;e dans le JNDI ou dans une variable 
	    statique <span class="emphasis"><em>Singleton</em></span>).
        </p><p>
	    Dans un bean session sans &eacute;tat, une approche similaire peut &ecirc;tre utilis&eacute;e. Le bean
	    obtiendra une <tt class="literal">SessionFactory</tt> dans <tt class="literal">setSessionContext()</tt>.
	    Ensuite, chaque m&eacute;thode m&eacute;tier cr&eacute;era une <tt class="literal">Session</tt>, appelera
            <tt class="literal">flush()</tt> puis <tt class="literal">close()</tt>. Ben s&ucirc;r, l'application
	    n'a pas &agrave; appeler <tt class="literal">commit()</tt> sur la connexion.(Laissez cela &agrave; JTA,
	    la connexion &agrave; la base de donn&eacute;es participe automatiquement aux transactions g&eacute;r&eacute;es par le
	    container).
        </p><p>
	    Nous utilisons l'API <tt class="literal">Transaction</tt> d'Hibernate comme d&eacute;crit pr&eacute;c&eacute;demment.
	    Un simple <tt class="literal">commit()</tt> de la <tt class="literal">Transaction</tt> Hibernate
	    "flush" l'&eacute;tat et committe chaque connexion &agrave; la base de donn&eacute;es associ&eacute;e
	    (en g&eacute;rant de mani&egrave;re particuli&egrave;re les transactions JTA).
        </p><p>
            Assurez vous de bien comprendre le sens de <tt class="literal">flush()</tt>. L'op&eacute;ration Flush() 
	    permet de synchroniser la source de donn&eacute;es persistante avec les modifications en m&eacute;moire 
	    mais <span class="emphasis"><em>pas</em></span> l'inverse. Notez que pour toutes les connexions/transactions 
	    JDBC utilis&eacute;es par Hibernate, le niveau d'isolation de transaction pour ces 
	    connexions s'applique &agrave; toutes les op&eacute;rations effectu&eacute;es par Hibernate !
        </p><p>
	    Les sections suivantes traitent d'approches alternatives qui utilisent le versioning
	    pour garantir l'atomicit&eacute; de la transaction. Elles sont consid&eacute;r&eacute;es comme des techniques
	    "avanc&eacute;es", et donc &agrave; utiliser en sachant ce que l'on fait.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-threads"></a>10.2.&nbsp;Threads et connections</h2></div></div><div></div></div><p>
            Vous devez respecter les r&egrave;gles suivantes lorsque vous cr&eacute;ez des Sessions Hibernate :
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Ne jamais cr&eacute;er plus d'une instance concurrente de <tt class="literal">Session</tt> 
		    ou <tt class="literal">Transaction</tt> par connexion &agrave; la base de donn&eacute;es.
                </p></li><li><p>
                    Soyez extr&ecirc;mement rigoureux lorsque vous cr&eacute;ez plus d'une <tt class="literal">Session</tt>
		    par base de donn&eacute;es par transaction. La <tt class="literal">Session</tt> tra&ccedil;ant elle-m&ecirc;me
		    les modifications faites sur les objets charg&eacute;s, une autre <tt class="literal">Session</tt>
                    pourrait voir des donn&eacute;es corrompues.
                </p></li><li><p>
                    La <tt class="literal">Session</tt> n'est <span class="emphasis"><em>pas</em></span> threadsafe !
                    Deux thread concurrents ne doivent jamais acc&eacute;der &agrave; la m&ecirc;me <tt class="literal">Session</tt> .
                    G&eacute;n&eacute;ralement, la <tt class="literal">Session</tt> doit &ecirc;tre consid&eacute;r&eacute;e comme une unit&eacute; 
                    de travail unitaire !
                </p></li></ul></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-identity"></a>10.3.&nbsp;Comprendre l'identit&eacute; d'un objet</h2></div></div><div></div></div><p>
            L'application peut acc&eacute;der de mani&egrave;re concurrente &agrave; la m&ecirc;me entit&eacute; persistente via
	    deux unit&eacute;s de travail diff&eacute;rentes. Cependant, une instance de classe persistante n'est
	    jamais partag&eacute;e par deux instances <tt class="literal">Session</tt>. Il y a donc deux notions
	    d'identit&eacute; diff&eacute;rentes.
        </p><div class="variablelist"><dl><dt><span class="term">Identit&eacute; dans la base de donn&eacute;es</span></dt><dd><p>
                        <tt class="literal">foo.getId().equals( bar.getId() )</tt>
                    </p></dd><dt><span class="term">Identit&eacute; dans la JVM</span></dt><dd><p>
                        <tt class="literal">foo==bar</tt>
                    </p></dd></dl></div><p>
            Pour les objets rattach&eacute;s &agrave; une <tt class="literal">Session</tt> <span class="emphasis"><em>donn&eacute;e</em></span>,
            les deux notions sont identiques. Cependant, puisque l'application peut acc&eacute;der de mani&egrave;re
            concurrente au "m&ecirc;me" (identit&eacute; persistante - dans la base de donn&eacute;es) objet m&eacute;tier par deux 
            sessions diff&eacute;rentes, les deux instances seront en fait "diff&eacute;rentes" (identit&eacute; dans JVM).
        </p><p>
            Cette approche laisse la gestion de la concurrence &agrave; Hibernate et &agrave; la base de donn&eacute;es.
	    L'application n'aura jamais besoin de synchroniser un objet m&eacute;tier tant qu'elle s'en
        tient &agrave; un thread par <tt class="literal">Session</tt> ou &agrave; l'identit&eacute; d'un objet 
	    (dans une <tt class="literal">Session</tt>, l'application peut utiliser sans risque <tt class="literal">==</tt> 
	    pour comparer deux objets).
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-optimistic"></a>10.4.&nbsp;Gestion de la concurrence par contr&ocirc;le optimiste</h2></div></div><div></div></div><p>
            Beaucoup de traitements m&eacute;tiers n&eacute;cessitent une s&eacute;rie d'interactions avec l'utilisateur
	    entrecoup&eacute;es d'acc&egrave;s &agrave; la base de donn&eacute;es. Dans les applications web et les applications
        d'entreprise, il n'est pas acceptable qu'une transaction de base de donn&eacute;es 
        se d&eacute;roule le temps de plusieurs interactions avec l'utilisateur.
        </p><p>
            La couche applicative prend dont en partie la responsabilit&eacute; de maintenir 
        l'isolation des traitements m&eacute;tier. C'est pourquoi, nous appelons ce processus 
        une <span class="emphasis"><em>transaction applicative</em></span>. Une transaction applicative
        pourra s'&eacute;tendre sur plusieurs transactions &agrave; la base de 
	    donn&eacute;es. Elle sera atomique si seule la derni&egrave;re des transactions &agrave; la base de donn&eacute;es
	    enregistre les donn&eacute;es mises &agrave; jour, les autres ne faisant que des acc&egrave;s en lecture.
        </p><p>
            La seule stat&eacute;gie remplissant les crit&egrave;res de concurrence et scalabitit&eacute; 
        &eacute;lev&eacute;es est le contr&ocirc;le optimiste de la concurrence en appliquant des versions
        aux donn&eacute;es : on utilisera par la suite le n&eacute;ologisme versionnage.
        Hibernate fournit trois approches pour &eacute;crire des applications bas&eacute;es sur la 
        concurrence optimiste.
        </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-longsession"></a>10.4.1.&nbsp;Session longue avec versionnage automatique</h3></div></div><div></div></div><p>
                Une seule instance de <tt class="literal">Session</tt> et ses instances persistantes
		sont utilis&eacute;es pour toute la transaction d'application.
            </p><p>
                La <tt class="literal">Session</tt> utilise le v&eacute;rouillage optimiste pour s'assurer 
		que plusieurs transactions &agrave; la base de donn&eacute;es ne soient vues par l'application
		que comme une seule transaction logique (transaction applicative). La <tt class="literal">Session</tt> 
		est d&eacute;connect&eacute;e de sa connexion JDBC lorsqu'elle est en attente d'interaction avec
		l'utilisateur. Cette approche est la plus efficace en terme d'acc&egrave;s &agrave; la base de donn&eacute;es.
		L'application n'a pas &agrave; ce soucier de la v&eacute;rification de version ou du r&eacute;attachement
		d'instaces d&eacute;tach&eacute;es.
            </p><pre class="programlisting">// foo est une instance charg&eacute;e plus t&ocirc;t par la Session
session.reconnect();
foo.setProperty("bar");
session.flush();
session.connection().commit();
session.disconnect();</pre><p>
                L'objet <tt class="literal">foo</tt> sait par quelle <tt class="literal">Session</tt> il a &eacute;t&eacute; charg&eacute;.
		D&egrave;s que la <tt class="literal">Session</tt> obtient une connexion JDBC, un commit sera fait sur
		les modifications apport&eacute;es &agrave; l'objet.
            </p><p>
                Ce pattern est probl&eacute;matique si la <tt class="literal">Session</tt> est trop volumineuse pour &ecirc;tre
		stock&eacute;es pendant le temps de r&eacute;flexion de l'utilisateur, par exemple il est 
        souhaitable qu'une <tt class="literal">HttpSession</tt> 
		reste aussi petite que possible. Comme la <tt class="literal">Session</tt> est aussi le premier
		niveau de cache et contient tous les objets charg&eacute;s, il n'est probablement possible de n'utiliser
		cette strat&eacute;gie que pour des cycles contenant peu de requ&ecirc;tes/r&eacute;ponses. C'est, en fait,
		recommand&eacute; puisque la <tt class="literal">Session</tt> risquerait tr&egrave;s vite de 
        contenir des donn&eacute;es obsol&egrave;tes.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-detached"></a>10.4.2.&nbsp;Plusieurs sessions avec versionnage automatique</h3></div></div><div></div></div><p>
                Chaque interaction avec la base de donn&eacute;es se fait dans une nouvelle <tt class="literal">Session</tt>.
		Cependant, les m&ecirc;mes instances persistantes sont r&eacute;utilis&eacute;es pour chaque interaction &agrave; la
		base de donn&eacute;es. L'application manipule l'&eacute;tat des instances d&eacute;tach&eacute;es, charg&eacute;es &agrave; l'initialement
		par une autre <tt class="literal">Session</tt>, puis "r&eacute;associ&eacute;es" en utilisant 
        <tt class="literal">Session.update()</tt>	ou <tt class="literal">Session.saveOrUpdate()</tt>.
            </p><pre class="programlisting">// foo est une instance charg&eacute;e plus t&ocirc;t par une autre Session
foo.setProperty("bar");
session = factory.openSession();
session.saveOrUpdate(foo);
session.flush();
session.connection().commit();
session.close();</pre><p>
                Vous pouvez aussi appeler <tt class="literal">lock()</tt> au lieu de <tt class="literal">update()</tt>
                et utiliser <tt class="literal">LockMode.READ</tt> (effectuant un contr&ocirc;le de version en court 
		circuitant tous les caches) si vous &ecirc;tes s&ucirc;rs que l'objet n'a pas &eacute;t&eacute; modifi&eacute;.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-manual"></a>10.4.3.&nbsp;Contr&ocirc;le de version de mani&egrave;re applicative</h3></div></div><div></div></div><p>
                Chaque interaction avec la base de donn&eacute;es se fait dans une nouvelle <tt class="literal">Session</tt>
		qui recharge toutes les instances persistantes depuis la base de donn&eacute;es avant 
		de les manipuler. Cette approche force l'application &agrave; assurer son propre contr&ocirc;le 
		de version pour garantir l'isolation de la transaction d'application (bien sur,
		Hibernate continuera de mettre &agrave; jour les num&eacute;ros de version pour vous). Cette
		approche est la moins performante en terme d'acc&egrave;s &agrave; la base de donn&eacute;es. Elle est
		ressemble plus &agrave; celle utilis&eacute;e par les EJBs entit&eacute;s.
            </p><pre class="programlisting">// foo est une instance charg&eacute;e plus t&ocirc;t par une autre Session
session = factory.openSession();
int oldVersion = foo.getVersion();
session.load( foo, foo.getKey() );
if ( oldVersion!=foo.getVersion ) throw new StaleObjectStateException();
foo.setProperty("bar");
session.flush();
session.connection().commit();
session.close();</pre><p>
                Evidemment, si vous vous trouvez dans un environnement avec peu de concurrence
		sur les donn&eacute;es et que vous n'avez pas besoin de contr&ocirc;le de version, vous pouvez 
		utiliser cette m&eacute;thode en retirant simplement le contr&ocirc;le de version.
            </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-disconnection"></a>10.5.&nbsp;D&eacute;connexion de Session</h2></div></div><div></div></div><p>
            La premi&egrave;re approche d&eacute;crite ci dessus consiste &agrave; maintenir une seule <tt class="literal">Session</tt>
	    pour tout un process m&eacute;tier qui englobe plusieurs interactions avec l'utilisateur
	    (par exemple, une servlet peut stocker une <tt class="literal">Session</tt> dans l'<tt class="literal">HttpSession</tt>
	    de l'utilisateur). Pour des raisons de performance, il est pr&eacute;f&eacute;rable
        </p><div class="orderedlist"><ol type="1" compact><li><p>
                    d'effectuer un commit de la <tt class="literal">Transaction</tt> (ou de la connexion JDBC) puis
                </p></li><li><p>
                    d&eacute;connecter la <tt class="literal">Session</tt> de la connexion JDBC
                </p></li></ol></div><p>
            avant d'attendre l'activit&eacute; de l'utilisateur. La m&eacute;thode <tt class="literal">Session.disconnect()</tt>
	    d&eacute;connectera la session de la connexion JDBC et la retournera au pool (&agrave; moins que vous 
	    ne fournissiez la connexion).
        </p><p>
            <tt class="literal">Session.reconnect()</tt> obtient une nouvelle connexion (ou vous devez
	    en fournir une) et red&eacute;marre la session. Apr&egrave;s reconnexion, pour forcer le contr&ocirc;le de
	    version sur les donn&eacute;es que vous ne modifiez pas, vous pouvez appeler <tt class="literal">Session.lock()</tt> 
	    sur les objets susceptibles d'avoir &eacute;t&eacute; modifi&eacute;s par une autre transaction. 
	    Vous n'avez pas besoin de v&eacute;rouiller (lock) les donn&eacute;es que vous <span class="emphasis"><em>&ecirc;tes en train</em></span>
	    de modifier.
        </p><p>
            Voici un exemple :
        </p><pre class="programlisting">SessionFactory sessions;
List fooList;
Bar bar;
....
Session s = sessions.openSession();

Transaction tx = null;
try {
    tx = s.beginTransaction();

    fooList = s.find(
    	"select foo from eg.Foo foo where foo.Date = current date"
        //utilisation de la fonction date de DB2
    );
    bar = (Bar) s.save(Bar.class);

    tx.commit();
}
catch (Exception e) {
    if (tx!=null) tx.rollback();
    s.close();
    throw e;
}
s.disconnect();</pre><p>
            Puis :
        </p><pre class="programlisting">s.reconnect();

try {
    tx = s.beginTransaction();

    bar.setFooTable( new HashMap() );
    Iterator iter = fooList.iterator();
    while ( iter.hasNext() ) {
        Foo foo = (Foo) iter.next();
        s.lock(foo, LockMode.READ);    //v&eacute;rifie que foo n'est pas obsol&egrave;te
        bar.getFooTable().put( foo.getName(), foo );
    }

    tx.commit();
}
catch (Exception e) {
    if (tx!=null) tx.rollback();
    throw e;
}
finally {
    s.close();
}</pre><p>
            Vous pouvez voir que la relation entre les <tt class="literal">Transaction</tt>s et
            les <tt class="literal">Session</tt>s est de type plusieurs-vers-une. 
            Une <tt class="literal">Session</tt> repr&eacute;sente
	    une conversation entre l'application et la base de donn&eacute;es. La <tt class="literal">Transaction</tt> 
	    divise cette conversation en plusieurs unit&eacute;s atomiques de travail au niveau
	    de la base de donn&eacute;es.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-locking"></a>10.6.&nbsp;V&eacute;rouillage pessimiste</h2></div></div><div></div></div><p>
            Il n'est pas pr&eacute;vu que les utilisateurs passent beaucoup de temps &agrave; se soucier des strat&eacute;gies
	    de verrou. Il est g&eacute;n&eacute;ralement suffisant de sp&eacute;cifier le niveau d'isolation pour les connexions
	    JDBC puis de laisser la base de donn&eacute;es faire le travail. Cependant, les utilisateurs avanc&eacute;s
	    veulent parfois obtenir des verrous pessimistes exclusifs, ou r&eacute;obtenir les verrous au
	    d&eacute;but d'une nouvelle transaction.
        </p><p>
            Hibernate utilisera toujours les m&eacute;canismes de v&eacute;rouillage de la base de donn&eacute;es, il
	    ne v&eacute;rouillera jamais les objets en m&eacute;moire !
        </p><p>
            La classe <tt class="literal">LockMode</tt> d&eacute;finit les niveaux de verrou qui peuvent &ecirc;tre obtenus
	    par Hibernate. Un verrou est obtenu pas les m&eacute;canismes suivant ;
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">LockMode.WRITE</tt> est obtenu automatiquement lorsqu'Hibernate ins&egrave;re ou modifie 
                    un enregistrement. 
                </p></li><li><p>
                    <tt class="literal">LockMode.UPGRADE</tt> peut &ecirc;tre obtenu &agrave; la demande explicite de l'utilsateur 
                    en utilisant la syntaxe <tt class="literal">SELECT ... FOR UPDATE</tt> sur les bases de donn&eacute;es 
                    qui la supportent.
                </p></li><li><p>
                    <tt class="literal">LockMode.UPGRADE_NOWAIT</tt> peut &ecirc;tre obtenu &agrave; la demande explicite 
                    de l'utilsateur gr&acirc;ce &agrave; la syntaxte <tt class="literal">SELECT ... FOR UPDATE NOWAIT</tt> 
                    sous Oracle.
                </p></li><li><p>
                    <tt class="literal">LockMode.READ</tt> est obtenu automatiquement lorsqu'Hibernate consulte des donn&eacute;es 
                    avec des niveaux d'isolation de type lectures reproductibles (repeatable read) ou de type
                    s&eacute;rialisable (serializable). Peut &ecirc;tre r&eacute;obtenu &agrave; la demande explicite de l'utilsateur
                </p></li><li><p>
            <tt class="literal">LockMode.NONE</tt> repr&eacute;sente l'absence de verrou. Tous les objets basculent &agrave; ce
	    verrou &agrave; la fin d'une <tt class="literal">Transaction</tt>. Les objets associ&eacute;s &agrave; la session via 
            l'appel de <tt class="literal">update()</tt> ou <tt class="literal">saveOrUpdate()</tt> d&eacute;marrent aussi
	    sur ce mode de verrou.
        </p></li></ul></div><p>
            La "demande explicite de l'utilsateur" se traduit par les moyens suivants :
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    un appel de <tt class="literal">Session.load()</tt>, sp&eacute;cifiant un mode de verrou (<tt class="literal">LockMode</tt>).
                </p></li><li><p>
                    un appel de <tt class="literal">Session.lock()</tt>.
                </p></li><li><p>
                    un appel de <tt class="literal">Query.setLockMode()</tt>.
                </p></li></ul></div><p>
            Si <tt class="literal">Session.load()</tt> est appel&eacute;e avec <tt class="literal">UPGRADE</tt> ou
            <tt class="literal">UPGRADE_NOWAIT</tt>, et que l'obet demand&eacute; n'a pas encore &eacute;t&eacute; charg&eacute; par 
	    la session, l'objet sera charg&eacute; en utilisant <tt class="literal">SELECT ... FOR UPDATE</tt>.
            Si <tt class="literal">load()</tt> est appel&eacute; et que l'objet a d&eacute;ja &eacute;t&eacute; charg&eacute; avec un mode moins
	    restrictif, Hibernate appelle <tt class="literal">lock()</tt> pour cet objet.
        </p><p>
            <tt class="literal">Session.lock()</tt> effectue un contr&ocirc;le de version si le mode de verrou sp&eacute;cifi&eacute;
	    est <tt class="literal">READ</tt>, <tt class="literal">UPGRADE</tt> ou <tt class="literal">UPGRADE_NOWAIT</tt> 
	    (Dans le cas de <tt class="literal">UPGRADE</tt> ou <tt class="literal">UPGRADE_NOWAIT</tt>, 
        <tt class="literal">SELECT ... FOR UPDATE</tt> est utilis&eacute;).
        </p><p>
            Si la base de donn&eacute;es ne supporte pas le mode de verrou demand&eacute;, Hibernate utilisera un mode
	    approchant appropri&eacute; (au lieu de lancer une exception). Ce qui garantit la portabilit&eacute; des
	    applications
        </p></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="queryhql"></a>Chapitre&nbsp;11.&nbsp;HQL: Langage de requ&ecirc;tage d'Hibernate</h2></div></div><div></div></div><p>
        Hibernate fourni un langage d'interrogation extr&ecirc;mement puissant qui
        ressemble (et c'est voulu) au SQL. Mais ne soyez pas distraits par la syntaxe ;
        HQL est totalement orient&eacute; objet, comprenant des notions d'h&eacute;ritage, de
        polymorphisme et d'association.
    </p><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-casesensitivity"></a>11.1.&nbsp;Sensibilit&eacute; &agrave; la casse</h2></div></div><div></div></div><p>
            Les requ&ecirc;tes sont insensibles &agrave; la casse, &agrave; l'exception des noms des classes Java
            et des propri&eacute;t&eacute;s.
            Ainsi, <tt class="literal">SeLeCT</tt> est identique &agrave;
            <tt class="literal">sELEct</tt> et &agrave;
            <tt class="literal">SELECT</tt> mais
            <tt class="literal">net.sf.hibernate.eg.FOO</tt> n'est pas identique
            <tt class="literal">net.sf.hibernate.eg.Foo</tt> et
            <tt class="literal">foo.barSet</tt> n'est pas identique &agrave;
            <tt class="literal">foo.BARSET</tt>.
        </p><p>
            Ce guide utilise les mots cl&eacute;s HQL en minuscule. Certains utilisateurs trouvent les
            requ&ecirc;tes &eacute;crites avec les mots cl&eacute;s en majuscule plus lisibles, mais nous trouvons
            cette convention p&eacute;nible lorsqu'elle est lue dans du code Java.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-from"></a>11.2.&nbsp;La clause from</h2></div></div><div></div></div><p>
            La requ&ecirc;te Hibernate la plus simple est de la forme :
        </p><pre class="programlisting">from eg.Cat</pre><p>
            qui retourne simplement toutes les instances de la classe <tt class="literal">eg.Cat</tt>. 
        </p><p>
            La plupart du temps, vous devrez assigner un <span class="emphasis"><em>alias</em></span> puisque vous
            voudrez faire r&eacute;f&eacute;rence &agrave; <tt class="literal">Cat</tt> dans d'autres parties de la requ&ecirc;te.
        </p><pre class="programlisting">from eg.Cat as cat</pre><p>
            Cette requ&ecirc;te assigne l'alias <tt class="literal">cat</tt> &agrave; l'instance <tt class="literal">Cat</tt>,
            nous pouvons donc utiliser cet alias ailleurs dans la requ&ecirc;te. Le mot cl&eacute; <tt class="literal">as</tt>
            est optionnel ; nous aurions pu &eacute;crire
        </p><pre class="programlisting">from eg.Cat cat</pre><p>
            Plusieurs classes peuvent appara&icirc;tre, ce qui conduira &agrave; un produit 
            cart&eacute;sien (encore appel&eacute; jointures crois&eacute;es).
        </p><pre class="programlisting">from Formula, Parameter</pre><pre class="programlisting">from Formula as form, Parameter as param</pre><p>
            C'est une bonne pratique que de nommer les alias dans les requ&ecirc;tes en utilisant l'initiale
            en miniscule, ce qui a le m&eacute;rite d'&ecirc;tre en phase avec les standards de 
            nommage Java pour les variables locales (<tt class="literal">domesticCat</tt>).
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-joins"></a>11.3.&nbsp;Associations et jointures</h2></div></div><div></div></div><p>
            On peut aussi assigner des alias &agrave; des entit&eacute;s associ&eacute;es, ou m&ecirc;me aux &eacute;l&eacute;ments d'une collection
            de valeurs, en utilisant un <tt class="literal">join</tt> (jointure).
        </p><pre class="programlisting">from eg.Cat as cat 
    inner join cat.mate as mate
    left outer join cat.kittens as kitten

from eg.Cat as cat left join cat.mate.kittens as kittens

from Formula form full join form.parameter param</pre><p>
            Les types de jointures support&eacute;es sont celles de ANSI SQL
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">inner join</tt> (jointure ferm&eacute;e)
                </p></li><li><p>
                    <tt class="literal">left outer join</tt> (jointure ouverte par la gauche)
                </p></li><li><p>
                    <tt class="literal">right outer join</tt> (jointure ouverte par la droite)
                </p></li><li><p>
                    <tt class="literal">full join</tt> (jointure ouverte totalement - g&eacute;n&eacute;ralement inutile)
                </p></li></ul></div><p>
            Les constructions des jointures <tt class="literal">inner join</tt>, <tt class="literal">left outer join</tt> 
            et <tt class="literal">right outer join</tt> peuvent &ecirc;tre abbr&eacute;g&eacute;es.
        </p><pre class="programlisting">from eg.Cat as cat 
    join cat.mate as mate
    left join cat.kittens as kitten</pre><p>
            Par ailleurs, une jointure "fetch&eacute;e" (rapport&eacute;e) permet d'initialiser 
            les associations ou collections de valeurs en m&ecirc;me temps que leur objet parent, 
            le tout n'utilisant qu'un seul Select.
            Ceci est particuli&egrave;rement utile dans le cas des collections. Ce syst&egrave;me permet de surcharger
            les d&eacute;clarations "lazy" et "outer-join" des fichiers de mapping pour les associations et 
            collections.            
        </p><pre class="programlisting">from eg.Cat as cat 
    inner join fetch cat.mate
    left join fetch cat.kittens</pre><p>
            Une jointure "fetch&eacute;e" (rapport&eacute;e) n'a g&eacute;n&eacute;ralement pas besoin de se voir assigner 
            un alias puisque les objets associ&eacute;s n'ont pas &agrave; &ecirc;tre utilis&eacute;s dans les autres clauses.
            Notez aussi que les objets associ&eacute;s ne sont pas retourn&eacute;s directement dans le r&eacute;sultat de
            la requ&ecirc;te mais l'on peut y acc&eacute;der via l'objet parent.
        </p><p>
            Notez que, dans l'impl&eacute;mentation courante, seule une seule collection 
            peut &ecirc;tre "fetch&eacute;e" par requ&ecirc;te (une autre strat&eacute;gie ne serait pas performante). 
            Notez aussi que le mot-cl&eacute; <tt class="literal">fetch</tt> ne peut pas &ecirc;tre utilis&eacute;
            lorsque l'on appelle <tt class="literal">scroll()</tt> ou <tt class="literal">iterate()</tt>. 
            Notez enfin que <tt class="literal">full join fetch</tt> et <tt class="literal">right join 
	    fetch</tt> ne sont pas utiles en g&eacute;n&eacute;ral.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-select"></a>11.4.&nbsp;La clause select</h2></div></div><div></div></div><p>
            La clause <tt class="literal">select</tt> s&eacute;lectionne les objets et propri&eacute;t&eacute;s
	    qui doivent &ecirc;tre retourn&eacute;s dans le r&eacute;sultat de la requ&ecirc;te.
	    Soit :
        </p><pre class="programlisting">select mate 
from eg.Cat as cat 
    inner join cat.mate as mate</pre><p>
            La requ&ecirc;te recherchera les <tt class="literal">mate</tt>s li&eacute;s aux <tt class="literal">Cat</tt>s.
            Vous pouvez explimer la requ&ecirc;te d'une mani&egrave;re plus compacte :
        </p><pre class="programlisting">select cat.mate from eg.Cat cat</pre><p>
            Vous pouvez m&ecirc;me s&eacute;lectionner les &eacute;l&eacute;ments d'une collection en utilisant la fonction
	    <tt class="literal">elements</tt>. La requ&ecirc;te suivante retourne tous les kittens de chaque cat.
        </p><pre class="programlisting">select elements(cat.kittens) from eg.Cat cat</pre><p>
            Les requ&ecirc;tes peuvent retourner des propri&eacute;t&eacute;s de n'importe quel type, m&ecirc;me celles de type
	    composant (component).
        </p><pre class="programlisting">select cat.name from eg.DomesticCat cat
where cat.name like 'fri%'

select cust.name.firstName from Customer as cust</pre><p>
            Les requ&ecirc;tes peuvent retourner plusieurs objets et/ou propri&eacute;t&eacute;s sous la forme
	    d'un tableau du type <tt class="literal">Object[]</tt>
        </p><pre class="programlisting">select mother, offspr, mate.name 
from eg.DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><p>
            ou sous la forme d'un objet Java typ&eacute;
        </p><pre class="programlisting">select new Family(mother, mate, offspr)
from eg.DomesticCat as mother
    join mother.mate as mate
    left join mother.kittens as offspr</pre><p>
            &agrave; condition que la classe <tt class="literal">Family</tt> poss&egrave;de le constructeur appropri&eacute;.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-aggregation"></a>11.5.&nbsp;Fonctions d'aggr&eacute;gation</h2></div></div><div></div></div><p>
            Les requ&ecirc;tes HQL peuvent aussi retourner le r&eacute;sultat de fonctions d'aggr&eacute;gation 
            sur les propri&eacute;t&eacute;s :	    
        </p><pre class="programlisting">select avg(cat.weight), sum(cat.weight), max(cat.weight), count(cat)
from eg.Cat cat</pre><p>
            Les collections peuvent aussi appara&icirc;tre &agrave; l'int&eacute;rieur des fonctions d'aggr&eacute;gation dans la clause 
	    <tt class="literal">select</tt>
        </p><pre class="programlisting">select cat, count( elements(cat.kittens) ) 
from eg.Cat cat group by cat</pre><p>
            Les fonctions support&eacute;es sont
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">avg(...), sum(...), min(...), max(...)</tt>
                </p></li><li><p>
                    <tt class="literal">count(*)</tt>
                </p></li><li><p>
                    <tt class="literal">count(...), count(distinct ...), count(all...)</tt>
                </p></li></ul></div><p>
            Les mots cl&eacute; <tt class="literal">distinct</tt> et <tt class="literal">all</tt> peuvent &ecirc;tre utilis&eacute;s et ont 
	    la m&ecirc;me signification qu'en SQL.
        </p><pre class="programlisting">select distinct cat.name from eg.Cat cat

select count(distinct cat.name), count(cat) from eg.Cat cat</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-polymorphism"></a>11.6.&nbsp;Requ&ecirc;tes polymorphiques</h2></div></div><div></div></div><p>
            Un requ&ecirc;te comme :
        </p><pre class="programlisting">from eg.Cat as cat</pre><p>
            retourne non seuleument les instances de <tt class="literal">Cat</tt>, mais aussi celles des
	    sous classes comme <tt class="literal">DomesticCat</tt>. Les requ&ecirc;tes Hibernate peuvent nommer n'importe
	    quelle classe ou interface Java dans la clause <tt class="literal">from</tt>. La requ&ecirc;te retournera les
	    instances de toutes les classes persistantes qui &eacute;tendent cette classe ou impl&eacute;mente cette interface.
	    La requ&ecirc;te suivante retournera tous les objets persistants :
        </p><pre class="programlisting">from java.lang.Object o</pre><p>
            L'interface <tt class="literal">Named</tt> peut &ecirc;tre impl&eacute;ment&eacute;e par plusieurs classes persistantes:
        </p><pre class="programlisting">from eg.Named n, eg.Named m where n.name = m.name</pre><p>
            Notez que ces deux derni&egrave;res requ&ecirc;tes n&eacute;cessitent plus d'un <tt class="literal">SELECT</tt> SQL. 
	    Ce qui signifie que la clause <tt class="literal">order by</tt> ne trie pas correctement la totalit&eacute;
	    des r&eacute;sultats (cela signifie aussi que vous ne pouvez ex&eacute;cuter ces requ&ecirc;tes en appelant 
	    <tt class="literal">Query.scroll()</tt>).
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-where"></a>11.7.&nbsp;La clause where</h2></div></div><div></div></div><p>
            La clause <tt class="literal">where</tt> vous permet de r&eacute;duire la liste des instances retourn&eacute;es.
        </p><pre class="programlisting">from eg.Cat as cat where cat.name='Fritz'</pre><p>
            retourne les instances de <tt class="literal">Cat</tt> dont name est &eacute;gale &agrave; 'Fritz'.
        </p><pre class="programlisting">select foo 
from eg.Foo foo, eg.Bar bar
where foo.startDate = bar.date</pre><p>
            retournera les instances de <tt class="literal">Foo</tt> pour lesquelles
            il existe une instance de <tt class="literal">bar</tt> avec la
            propri&eacute;t&eacute; <tt class="literal">date</tt> est &eacute;gale &agrave; la
            propri&eacute;t&eacute; <tt class="literal">startDate</tt> de <tt class="literal">Foo</tt>. 
	    Les expressions utilisant la navigation rendent la clause <tt class="literal">where</tt> 
	    extr&ecirc;mement puissante. Soit :
        </p><pre class="programlisting">from eg.Cat cat where cat.mate.name is not null</pre><p>
            Cette requ&ecirc;te se traduit en SQL par une jointure interne &agrave; une table.
	    Si vous souhaitez &eacute;crire quelque chose comme :
        </p><pre class="programlisting">from eg.Foo foo  
where foo.bar.baz.customer.address.city is not null</pre><p>
            vous finiriez avec une requ&ecirc;te qui n&eacute;cessiterait quatre jointures en SQL.
        </p><p>
            L'op&eacute;rateur <tt class="literal">=</tt> peut &ecirc;tre utilis&eacute; pour comparer aussi bien des propri&eacute;t&eacute;s que des instances :
        </p><pre class="programlisting">from eg.Cat cat, eg.Cat rival where cat.mate = rival.mate

select cat, mate 
from eg.Cat cat, eg.Cat mate
where cat.mate = mate</pre><p>
            La propri&eacute;t&eacute; sp&eacute;ciale (en minuscule) <tt class="literal">id</tt> peut &ecirc;tre utilis&eacute;e
	    pour faire r&eacute;f&eacute;rence &agrave; l'identifiant d'un objet (vous pouvez aussi utiliser
	    le nom de cette propri&eacute;t&eacute;).
        </p><pre class="programlisting">from eg.Cat as cat where cat.id = 123

from eg.Cat as cat where cat.mate.id = 69</pre><p>
            La seconde requ&ecirc;te est particuli&egrave;rement efficace. Aucune jointure n'est n&eacute;cessaire !
        </p><p>
            Les propri&eacute;t&eacute;s d'un identifiant compos&eacute; peuvent aussi &ecirc;tre utilis&eacute;es. Supposez que
	    <tt class="literal">Person</tt> ait un identifiant compos&eacute; de <tt class="literal">country</tt> et 
            <tt class="literal">medicareNumber</tt>.
        </p><pre class="programlisting">from bank.Person person
where person.id.country = 'AU' 
    and person.id.medicareNumber = 123456

from bank.Account account
where account.owner.id.country = 'AU' 
    and account.owner.id.medicareNumber = 123456</pre><p>
            Une fois de plus, la seconde requ&ecirc;te ne n&eacute;cessite pas de jointure.
        </p><p>
            De m&ecirc;me, la propri&eacute;t&eacute; sp&eacute;ciale <tt class="literal">class</tt> interroge la valeur discriminante
	    d'une instance dans le cas d'une persistance polymorphique. Le nom d'une classe Java incorpor&eacute;e
	    dans la clause where sera traduite par sa valeur discriminante.
        </p><pre class="programlisting">from eg.Cat cat where cat.class = eg.DomesticCat</pre><p>
            Vous pouvez aussi sp&eacute;cifier les propri&eacute;t&eacute;s des composants ou types utilisateurs compos&eacute;s
	    (components, composite user types etc). N'essayez jamais d'utiliser un expression de navigation
	    qui se terminerait par une propri&eacute;t&eacute; de type composant (qui est diff&eacute;rent d'une propri&eacute;t&eacute; d'un
	    composant). Par exemple, si <tt class="literal">store.owner</tt> est une entit&eacute; avec un composant 
	    <tt class="literal">address</tt>
        </p><pre class="programlisting">store.owner.address.city    // correct
store.owner.address         // erreur!</pre><p>
            Un type "any" poss&egrave;de les propri&eacute;t&eacute;s sp&eacute;ciales <tt class="literal">id</tt> et <tt class="literal">class</tt>,
            qui nous permettent d'exprimer une jointure de la mani&egrave;re suivante (o&ugrave; <tt class="literal">AuditLog.item</tt>
            est une propri&eacute;t&eacute; mapp&eacute;e avec <tt class="literal">&lt;any&gt;</tt>).
        </p><pre class="programlisting">from eg.AuditLog log, eg.Payment payment 
where log.item.class = 'eg.Payment' and log.item.id = payment.id</pre><p>
            Dans la requ&ecirc;te pr&eacute;c&eacute;dente, notez que <tt class="literal">log.item.class</tt> et <tt class="literal">payment.class</tt>
            feraient r&eacute;f&eacute;rence &agrave; des valeurs de colonnes de la base de donn&eacute;es compl&egrave;tement diff&eacute;rentes.	    
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-expressions"></a>11.8.&nbsp;Expressions</h2></div></div><div></div></div><p>
            Les expressions permises dans la clause <tt class="literal">where</tt> incluent
	    la plupart des choses que vous pouvez utiliser en SQL :
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    op&eacute;rateurs math&eacute;matiques <tt class="literal">+, -, *, /</tt>
                </p></li><li><p>
                    op&eacute;rateur de comparaison binaire <tt class="literal">=, &gt;=, &lt;=, &lt;&gt;, !=, like</tt>
                </p></li><li><p>
                    op&eacute;rateurs logiques <tt class="literal">and, or, not</tt>
                </p></li><li><p>
                    concatenation de cha&icirc;ne de caract&egrave;res ||
                </p></li><li><p>
                    fonctions SQL scalaires comme <tt class="literal">upper()</tt> et
                    <tt class="literal">lower()</tt>
                </p></li><li><p>
                    Parenth&egrave;ses <tt class="literal">( )</tt> indiquant un regroupement
                </p></li><li><p>
                    <tt class="literal">in</tt>,
                    <tt class="literal">between</tt>,
                    <tt class="literal">is null</tt>
                </p></li><li><p>
                    param&egrave;tres JDBC IN <tt class="literal">?</tt>
                </p></li><li><p>
                    param&egrave;tres nomm&eacute;es <tt class="literal">:name</tt>, <tt class="literal">:start_date</tt>, <tt class="literal">:x1</tt>
                </p></li><li><p>
                    litt&eacute;ral SQL <tt class="literal">'foo'</tt>, <tt class="literal">69</tt>, <tt class="literal">'1970-01-01 10:00:01.0'</tt>
                </p></li><li><p>
                    Constantes Java <tt class="literal">public static final</tt> <tt class="literal">eg.Color.TABBY</tt>
                </p></li></ul></div><p>
            <tt class="literal">in</tt> et <tt class="literal">between</tt> peuvent &ecirc;tre utilis&eacute;s comme suit :
        </p><pre class="programlisting">from eg.DomesticCat cat where cat.name between 'A' and 'B'

from eg.DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )</pre><p>
            et la forme n&eacute;gative peut &ecirc;tre &eacute;crite
        </p><pre class="programlisting">from eg.DomesticCat cat where cat.name not between 'A' and 'B'

from eg.DomesticCat cat where cat.name not in ( 'Foo', 'Bar', 'Baz' )</pre><p>
            De m&ecirc;me, <tt class="literal">is null</tt> et <tt class="literal">is not null</tt> peuvent &ecirc;tre utilis&eacute;s pour tester
	    les valeurs nulle.
        </p><p>
            Les Bool&eacute;ens peuvent &ecirc;tre facilement utilis&eacute;s en d&eacute;clarant les substitutions de requ&ecirc;tes dans la
	    configuration Hibernate :
        </p><pre class="programlisting">&lt;property name="hibernate.query.substitutions"&gt;true 1, false 0&lt;/property&gt;</pre><p>
            Ce qui remplacera les mots cl&eacute;s <tt class="literal">true</tt> et <tt class="literal">false</tt> par
            <tt class="literal">1</tt> et <tt class="literal">0</tt> dans la traduction SQL du HQL suivant:
        </p><pre class="programlisting">from eg.Cat cat where cat.alive = true</pre><p>
            Vous pouvez tester la taille d'une collection par la propri&eacute;t&eacute; sp&eacute;ciale <tt class="literal">size</tt>, ou
            la fonction sp&eacute;ciale <tt class="literal">size()</tt>.
        </p><pre class="programlisting">from eg.Cat cat where cat.kittens.size &gt; 0

from eg.Cat cat where size(cat.kittens) &gt; 0</pre><p>
            Pour les collections index&eacute;es, vous pouvez faire r&eacute;f&eacute;rence aux indices minimum et maximum en
	    utilisant <tt class="literal">minIndex</tt> and <tt class="literal">maxIndex</tt>. De mani&egrave;re similaire,
	    vous pouvez faire r&eacute;f&eacute;rence aux &eacute;l&eacute;ments minimum et maximum d'une collection de type basiques
	    en utilisant <tt class="literal">minElement</tt> et <tt class="literal">maxElement</tt>.
        </p><pre class="programlisting">from Calendar cal where cal.holidays.maxElement &gt; current date</pre><p>
            Ceci existe aussi sous forme de fonctions (qui, contrairement &agrave; l'&eacute;criture pr&eacute;c&eacute;dente, n'est pas
	    sensible &agrave; la casse):
        </p><pre class="programlisting">from Order order where maxindex(order.items) &gt; 100

from Order order where minelement(order.items) &gt; 10000</pre><p>
            Les fonctions SQL <tt class="literal">any, some, all, exists, in</tt> supportent que leur soient pass&eacute;es
	    l'&eacute;l&eacute;ment, l'index d'une collection (fonctions <tt class="literal">elements</tt> et <tt class="literal">indices</tt>)
	    ou le r&eacute;sultat d'une sous requ&ecirc;te (voir ci dessous).
        </p><pre class="programlisting">select mother from eg.Cat as mother, eg.Cat as kit
where kit in elements(foo.kittens)

select p from eg.NameList list, eg.Person p
where p.name = some elements(list.names)

from eg.Cat cat where exists elements(cat.kittens)

from eg.Player p where 3 &gt; all elements(p.scores)

from eg.Show show where 'fizard' in indices(show.acts)</pre><p>
            Notez que l'&eacute;criture de  - <tt class="literal">size</tt>, <tt class="literal">elements</tt>,
            <tt class="literal">indices</tt>, <tt class="literal">minIndex</tt>, <tt class="literal">maxIndex</tt>,
            <tt class="literal">minElement</tt>, <tt class="literal">maxElement</tt> - ont un usage restreint :
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    dans la clause <tt class="literal">where</tt> : uniquement pour les bases de donn&eacute;es qui supportent 
		    les requ&ecirc;tes imbriqu&eacute;es (sous requ&ecirc;tes)
                </p></li><li><p>
                    dans la clause <tt class="literal">select</tt> : uniquement <tt class="literal">elements</tt> et 
                    <tt class="literal">indices</tt> ont un sens
                </p></li></ul></div><p>
            Les &eacute;l&eacute;ments de collections index&eacute;es (arrays, lists, maps) peuvent &ecirc;tre r&eacute;f&eacute;renc&eacute;s via index
	    (dans une clause where seuleuement) :
        </p><pre class="programlisting">from Order order where order.items[0].id = 1234

select person from Person person, Calendar calendar
where calendar.holidays['national day'] = person.birthDay
    and person.nationality.calendar = calendar

select item from Item item, Order order
where order.items[ order.deliveredItemIndices[0] ] = item and order.id = 11

select item from Item item, Order order
where order.items[ maxindex(order.items) ] = item and order.id = 11</pre><p>
            L'expression entre <tt class="literal">[]</tt> peut m&ecirc;me &ecirc;tre une expression arithm&eacute;tique.
        </p><pre class="programlisting">select item from Item item, Order order
where order.items[ size(order.items) - 1 ] = item</pre><p>
            HQL propose aussi une fonction <tt class="literal">index()</tt> interne, pour les &eacute;l&eacute;ments
	    d'une association one-to-many ou d'une collections de valeurs.
        </p><pre class="programlisting">select item, index(item) from Order order 
    join order.items item
where index(item) &lt; 5</pre><p>
            Les fonctions SQL scalaires support&eacute;es par la base de donn&eacute;es utilis&eacute;e peuvent &ecirc;tre utilis&eacute;es
        </p><pre class="programlisting">from eg.DomesticCat cat where upper(cat.name) like 'FRI%'</pre><p>
            Si vous n'&ecirc;tes pas encore convaincu par tout cela, imaginez la taille et l'illisibilit&eacute; qui caract&eacute;riseraient
	    la transformation SQL de la requ&ecirc;te HQL suivante :
        </p><pre class="programlisting">select cust
from Product prod,
    Store store
    inner join store.customers cust
where prod.name = 'widget'
    and store.location.name in ( 'Melbourne', 'Sydney' )
    and prod = all elements(cust.currentOrder.lineItems)</pre><p>
            <span class="emphasis"><em>Un indice :</em></span> cela donnerait quelque chose comme
        </p><pre class="programlisting">SELECT cust.name, cust.address, cust.phone, cust.id, cust.current_order
FROM customers cust,
    stores store,
    locations loc,
    store_customers sc,
    product prod
WHERE prod.name = 'widget'
    AND store.loc_id = loc.id
    AND loc.name IN ( 'Melbourne', 'Sydney' )
    AND sc.store_id = store.id
    AND sc.cust_id = cust.id
    AND prod.id = ALL(
        SELECT item.prod_id
        FROM line_items item, orders o
        WHERE item.order_id = o.id
            AND cust.current_order = o.id
    )</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-ordering"></a>11.9.&nbsp;La clause order by</h2></div></div><div></div></div><p>
            La liste retoun&eacute;e par la requ&ecirc;te peut &ecirc;tre tri&eacute;e par n'importe quelle propri&eacute;t&eacute; de la classe ou
	    du composant retourn&eacute; :
        </p><pre class="programlisting">from eg.DomesticCat cat
order by cat.name asc, cat.weight desc, cat.birthdate</pre><p>
            Le mot optionnel <tt class="literal">asc</tt> ou <tt class="literal">desc</tt> indique respectivement si le tri
	    doit &ecirc;tre croissant ou d&eacute;croissant.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-grouping"></a>11.10.&nbsp;La clause group by</h2></div></div><div></div></div><p>
            Si la requ&ecirc;te retourne des valeurs aggr&eacute;g&eacute;es, celles ci peuvent &ecirc;tre group&eacute;es par propri&eacute;t&eacute; ou composant :
        </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat) 
from eg.Cat cat
group by cat.color

select foo.id, avg( elements(foo.names) ), max( indices(foo.names) ) 
from eg.Foo foo
group by foo.id</pre><p>
            Note: vous pouvez aussi utiliser l'&eacute;criture <tt class="literal">elements</tt> et <tt class="literal">indices</tt>
            dans une clause select, m&ecirc;me pour des bases de donn&eacute;es qui ne supportent pas les sous requ&ecirc;tes.
        </p><p>
            Une clause <tt class="literal">having</tt> est aussi permise.
        </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat) 
from eg.Cat cat
group by cat.color 
having cat.color in (eg.Color.TABBY, eg.Color.BLACK)</pre><p>
            Les fonctions SQL et les fonctions d'aggr&eacute;gations sont permises dans les clauses <tt class="literal">having</tt>
            et <tt class="literal">order by</tt>, si elles sont support&eacute;es par la base de donn&eacute;es (ce que ne fait pas MySQL par exemple).
        </p><pre class="programlisting">select cat
from eg.Cat cat
    join cat.kittens kitten
group by cat
having avg(kitten.weight) &gt; 100
order by count(kitten) asc, sum(kitten.weight) desc</pre><p>
            Notez que ni la clause <tt class="literal">group by</tt> ni la clause
            <tt class="literal">order by</tt> ne peuvent contenir d'expressions arithm&eacute;tiques.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-subqueries"></a>11.11.&nbsp;Sous requ&ecirc;tes</h2></div></div><div></div></div><p>
            Pour les bases de donn&eacute;es le supportant, Hibernate supporte les sous requ&ecirc;tes dans les requ&ecirc;tes.
	    Une sous requ&ecirc;te doit &ecirc;tre entre parenth&egrave;ses (souvent pour un appel &agrave; une fonction d'agr&eacute;gation SQL)
	    M&ecirc;me les sous requ&ecirc;tes corr&eacute;l&eacute;es (celles qui font r&eacute;f&eacute;rence &agrave; un alias de la requ&ecirc;te principale) sont
	    support&eacute;es.
        </p><pre class="programlisting">from eg.Cat as fatcat 
where fatcat.weight &gt; ( 
    select avg(cat.weight) from eg.DomesticCat cat 
)

from eg.DomesticCat as cat 
where cat.name = some ( 
    select name.nickName from eg.Name as name 
)
    
from eg.Cat as cat 
where not exists ( 
    from eg.Cat as mate where mate.mate = cat 
)

from eg.DomesticCat as cat 
where cat.name not in ( 
    select name.nickName from eg.Name as name 
)</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-examples"></a>11.12.&nbsp;Exemples HQL</h2></div></div><div></div></div><p>
            Les requ&ecirc;tes Hibernate peuvent &ecirc;tre relativement puissantes et complexes. En fait, la puissance
	    du langage de requ&ecirc;tage est l'un des avantages principaux d'Hibernate. Voici quelques exemples
	    tr&egrave;s similaires aux requ&ecirc;tes que nous avons utilis&eacute;es lors d'un r&eacute;cent projet. Notez que la plupart
	    des requ&ecirc;tes que vous &eacute;crirez seront plus simples que les exemples suivantes !
        </p><p>
            La requ&ecirc;te suivante retourne l'id de commande (order), le nombre d'articles (items) et la valeur
	    totale de la commande (order) pour toutes les commandes non pay&eacute;es d'un client (customer) particulier
	    pour un total minimum donn&eacute;, le tout tri&eacute; par la valeur totale. La requ&ecirc;te SQL g&eacute;n&eacute;r&eacute;e sur les tables
	    <tt class="literal">ORDER</tt>, <tt class="literal">ORDER_LINE</tt>, <tt class="literal">PRODUCT</tt>,
            <tt class="literal">CATALOG</tt> et <tt class="literal">PRICE</tt> est compos&eacute;e de quatre jointures interne ainsi que
	    d'une sous requ&ecirc;te non corr&eacute;l&eacute;e.
        </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog.effectiveDate &lt; sysdate
    and catalog.effectiveDate &gt;= all (
        select cat.effectiveDate 
        from Catalog as cat
        where cat.effectiveDate &lt; sysdate
    )
group by order
having sum(price.amount) &gt; :minAmount
order by sum(price.amount) desc</pre><p>
            Quel monstre ! 
	    En principe, nous ne sommes pas tr&egrave;s fan des sous requ&ecirc;tes, la requ&ecirc;te ressemblait donc plut&ocirc;t
	    &agrave; cela :
        </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog = :currentCatalog
group by order
having sum(price.amount) &gt; :minAmount
order by sum(price.amount) desc</pre><p>
            La requ&ecirc;te suivante compte le nombre de paiements (payments) pour chaque status, en excluant 
	    les paiements dans le status <tt class="literal">AWAITING_APPROVAL</tt> o&ugrave; le changement de status
	    le plus r&eacute;cent &agrave; &eacute;t&eacute; fait par l'utilisateur courant. En SQL, cette requ&ecirc;te effectue deux
	    jointures internes et des sous requ&ecirc;tes corr&eacute;l&eacute;es sur les tables <tt class="literal">PAYMENT</tt>, 
	    <tt class="literal">PAYMENT_STATUS</tt> et <tt class="literal">PAYMENT_STATUS_CHANGE</tt>.
        </p><pre class="programlisting">select count(payment), status.name 
from Payment as payment 
    join payment.currentStatus as status
    join payment.statusChanges as statusChange
where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL
    or (
        statusChange.timeStamp = ( 
            select max(change.timeStamp) 
            from PaymentStatusChange change 
            where change.payment = payment
        )
        and statusChange.user &lt;&gt; :currentUser
    )
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>
            Si nous avions mapp&eacute; la collection <tt class="literal">statusChanges</tt> comme une list, au lieu d'un set, 
            la requ&ecirc;te aurait &eacute;t&eacute; plus facile &agrave; &eacute;crire.
        </p><pre class="programlisting">select count(payment), status.name 
from Payment as payment
    join payment.currentStatus as status
where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL
    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user &lt;&gt; :currentUser
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>
            La requ&ecirc;te qui suit utilise la fonction de MS SQL <tt class="literal">isNull()</tt> pour retourner 
	    tous les comptes (accounts) et paiements (payments) impay&eacute;s pour l'organisation &agrave; laquelle
	    l'uilisateur (user) courant appartient. Elle est traduite en SQL par trois jointures internes,
	    une jointure externe ainsi qu'une sous requ&ecirc;te sur les tables <tt class="literal">ACCOUNT</tt>, <tt class="literal">PAYMENT</tt>, 
	    <tt class="literal">PAYMENT_STATUS</tt>, <tt class="literal">ACCOUNT_TYPE</tt>, <tt class="literal">ORGANIZATION</tt> et 
            <tt class="literal">ORG_USER</tt>.
        </p><pre class="programlisting">select account, payment
from Account as account
    left outer join account.payments as payment
where :currentUser in elements(account.holder.users)
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre><p>
            Pour d'autres base de donn&eacute;es, nous aurions d&ucirc; faire sans la sous requ&ecirc;te (corr&eacute;l&eacute;e)
        </p><pre class="programlisting">select account, payment
from Account as account
    join account.holder.users as user
    left outer join account.payments as payment
where :currentUser = user
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-tipstricks"></a>11.13.&nbsp;Trucs &amp; Astuces</h2></div></div><div></div></div><p>
            Vous pouvez compter le nombre de r&eacute;sultats d'une requ&ecirc;te sans les retourner :
        </p><pre class="programlisting">( (Integer) session.iterate("select count(*) from ....").next() ).intValue()</pre><p>
            Pour trier les r&eacute;sultats par la taille d'une collection, utilisez :
        </p><pre class="programlisting">select usr.id, usr.name
from User as usr 
    left join usr.messages as msg
group by usr.id, usr.name
order by count(msg)</pre><p>
            Si votre base de donn&eacute;es supporte les sous requ&ecirc;tes, vous pouvez placer des 
	    conditions sur la taille de la s&eacute;lection dans la clause where de votre requ&ecirc;te :
        </p><pre class="programlisting">from User usr where size(usr.messages) &gt;= 1</pre><p>
            Si votre base de donn&eacute;es ne supporte pas les sous requ&ecirc;tes, utilisez :
        </p><pre class="programlisting">select usr.id, usr.name
from User usr.name
    join usr.messages msg
group by usr.id, usr.name
having count(msg) &gt;= 1</pre><p>
            Cette solution ne peut pas retourner un <tt class="literal">User</tt> avec z&eacute;ro message
            &agrave; cause de la jointure interne, la forme suivante peut donc &ecirc;tre utile :
        </p><pre class="programlisting">select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
having count(msg) = 0</pre><p>
            Les propri&eacute;t&eacute;s d'un JavaBean peuvent &ecirc;tre inject&eacute;es dans les param&egrave;tres nomm&eacute;s d'un requ&ecirc;te :
        </p><pre class="programlisting">Query q = s.createQuery("from foo in class Foo where foo.name=:name and foo.size=:size");
q.setProperties(fooBean); // fooBean poss&egrave;de getName() and getSize()
List foos = q.list();</pre><p>
            Les collections sont paginables via l'utilisation de l'interface <tt class="literal">Query</tt> avec un filtre :
        </p><pre class="programlisting">Query q = s.createFilter( collection, "" ); // the trivial filter
q.setMaxResults(PAGE_SIZE);
q.setFirstResult(PAGE_SIZE * pageNumber);
List page = q.list();</pre><p>
            Les &eacute;l&eacute;ments d'une collection peuvent &ecirc;tre tri&eacute;s ou group&eacute;s en utilisant un filtre de requ&ecirc;te :
        </p><pre class="programlisting">Collection orderedCollection = s.filter( collection, "order by this.amount" );
Collection counts = s.filter( collection, "select this.type, count(this) group by this.type" );</pre><p>
            Vous pouvez r&eacute;cup&eacute;rer la taille d'une collection sans l'initialiser :
        </p><pre class="programlisting">( (Integer) session.iterate("select count(*) from ....").next() ).intValue();</pre></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="querycriteria"></a>Chapitre&nbsp;12.&nbsp;Requ&ecirc;tes par crit&egrave;res</h2></div></div><div></div></div><p>
        Intuitive et extensible, l'API d'interrogation par crit&egrave;re est d&eacute;sormais offerte par Hibernate. 
        Pour le moment, cette API est moins puissante que l'HQL et toutes les possibilit&eacute;s qu'il offre.
	En particulier, criteria ne supporte pas la projection ou l'aggr&eacute;gation.
    </p><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-creating"></a>12.1.&nbsp;Cr&eacute;er une instance de <tt class="literal">Criteria</tt></h2></div></div><div></div></div><p>
            L'interface <tt class="literal">net.sf.hibernate.Criteria</tt> repr&eacute;sente une requ&ecirc;te sur une
	    classe persistente donn&eacute;e. La <tt class="literal">Session</tt> fournit les instances de
            <tt class="literal">Criteria</tt>.
        </p><pre class="programlisting">Criteria crit = sess.createCriteria(Cat.class);
crit.setMaxResults(50);
List cats = crit.list();</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-narrowing"></a>12.2.&nbsp;Restriction du r&eacute;sultat</h2></div></div><div></div></div><p>
            Un criterion (crit&egrave;re de recherche) est une instance de l'interface
            <tt class="literal">net.sf.hibernate.expression.Criterion</tt>. La classe
            <tt class="literal">net.sf.hibernate.expression.Expression</tt> d&eacute;finit
            des m&eacute;thodes pour obtenir des types de <tt class="literal">Criterion</tt>
	    pr&eacute; d&eacute;finis.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Expression.like("name", "Fritz%") )
    .add( Expression.between("weight", minWeight, maxWeight) )
    .list();</pre><p>
            Les expressions peuvent &ecirc;tre goup&eacute;es de mani&egrave;re logique.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Expression.like("name", "Fritz%") )
    .add( Expression.or(
        Expression.eq( "age", new Integer(0) ),
        Expression.isNull("age")
    ) )
    .list();</pre><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Expression.in( "name", new String[] { "Fritz", "Izi", "Pk" } ) )
    .add( Expression.disjunction()
        .add( Expression.isNull("age") )
    	.add( Expression.eq("age", new Integer(0) ) )
    	.add( Expression.eq("age", new Integer(1) ) )
    	.add( Expression.eq("age", new Integer(2) ) )
    ) )
    .list();</pre><p>
            Il y a plusieurs types de criterion pr&eacute; d&eacute;finis (sous classes de <tt class="literal">Expression</tt>),
	    mais l'une d'entre elle particuli&egrave;rement utile vous permet de sp&eacute;cifier directement
	    du SQL.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Expression.sql("lower({alias}.name) like lower(?)", "Fritz%", Hibernate.STRING) )
    .list();</pre><p>
            La zone <tt class="literal">{alias}</tt> sera remplac&eacute;e par l'alias de colonne de l'entit&eacute; 
	    que l'on souhaite int&eacute;rroger.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-ordering"></a>12.3.&nbsp;Trier les r&eacute;sultats</h2></div></div><div></div></div><p>
            Vous pouvez trier les r&eacute;sultats en utilisant <tt class="literal">net.sf.hibernate.expression.Order</tt>.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Expression.like("name", "F%")
    .addOrder( Order.asc("name") )
    .addOrder( Order.desc("age") )
    .setMaxResults(50)
    .list();</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-associations"></a>12.4.&nbsp;Associations</h2></div></div><div></div></div><p>
            Vous pouvez facilement sp&eacute;cifier des contraintes sur des entit&eacute;s li&eacute;es,
	    par des associations en utilisant <tt class="literal">createCriteria()</tt>.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Expression.like("name", "F%")
    .createCriteria("kittens")
        .add( Expression.like("name", "F%")
    .list();</pre><p>
            Notez que la seconde <tt class="literal">createCriteria()</tt> retourne une nouvelle
	    instance de <tt class="literal">Criteria</tt>, qui se rapporte aux &eacute;l&eacute;ments de la 
	    collection <tt class="literal">kittens</tt>.
        </p><p>
            La forme alternative suivante est utile dans certains cas.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .createAlias("kittens", "kt")
    .createAlias("mate", "mt")
    .add( Expression.eqProperty("kt.name", "mt.name") )
    .list();</pre><p>
            (<tt class="literal">createAlias()</tt> ne cr&eacute;&eacute; par de nouvelle instance de
            <tt class="literal">Criteria</tt>.)
        </p><p>
            Notez que les collections kittens contenues dans les instances de <tt class="literal">Cat</tt>
            retourn&eacute;es par les deux pr&eacute;c&eacute;dentes requ&ecirc;tes ne sont <span class="emphasis"><em>pas</em></span> pr&eacute;-filtr&eacute;es
            par les crit&egrave;res ! Si vous souhaitez r&eacute;cup&eacute;rer uniquement les kittens qui correspondent &agrave; la
            criteria, vous devez utiliser <tt class="literal">returnMaps()</tt>.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .createCriteria("kittens", "kt")
        .add( Expression.eq("name", "F%") )
    .returnMaps()
    .list();
Iterator iter = cats.iterator();
while ( iter.hasNext() ) {
    Map map = (Map) iter.next();
    Cat cat = (Cat) map.get(Criteria.ROOT_ALIAS);
    Cat kitten = (Cat) map.get("kt");
}</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-dynamicfetching"></a>12.5.&nbsp;Peuplement d'associations de mani&egrave;re dynamique</h2></div></div><div></div></div><p>
            Vous pouvez sp&eacute;ficier au runtime le peuplement d'une association en utilisant
            <tt class="literal">setFetchMode()</tt> (c'est-&agrave;-dire le chargement de celle-ci).
            Cela permet de surcharger les valeurs
            "lazy" et "outer-join" du mapping.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Expression.like("name", "Fritz%") )
    .setFetchMode("mate", FetchMode.EAGER)
    .setFetchMode("kittens", FetchMode.EAGER)
    .list();</pre><p>
            Cette requ&ecirc;te recherchera <tt class="literal">mate</tt> et <tt class="literal">kittens</tt>
            via les jointures externes.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-examples"></a>12.6.&nbsp;Requ&ecirc;te par l'exemple</h2></div></div><div></div></div><p>
            La classe <tt class="literal">net.sf.hibernate.expression.Example</tt> vous permet de 
	    construire un crit&egrave;re suivant une instance d'objet donn&eacute;e.
        </p><pre class="programlisting">Cat cat = new Cat();
cat.setSex('F');
cat.setColor(Color.BLACK);
List results = session.createCriteria(Cat.class)
    .add( Example.create(cat) )
    .list();</pre><p>
           Les propri&eacute;t&eacute;s de type version, identifiant et association sont ignor&eacute;es.
	   Par d&eacute;faut, les valeurs null sont exclues.
        </p><p>
           Vous pouvez ajuster la strat&eacute;gie d'utilisation de valeurs de 
           l'<tt class="literal">Exemple</tt>.
        </p><pre class="programlisting">Example example = Example.create(cat)
    .excludeZeroes()           //exclure les valeurs z&eacute;ro
    .excludeProperty("color")  //exclure la propri&eacute;t&eacute; nomm&eacute;e "color"
    .ignoreCase()              //ne respecte pas la casse sur les chaines de caract&egrave;res
    .enableLike();             //utilise like pour les comparaisons de string
List results = session.createCriteria(Cat.class)
    .add(example)
    .list();</pre><p>
            Vous pouvez utiliser les "exemples" pour des crit&egrave;res sur les objets associ&eacute;s.
        </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .add( Example.create(cat) )
    .createCriteria("mate")
        .add( Example.create( cat.getMate() ) )
    .list();</pre></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="querysql"></a>Chapitre&nbsp;13.&nbsp;Requ&ecirc;tes en sql natif</h2></div></div><div></div></div><p>
        Vous pouvez aussi &eacute;crire vos requ&ecirc;tes dans le dialecte SQL natif de votre base de donn&eacute;es.
	Ceci est utile si vous souhaitez utiliser les fonctionnalit&eacute;s sp&eacute;cifiques de votre base de
	donn&eacute;es comme le mot cl&eacute; CONNECT d'Oracle. Cette fonctionnalit&eacute; offre par ailleurs un moyen
	de migration plus propre et doux d'une application bas&eacute;e sur SQL/JDBC vers 
    une application Hibernate.
    </p><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-creating"></a>13.1.&nbsp;Cr&eacute;er une requ&ecirc;te bas&eacute;e sur SQL</h2></div></div><div></div></div><p>
            Les requ&ecirc;tes de type SQL sont invocables via l'interface <tt class="literal">Query</tt> comme les
	    requ&ecirc;tes HQL. La seule diff&eacute;rence est l'utilisation de <tt class="literal">Session.createSQLQuery()</tt>.
        </p><pre class="programlisting">Query sqlQuery = sess.createSQLQuery("select {cat.*} from cats {cat}", "cat", Cat.class);
sqlQuery.setMaxResults(50);
List cats = sqlQuery.list();</pre><p>
            Les trois arguments n&eacute;cessaires &agrave; <tt class="literal">createSQLQuery()</tt> sont :
        </p><div class="itemizedlist"><ul type="disc"><li><p>
            la cha&icirc;ne de caract&egrave;res repr&eacute;sentant la requ&ecirc;te SQL
        </p></li><li><p>
            un alias de table
        </p></li><li><p>
            la classe persistante retourn&eacute;e par la requ&ecirc;te
        </p></li></ul></div><p>
            L'alias est utilis&eacute; dans la requ&ecirc;te pour r&eacute;f&eacute;rencer les propri&eacute;t&eacute;s de la classe mapp&eacute;e
	    (<tt class="literal">Cat</tt> dans notre exemple). Vous pouvez r&eacute;cup&eacute;rer plusieurs objets par
	    ligne en passant en argument un tableau de string (d'alias) ainsi que le 
	    tableau de <tt class="literal">Class</tt> correspondantes.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-aliasreferences"></a>13.2.&nbsp;Alias et r&eacute;f&eacute;rences de propri&eacute;t&eacute;s</h2></div></div><div></div></div><p>
            La notation <tt class="literal">{cat.*}</tt> utilis&eacute;e pr&eacute;c&eacute;demment signifie "toutes les propri&eacute;t&eacute;s".
	    Vous pouvez lister de mani&egrave;re explicite les propri&eacute;t&eacute;s, mais vous devez laisser Hibernate
	    g&eacute;rer les alias SQL des colonnes pour chaque propri&eacute;t&eacute;. La forme/nom de ces 
	    alias de colonnes est l'alias de leur table postfix&eacute; par le nom de la propri&eacute;t&eacute; (cat.id).
	    Dans l'exemple suivant, nous r&eacute;cup&eacute;rons <tt class="literal">Cat</tt>s depuis une table (<tt class="literal">cat_log</tt>) 
	    diff&eacute;rente de celle d&eacute;clar&eacute;e dans nos m&eacute;tadonn&eacute;es de mapping. Notez que nous pouvons 
	    utiliser l'alias de la propri&eacute;t&eacute; dans la clause where.
        </p><pre class="programlisting">String sql = "select cat.originalId as {cat.id}, "
    + "  cat.mateid as {cat.mate}, cat.sex as {cat.sex}, "
    + "  cat.weight*10 as {cat.weight}, cat.name as {cat.name}"
    + "     from cat_log cat where {cat.mate} = :catId"
List loggedCats = sess.createSQLQuery(sql, "cat", Cat.class)
    .setLong("catId", catId)
    .list();
</pre><p>
            <span class="emphasis"><em>A savoir :</em></span> si vous listez chaque propri&eacute;t&eacute; de mani&egrave;re explicite,
	    vous devez inclure toutes les propri&eacute;t&eacute;s de la classe et de ses <span class="emphasis"><em>sous-classes</em></span> !
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-namedqueries"></a>13.3.&nbsp;Requ&ecirc;tes SQL nomm&eacute;es</h2></div></div><div></div></div><p>
            Des requ&ecirc;tes SQL nomm&eacute;es peuvent &ecirc;tre d&eacute;finies dans le document de mapping et &ecirc;tre
	    appell&eacute;es de la m&ecirc;me mani&egrave;re que les requ&ecirc;tes HQL nomm&eacute;es.
        </p><pre class="programlisting">List people = sess.getNamedQuery("mySqlQuery")
    .setMaxResults(50)
    .list();</pre><pre class="programlisting">&lt;sql-query name="mySqlQuery"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    SELECT {person}.NAME AS {person.name},
           {person}.AGE AS {person.age},
           {person}.SEX AS {person.sex}
    FROM PERSON {person} WHERE {person}.NAME LIKE 'Hiber%'
&lt;/sql-query&gt;</pre></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="performance"></a>Chapitre&nbsp;14.&nbsp;Am&eacute;liorer les performances</h2></div></div><div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-collections"></a>14.1.&nbsp;Comprendre les performances des Collections</h2></div></div><div></div></div><p>
            Nous avons d&eacute;j&agrave; pass&eacute; du temps &agrave; discuter des collections.
	    Dans cette section, nous allons traiter du comportement des
	    collections &agrave; l'ex&eacute;cution.
        </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-taxonomy"></a>14.1.1.&nbsp;Classification</h3></div></div><div></div></div><p>Hibernate d&eacute;finit trois types de collections :</p><div class="itemizedlist"><ul type="disc"><li><p>les collections de valeurs</p></li><li><p>les associations un-vers-plusieurs</p></li><li><p>les associations plusieurs-vers-plusieurs</p></li></ul></div><p>
                Cette classification distingue les diff&eacute;rentes relations entre les tables
		et les cl&eacute;s &eacute;trang&egrave;res mais ne nous apprend rien de ce que nous devons savoir
		sur le mod&egrave;le relationnel. Pour comprendre parfaitement la structure relationnelle
		et les caract&eacute;ristiques des performances, nous devons consid&eacute;rer la structure
		de la cl&eacute; primaire qui est utilis&eacute;e par Hibernate pour mettre &agrave; jour ou supprimer
		les &eacute;l&eacute;ments des collections. Cel&agrave; nous am&egrave;ne aux classifications suivantes :
            </p><div class="itemizedlist"><ul type="disc"><li><p>collections index&eacute;es</p></li><li><p>sets</p></li><li><p>bags</p></li></ul></div><p>
                Toutes les collections index&eacute;es (maps, lists, arrays) ont une cl&eacute; primaire constitu&eacute;e 
		des colonnes cl&eacute; (<tt class="literal">&lt;key&gt;</tt>) et <tt class="literal">&lt;index&gt;</tt>.
		Avec ce type de cl&eacute; primaire, la mise &agrave; jour de collection est en g&eacute;n&eacute;ral tr&egrave;s performante - la cl&eacute;
		primaire peut &ecirc;tre index&eacute;es efficacement et un &eacute;l&eacute;ment particulier peut &ecirc;tre 
		localis&eacute; efficacement lorsqu'Hibernate essaie de le mettre &agrave; jour ou de le supprimer.
            </p><p>
                Les Sets ont une cl&eacute; primaire compos&eacute;e de <tt class="literal">&lt;key&gt;</tt> et des
        colonnes repr&eacute;sentant l'&eacute;l&eacute;ment. Elle est donc moins efficace pour certains 
        types de collections d'&eacute;l&eacute;ments, en particulier les &eacute;l&eacute;ments composites, 
        les textes volumineux ou les champs binaires ; la base de donn&eacute;es
		peut ne pas &ecirc;tre capable d'indexer aussi efficacement une cl&eacute; primaire 
        aussi complexe. Cependant, pour les associations un-vers-plusieurs 
        ou plusieurs-vers-plusieurs, sp&eacute;cialement lorsque l'on utilise des entit&eacute;s
        ayant des identifiants techniques, il est probable que cela soit aussi efficace
		(note : si vous voulez que <tt class="literal">SchemaExport</tt> cr&eacute;&eacute; effectivement
        la cl&eacute; primaire	d'un <tt class="literal">&lt;set&gt;</tt> pour vous, vous devez 
        d&eacute;clarer toutes les colonnes avec <tt class="literal">not-null="true"</tt>).
            </p><p>
                Le pire cas intervient pour les Bags. Dans la mesure o&ugrave; un bag permet 
        la duplications des &eacute;l&eacute;ments et n'a pas de colonne d'index, aucune cl&eacute; primaire 
        ne peut &ecirc;tre d&eacute;finie. Hibernate	n'a aucun moyen de distinguer des enregistrements 
        dupliqu&eacute;s. Hibernate r&eacute;sout ce probl&egrave;me en supprimant compl&egrave;tement les 
        enregistrements (via un simple <tt class="literal">DELETE</tt>), puis en recr&eacute;ant
		la collection chaque fois qu'elle change. Ce qui peut &ecirc;tre tr&egrave;s inefficace.
            </p><p>
                Notez que pour une relation un-vers-plusieurs, la "cl&eacute; primaire" 
        peut ne pas &ecirc;tre la cl&eacute;	primaire de la table en base de donn&eacute;es - 
        mais m&ecirc;me dans ce cas, la classification ci-dessus reste utile 
        (Elle explique comment Hibernate "localise" chaque enregistrement
		de la collection).
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-mostefficientupdate"></a>14.1.2.&nbsp;Les lists, les maps et les sets sont les collections les plus efficaces pour la mise &agrave; jour</h3></div></div><div></div></div><p>
                La discussion pr&eacute;c&eacute;dente montre clairement que les collections index&eacute;es 
        et (la plupart du temps) les sets, permettent de r&eacute;aliser le plus efficacement 
        les op&eacute;rations d'ajout, de suppression ou de modification d'&eacute;l&eacute;ments.		
            </p><p>
                Il existe un autre avantage qu'ont les collections index&eacute;es sur les Sets 
		dans le cadre d'une association plusieurs vers plusieurs ou d'une collection de valeurs.
		A cause de la structure inh&eacute;rente d'un <tt class="literal">Set</tt>, Hibernate n'effectue jamais  
		d'<tt class="literal">UPDATE</tt> quand un enregistrement est modifi&eacute;. Les modifications
		apport&eacute;es &agrave; un <tt class="literal">Set</tt> se font via un <tt class="literal">INSERT</tt> et <tt class="literal">DELETE</tt> 
		(de chaque enregistrement). Une fois de plus, ce cas ne s'applique pas aux associations
		un vers plusieurs.
            </p><p>
                Apr&egrave;s s'&ecirc;tre rappel&eacute; que les tableaux ne peuvent pas &ecirc;tre charg&eacute;s tardivement,
        nous pouvons conclure que les lists, les maps et les sets sont les types de collections
        les plus performants. (tout en remarquant, que pour certaines valeurs de collections, 
        les sets peuvent &ecirc;tre moins performants).
            </p><p>
                Les sets sont consid&eacute;r&eacute;s comme le type de collection le plus r&eacute;pendu
                dans des applications bas&eacute;es sur Hibernate.
            </p><p>
                <span class="emphasis"><em>Il existe une fonctionnalit&eacute; non document&eacute;e dans cette version 
        d'Hibernate : les mapping <tt class="literal">&lt;idbag&gt;</tt> impl&eacute;mentent la 
        s&eacute;mantique des bags pour une collection de valeurs ou une association 
        plusieurs vers plusieurs et sont plus performants que les autres types de 
        collections dans le cas qui nous occupe !</em></span>
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-mostefficentinverse"></a>14.1.3.&nbsp;Les Bags et les lists sont les plus efficaces pour les collections inverse</h3></div></div><div></div></div><p>
                Avant que vous n'oubliez les bags pour toujours, il y a un cas pr&eacute;cis o&ugrave; les bags 
        (et les lists) sont bien plus performants que les sets. Pour une collection marqu&eacute;e
        comme <tt class="literal">inverse="true"</tt>	(le choix le plus courant pour un relation
        un vers plusieurs bidirectionnelle), nous pouvons ajouter des &eacute;l&eacute;ments &agrave; un bag 
        ou une list sans avoir besoin de l'initialiser (fetch) les &eacute;l&eacute;ments du sac! 
        Ceci parce que <tt class="literal">Collection.add()</tt> ou <tt class="literal">Collection.addAll()</tt> 
		doit toujours retourner vrai pour un bag ou une <tt class="literal">List</tt>
        (contrairement au <tt class="literal">Set</tt>). 
		Cela peut rendre le code suivant beaucoup plus rapide.
            </p><pre class="programlisting">Parent p = (Parent) sess.load(Parent.class, id);
    Child c = new Child();
    c.setParent(p);
    p.getChildren().add(c);  //pas besoin de charger la collection !
    sess.flush();</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-oneshotdelete"></a>14.1.4.&nbsp;Suppression en un coup</h3></div></div><div></div></div><p>
                Parfois, effacer les &eacute;l&eacute;ments d'une collection un par un peut &ecirc;tre extr&ecirc;mement inefficace.
		Hibernate n'est pas totalement stupide, il sait qu'il ne faut pas le faire dans le cas d'une
		collection compl&egrave;tement vid&eacute;e (lorsque vous appellez <tt class="literal">list.clear()</tt>, par exemple).
		Dans ce cas, Hibernate fera un simple <tt class="literal">DELETE</tt> et le travail est fait !
            </p><p>
                Supposons que nous ajoutions un &eacute;l&eacute;ment dans une collection de taille vingt et que nous
		enlevions ensuite deux &eacute;l&eacute;ments. Hibernate effectuera un <tt class="literal">INSERT</tt> puis
		deux <tt class="literal">DELETE</tt> (&agrave; moins que la collection ne soit un bag). Ce qui est
		souhaitable.
            </p><p>
                Cependant, supposons que nous enlevions dix huit &eacute;l&eacute;ments, laissant ainsi deux &eacute;l&eacute;ments, puis
		que nous ajoutions trois nouveaux &eacute;l&eacute;ments. Il y a deux moyens de proc&eacute;der.
            </p><div class="itemizedlist"><ul type="disc"><li><p>effacer dix huit enregistrements un &agrave; un puis en ins&eacute;rer trois</p></li><li><p>effacer la totalit&eacute; de la collection (en un <tt class="literal">DELETE</tt> SQL) puis ins&eacute;rer
                les cinq &eacute;l&eacute;ments restant un &agrave; un</p></li></ul></div><p>
                Hibernate n'est pas assez intelligent pour savoir que, dans ce cas, la seconde m&eacute;thode est plus
		rapide (Il plut&ocirc;t heureux qu'Hibernate ne soit pas trop intelligent ; un tel comportement
		pourrait rendre l'utilisation de triggers de bases de donn&eacute;es plut&ocirc;t al&eacute;atoire, etc...).
            </p><p>
                Heureusement, vous pouvez forcer ce comportement lorsque vous le souhaitez, en liberant 
        (c'est-&agrave;-dire en d&eacute;r&eacute;f&eacute;ren&ccedil;ant) la collection initiale et en retournant une collection
        nouvellement instanci&eacute;e avec les &eacute;l&eacute;ments restants. Ceci peut &ecirc;tre tr&egrave;s pratique et 
        tr&egrave;s puissant de temps en temps.
            </p></div></div><p>
        Nous avons d&eacute;j&agrave; pr&eacute;sent&eacute; l'utilisation de l'initialisation tardive pour les collections persistantes
	dans le chapitre sur le mapping des collections. Une fonctionnalit&eacute; similaire existe pour les
	r&eacute;f&eacute;rences aux objets ordinaires, elle utilise les proxys CGLIB. Nous avons &eacute;galement
    mentionn&eacute; comment Hibernate met en cache les objets persistants au niveau de la 
    <tt class="literal">Session</tt>. Des strat&eacute;gies de cache plus aggressives peuvent 
    &ecirc;tre configur&eacute;es classe par classe.
    </p><p>
        Dans la section suivante, nous vous montrerons comment utiliser ces fonctionnalit&eacute;s, qui peuvent &ecirc;tre
	utlis&eacute;es pour atteindre des performantes plus &eacute;lev&eacute;es, quand cela est n&eacute;cessaire.
    </p><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-proxies"></a>14.2.&nbsp;Proxy pour une Initialisation Tardive</h2></div></div><div></div></div><p>
            Hibernate impl&eacute;mente l'initialisation tardive d'objets persistants via
            la g&eacute;n&eacute;ration de proxy par bytecode enhancement &agrave; l'ex&eacute;cution
            (gr&acirc;ce &agrave; l'excellente biblioth&egrave;que CGLIB).
        </p><p>
            Le fichier de mapping d&eacute;clare une classe ou une interface &agrave; utiliser comme interface
	    proxy pour la classe. L'approche recommand&eacute;e est de d&eacute;finir la classe elle-m&ecirc;me :
        </p><pre class="programlisting">&lt;class name="eg.Order" proxy="eg.Order"&gt;</pre><p>
            Le type des proxys &agrave; l'ex&eacute;cution sera une sous classe de <tt class="literal">Order</tt>. 
	    Notez que les classes soumises &agrave; proxy doivent impl&eacute;menter un contructeur par d&eacute;faut
	    avec au minimum la visibilit&eacute; package.
        </p><p>
            Il y a quelques pr&eacute;cautions &agrave; prendre lorsque l'on &eacute;tend cette approche &agrave; des classes
	    polymorphiques, exemple :
        </p><pre class="programlisting">&lt;class name="eg.Cat" proxy="eg.Cat"&gt;
    ......
    &lt;subclass name="eg.DomesticCat" proxy="eg.DomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
            Tout d'abord, les instances de <tt class="literal">Cat</tt> ne pourront jamais &ecirc;tre "cast&eacute;es"
	    en <tt class="literal">DomesticCat</tt>, m&ecirc;me si l'instance sous jacente est une instance 
	    de <tt class="literal">DomesticCat</tt>.
        </p><pre class="programlisting">Cat cat = (Cat) session.load(Cat.class, id);  // instancie un proxy (n'interroge pas la base de donn&eacute;es)
if ( cat.isDomesticCat() ) {                  // interroge la base de donn&eacute;es pour initialiser le proxy
    DomesticCat dc = (DomesticCat) cat;       // Erreur !
    ....
}</pre><p>
            Deuxi&egrave;mement, il est possible de casser la notion d'<tt class="literal">==</tt> des proxy.
        </p><pre class="programlisting">
Cat cat = (Cat) session.load(Cat.class, id);            // instancie un proxy Cat
DomesticCat dc = 
    (DomesticCat) session.load(DomesticCat.class, id);  // un nouveau proxy Cat est requis !
System.out.println(cat==dc);                            // faux</pre><p>
            Cette situation n'est pas si mauvaise qu'il n'y parait. M&ecirc;me si nous avons deux
	    r&eacute;f&eacute;rences &agrave; deux objets proxys diff&eacute;rents, l'instance de base sera quand m&ecirc;me le m&ecirc;me objet :
        </p><pre class="programlisting">cat.setWeight(11.0);  // interroge la base de donn&eacute;es pour initialiser le proxy
System.out.println( dc.getWeight() );  // 11.0</pre><p>
            Troisi&egrave;mement, vous ne pourrez pas utiliser un proxy CGLIB pour une classe <tt class="literal">final</tt>
	    ou pour une classe contenant la moindre m&eacute;thode <tt class="literal">final</tt>.
        </p><p>
            Enfin, si votre objet persistant obtient une ressource &agrave; l'instanciation (par
	    example dans les initialiseurs ou dans le contructeur par d&eacute;faut), alors ces ressources
	    seront aussi obtenues par le proxy. La classe proxy est vraiment une sous classe de la classe
	    persistante.
        </p><p>
            Ces probl&egrave;mes sont tous dus aux limitations fondamentales du mod&egrave;le d'h&eacute;ritage unique de Java.
	    Si vous souhaitez &eacute;viter ces probl&egrave;mes, vos classes persistantes doivent chacune impl&eacute;menter
	    une interface qui d&eacute;clare ses m&eacute;thodes m&eacute;tier. Vous devriez alors sp&eacute;cifier ces interfaces
	    dans le fichier de mapping :
        </p><pre class="programlisting">&lt;class name="eg.Cat" proxy="eg.ICat"&gt;
    ......
    &lt;subclass name="eg.DomesticCat" proxy="eg.IDomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
            o&ugrave; <tt class="literal">Cat</tt> impl&eacute;mente l'interface <tt class="literal">ICat</tt> et <tt class="literal">DomesticCat</tt> 
	    impl&eacute;mente l'interface <tt class="literal">IDomesticCat</tt>. Ainsi, des proxys pour les instances de 
	    <tt class="literal">Cat</tt> et <tt class="literal">DomesticCat</tt> pourraient &ecirc;tre retourn&eacute;es par <tt class="literal">load()</tt> 
	    ou <tt class="literal">iterate()</tt> (Notez que <tt class="literal">find()</tt> ne retourne pas de proxy).
        </p><pre class="programlisting">ICat cat = (ICat) session.load(Cat.class, catid);
Iterator iter = session.iterate("from cat in class eg.Cat where cat.name='fritz'");
ICat fritz = (ICat) iter.next();</pre><p>
            Les relations sont aussi initialis&eacute;es tardivement. Ceci signifie que vous 
        devez d&eacute;clarer chaque propri&eacute;t&eacute; comme &eacute;tant de type <tt class="literal">ICat</tt>, 
        et non <tt class="literal">Cat</tt>.
        </p><p>
            Certaines op&eacute;rations ne n&eacute;cessitent pas l'initialisation du proxy
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">equals()</tt>, si la classe persistante ne surcharge pas
                    <tt class="literal">equals()</tt>
                </p></li><li><p>
                    <tt class="literal">hashCode()</tt>, si la classe persistante ne surcharge pas
                    <tt class="literal">hashCode()</tt>
                </p></li><li><p>
                    Le getter de l'identifiant
                </p></li></ul></div><p>
            Hibernate d&eacute;tectera les classes qui surchargent <tt class="literal">equals()</tt> ou
            <tt class="literal">hashCode()</tt>.
        </p><p>
            Les exceptions qui surviennent &agrave; l'initialisation d'un proxy sont encapsul&eacute;es 
	    dans une <tt class="literal">LazyInitializationException</tt>.
        </p><p>
            Parfois, nous devons nous assurer qu'un proxy ou une collection est initialis&eacute;e avant de 
	    fermer la <tt class="literal">Session</tt>. Bien s&ucirc;r, nous pouvons toujours forcer l'initialisation
	    en appelant par exemple <tt class="literal">cat.getSex()</tt> ou <tt class="literal">cat.getKittens().size()</tt>.
            Mais ceci n'est pas tr&egrave;s lisible pour les personnes parcourant le code et n'est pas tr&egrave;s g&eacute;n&eacute;rique.
	    Les m&eacute;thodes statiques <tt class="literal">Hibernate.initialize()</tt> et <tt class="literal">Hibernate.isInitialized()</tt>
        fournissent &agrave; l'application un moyen de travailler avec des proxys ou des collections initialis&eacute;s.
	    <tt class="literal">Hibernate.initialize(cat)</tt> forcera l'initialisation d'un proxy de <tt class="literal">cat</tt>, 
	    si tant est que sa <tt class="literal">Session</tt> est ouverte. <tt class="literal">Hibernate.initialize( cat.getKittens() )</tt> 
	    a le m&ecirc;me effet sur la collection kittens. 
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-batchfetching"></a>14.3.&nbsp;Utiliser le batch fetching (chargement par batch)</h2></div></div><div></div></div><p>
            Pour am&eacute;liorer les performances, Hibernate peut utiliser le batch fetching 
        ce qui veut dire qu'Hibernate peut charger plusieurs proxys non initialis&eacute;s en une seule 
        requ&ecirc;te lorsque l'on acc&egrave;de &agrave; l'un de ces proxys. Le batch fetching est une optimisation 
        intimement li&eacute;e &agrave; la strat&eacute;gie de chargement tardif. Il y a deux moyens d'activer le batch 
        fetching : au niveau de la classe et au niveau de la collection.
        </p><p>
            Le batch fetching pour les classes/entit&eacute;s est plus simple &agrave; comprendre. Imaginez que vous ayez la
	    situation suivante &agrave; l'ex&eacute;cution : vous avez 25 instances de <tt class="literal">Cat</tt> 
        charg&eacute;es dans une <tt class="literal">Session</tt>, chaque <tt class="literal">Cat</tt> a une r&eacute;f&eacute;rence 
        &agrave; son <tt class="literal">owner</tt>, une <tt class="literal">Person</tt>.
            La classe <tt class="literal">Person</tt> est mapp&eacute;e avec un proxy, <tt class="literal">lazy="true"</tt>. 
        Si vous it&eacute;rez sur tous les cats et appelez <tt class="literal">getOwner()</tt> sur chacun d'eux, 
        Hibernate ex&eacute;cutera par d&eacute;faut 25 <tt class="literal">SELECT</tt>, pour charger les owners
        (initialiser le proxy). Vous pouvez param&eacute;trer ce comportement en sp&eacute;cifiant une 
        <tt class="literal">batch-size</tt> (taille de batch) dans le mapping de <tt class="literal">Person</tt> :
        </p><pre class="programlisting">&lt;class name="Person" lazy="true" batch-size="10"&gt;...&lt;/class&gt;</pre><p>
            Hibernate ex&eacute;cutera d&eacute;sormais trois requ&ecirc;tes, en chargeant respectivement 10, 
        10, et 5 entit&eacute;s. Vous pouvez voir que le batch fetching est une optimisation aveugle
        dans le mesure o&ugrave; elle d&eacute;pend du nombre de proxys non initialis&eacute;s dans une
        <tt class="literal">Session</tt> particuli&egrave;re.
        </p><p>
            Vous pouvez aussi activer le batch fetching pour les collections. Par exemple, 
        si chaque <tt class="literal">Person</tt> a une collection charg&eacute;e tardivement de 
        <tt class="literal">Cat</tt>s, et que 10 persons sont actuellement charg&eacute;es dans la 
        <tt class="literal">Session</tt>, it&eacute;rer sur toutes les persons g&eacute;n&eacute;rera 10 <tt class="literal">SELECT</tt>s,
        un pour chaque appel de <tt class="literal">getCats()</tt>. Si vous activez le batch fetching pour la
	    collection <tt class="literal">cats</tt> dans le mapping de <tt class="literal">Person</tt>, Hibernate pourra
        pr&eacute;charger les collections :
        </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;set name="cats" lazy="true" batch-size="3"&gt;
        ...
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
            Avec une taille de batch (<tt class="literal">batch-size</tt>) de 3, Hibernate chargera 
        respectivement 3, 3, 3, et 1 collections en 4 <tt class="literal">SELECT</tt>s. 
        Encore une fois, la valeur de l'attribut d&eacute;pend du nombre de collections
	    non initialis&eacute;es dans une <tt class="literal">Session</tt> particuli&egrave;re.
        </p><p>
            Le batch fetching de collections est particuli&egrave;rement utile si vous avez des 
        arborescenses r&eacute;cursives d'&eacute;l&eacute;ments (typiquement, le sch&eacute;ma facture de 
        mat&eacute;riels).
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-cache"></a>14.4.&nbsp;Le cache de second niveau</h2></div></div><div></div></div><p>
            Une <tt class="literal">Session</tt> Hibernate est un cache de niveau transactionnel 
        des donn&eacute;es persistantes. Il est possible de configurer un cache de cluster ou de JVM 
        (de niveau <tt class="literal">SessionFactory</tt> pour &ecirc;tre exact) d&eacute;fini classe par classe 
        et collection par collection. Vous pouvez m&ecirc;me utiliser votr choix de cache
        en impl&eacute;mentant le pourvoyeur (provider) associ&eacute;.
	    Faites attention, les caches ne sont jamais avertis des modifications faites 
        dans la base de donn&eacute;es par d'autres applications (ils peuvent cependant &ecirc;tre 
        configur&eacute;s pour r&eacute;guli&egrave;rement expirer les donn&eacute;es en cache).
        </p><p>
            Par d&eacute;faut, Hibernate utilise EHCache comme cache de niveau JVM (le support 
        de JCS est d&eacute;sormais d&eacute;pr&eacute;ci&eacute; et sera enlev&eacute; des futures versions d'Hibernate).
        Vous pouvez choisir une autre impl&eacute;mentation en sp&eacute;cifiant le nom de la classe qui 
        impl&eacute;mente <tt class="literal">net.sf.hibernate.cache.CacheProvider</tt> en utilisant 
        la propri&eacute;t&eacute; <tt class="literal">hibernate.cache.provider_class</tt>.
        </p><div class="table"><a name="cacheproviders"></a><p class="title"><b>Tableau&nbsp;14.1.&nbsp;Fournisseur de cache</b></p><table summary="Fournisseur de cache" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Cache</th><th align="left">Classe pourvoyeuse</th><th align="left">Type</th><th align="left">Support en Cluster</th><th align="left">Cache de requ&ecirc;tes support&eacute;</th></tr></thead><tbody><tr><td align="left">Hashtable (ne pas utiliser en production)</td><td align="left"><tt class="literal">net.sf.hibernate.cache.HashtableCacheProvider</tt></td><td align="left">m&eacute;moire</td><td align="left">&nbsp;</td><td align="left">oui</td></tr><tr><td align="left">EHCache</td><td align="left"><tt class="literal">net.sf.hibernate.cache.EhCacheProvider</tt></td><td align="left">m&eacute;moire, disque</td><td align="left">&nbsp;</td><td align="left">oui</td></tr><tr><td align="left">OSCache</td><td align="left"><tt class="literal">net.sf.hibernate.cache.OSCacheProvider</tt></td><td align="left">m&eacute;moire, disque</td><td align="left">&nbsp;</td><td align="left">oui</td></tr><tr><td align="left">SwarmCache</td><td align="left"><tt class="literal">net.sf.hibernate.cache.SwarmCacheProvider</tt></td><td align="left">en cluster (multicast ip)</td><td align="left">oui (invalidation de cluster)</td><td align="left">&nbsp;</td></tr><tr><td align="left">JBoss TreeCache</td><td align="left"><tt class="literal">net.sf.hibernate.cache.TreeCacheProvider</tt></td><td align="left">en cluster (multicast ip), transactionnel</td><td align="left">oui (replication)</td><td align="left">oui (horloge sync. n&eacute;cessaire)</td></tr></tbody></table></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-mapping"></a>14.4.1.&nbsp;Mapping de Cache</h3></div></div><div></div></div><p>
                L'&eacute;l&eacute;ment <tt class="literal">&lt;cache&gt;</tt> d'une classe ou d'une collection &agrave;
		la forme suivante :
            </p><div class="programlistingco"><pre class="programlisting">&lt;cache 
    usage="transactional|read-write|nonstrict-read-write|read-only"  <span class="co">(1)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">usage</tt> sp&eacute;cifie la strat&eacute;gie de cache :
                            <tt class="literal">transactionel</tt>,
                            <tt class="literal">lecture-&eacute;criture</tt>,
                            <tt class="literal">lecture-&eacute;criture non stricte</tt> ou
                            <tt class="literal">lecture seule</tt>
                        </p></td></tr></table></div></div><p>
                Alternativement (voir pr&eacute;f&eacute;rentiellement), vous pouvez sp&eacute;cifier les &eacute;l&eacute;ments 
		<tt class="literal">&lt;class-cache&gt;</tt> et <tt class="literal">&lt;collection-cache&gt;</tt> 
		dans <tt class="literal">hibernate.cfg.xml</tt>.
            </p><p>
                L'attribut <tt class="literal">usage</tt> sp&eacute;cifie une <span class="emphasis"><em>strat&eacute;gie de concurrence d'acc&egrave;s au cache</em></span>.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-readonly"></a>14.4.2.&nbsp;Strategie : lecture seule</h3></div></div><div></div></div><p>
                Si votre application a besoin de lire mais ne modifie jamais les instances d'une classe,
		un cache <tt class="literal">read-only</tt> peut &ecirc;tre utilis&eacute;. C'est la strat&eacute;gie la plus simple
		et la plus performante. Elle est m&ecirc;me parfaitement s&ucirc;re dans un cluster.
            </p><pre class="programlisting">&lt;class name="eg.Immutable" mutable="false"&gt;
    &lt;cache usage="read-only"/&gt;
    ....
&lt;/class&gt;</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-readwrite"></a>14.4.3.&nbsp;Strat&eacute;gie : lecture/&eacute;criture</h3></div></div><div></div></div><p>
                Si l'application a besoin de mettre &agrave; jour des donn&eacute;es, un cache <tt class="literal">read-write</tt> peut
		&ecirc;tre appropri&eacute;. Cette strat&eacute;gie ne devrait jamais &ecirc;tre utilis&eacute;e si votre application
        n&eacute;cessite un niveau d'isolation transactionnelle s&eacute;rialisable. Si le cache est utilis&eacute; 
        dans un environnement JTA, vous devez sp&eacute;cifier 
        <tt class="literal">hibernate.transaction.manager_lookup_class</tt>, fournissant une strat&eacute;gie pour obtenir
		le <tt class="literal">TransactionManager</tt> JTA. Dans d'autres environnements, vous devriez vous assurer
		que la transation est termin&eacute;e &agrave; l'appel de <tt class="literal">Session.close()</tt> 
        ou <tt class="literal">Session.disconnect()</tt>.	Si vous souhaitez utiliser cette strat&eacute;gie 
        dans un cluster, vous devriez vous assurer que l'impl&eacute;mentation de cache utilis&eacute;e supporte 
        le v&eacute;rrouillage. Ce que ne font <span class="emphasis"><em>pas</em></span> les pourvoyeurs caches fournis.
            </p><pre class="programlisting">&lt;class name="eg.Cat" .... &gt;
    &lt;cache usage="read-write"/&gt;
    ....
    &lt;set name="kittens" ... &gt;
        &lt;cache usage="read-write"/&gt;
        ....
    &lt;/set&gt;
&lt;/class&gt;</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-nonstrict"></a>14.4.4.&nbsp;Strat&eacute;gie : lecture/&eacute;criture non stricte</h3></div></div><div></div></div><p>
                Si l'application besoin de mettre &agrave; jour les donn&eacute;es de mani&egrave;re occasionnelle 
        (qu'il est tr&egrave;s peu probable que deux transactions essaient de mettre &agrave; jour le m&ecirc;me 
        &eacute;l&eacute;ment simultan&eacute;ment) et qu'une isolation transactionnelle stricte n'est pas n&eacute;cessaire, 
        un cache <tt class="literal">nonstrict-read-write</tt> peut &ecirc;tre appropri&eacute;. Si le cache est 
        utilis&eacute; dans un environnement JTA, vous devez sp&eacute;cifier
        <tt class="literal">hibernate.transaction.manager_lookup_class</tt>. Dans d'autres 
        environnements, vous devriez vous assurer que la transation est termin&eacute;e &agrave; l'appel 
        de <tt class="literal">Session.close()</tt> ou <tt class="literal">Session.disconnect()</tt> 
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-transactional"></a>14.4.5.&nbsp;Strat&eacute;gie : transactionelle</h3></div></div><div></div></div><p>
                La strat&eacute;gie de cache <tt class="literal">transactional</tt> supporte un cache 
        compl&egrave;tement transactionnel	comme, par exemple, JBoss TreeCache. Un tel cache ne 
        peut &ecirc;tre utilis&eacute; que dans un environnement JTA	et vous devez sp&eacute;cifier 
        <tt class="literal">hibernate.transaction.manager_lookup_class</tt>. 
            </p></div><p>
            Aucun des caches livr&eacute;s ne supporte toutes les strat&eacute;gies de concurrence. Le tableau suivant montre
	    quels caches sont compatibles avec quelles strat&eacute;gies de concurrence.	    
        </p><div class="table"><a name="d0e9114"></a><p class="title"><b>Tableau&nbsp;14.2.&nbsp;Strat&eacute;gie de concurrence du cache</b></p><table summary="Strat&eacute;gie de concurrence du cache" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Cache</th><th align="left">read-only (lecture seule)</th><th align="left">nonstrict-read-write (lecture-&eacute;criture non stricte)</th><th align="left">read-write (lecture-&eacute;riture)</th><th align="left">transactional (transactionnel)</th></tr></thead><tbody><tr><td align="left">Hashtable (ne pas utilser en production)</td><td align="left">oui</td><td align="left">oui</td><td align="left">oui</td><td align="left">&nbsp;</td></tr><tr><td align="left">EHCache</td><td align="left">oui</td><td align="left">oui</td><td align="left">oui</td><td align="left">&nbsp;</td></tr><tr><td align="left">OSCache</td><td align="left">oui</td><td align="left">oui</td><td align="left">oui</td><td align="left">&nbsp;</td></tr><tr><td align="left">SwarmCache</td><td align="left">oui</td><td align="left">oui</td><td align="left">&nbsp;</td><td align="left">&nbsp;</td></tr><tr><td align="left">JBoss TreeCache</td><td align="left">oui</td><td align="left">&nbsp;</td><td align="left">&nbsp;</td><td align="left">oui</td></tr></tbody></table></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-sessioncache"></a>14.5.&nbsp;G&eacute;rer le cache de la <tt class="literal">Session</tt> </h2></div></div><div></div></div><p>
            A chaque fois que vous passez un objet &agrave; <tt class="literal">save()</tt>, <tt class="literal">update()</tt>
            ou <tt class="literal">saveOrUpdate()</tt> ou chaque fois que r&eacute;cup&eacute;rez un objet via 
	    <tt class="literal">load()</tt>, <tt class="literal">find()</tt>, <tt class="literal">iterate()</tt>,
        ou <tt class="literal">filter()</tt>, cet objet est ajout&eacute; au cache interne de la <tt class="literal">Session</tt>. 
	    Quand <tt class="literal">flush()</tt> est appel&eacute;, l'&eacute;tat de cet objet est synchronis&eacute; avec la
	    base de donn&eacute;es. Si vous ne souhaitez pas que cette synchronisation se fasse ou si vous &ecirc;tes
	    en train de travailler avec un grand nombre d'objets et avez besoin de g&eacute;rer
	    la m&eacute;moire de mani&egrave;re efficace, la m&eacute;thode <tt class="literal">evict()</tt> peut &ecirc;tre utilis&eacute;e
	    pour enlever l'objet et ses collections du cache.
        </p><pre class="programlisting">Iterator cats = sess.iterate("from eg.Cat as cat"); //un grand result set
while ( cats.hasNext() ) {
    Cat cat = (Cat) iter.next();
    doSomethingWithACat(cat);
    sess.evict(cat);
}</pre><p>
				Hibernate enl&egrave;vera automatiquement toutes les entit&eacute;s associ&eacute;es si l'association est mapp&eacute;e
				avec <tt class="literal">cascade="all"</tt> ou <tt class="literal">cascade="all-delete-orphan"</tt>.
			</p><p>
            La <tt class="literal">Session</tt> dispose aussi de la m&eacute;thode <tt class="literal">contains()</tt> pour d&eacute;terminer
	    si une instance appartient au cache de la session.
        </p><p>
            Pour retirer tous les objets du cache session, appelez <tt class="literal">Session.clear()</tt>
        </p><p>
            Pour le cache de second niveau, il existe des m&eacute;thodes d&eacute;finies dans 
        <tt class="literal">SessionFactory</tt> pour retirer des instances du cache, 
        la classe enti&egrave;re, une instance de collection ou
	    le r&ocirc;le entier d'une collection.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-querycache"></a>14.6.&nbsp;Le cache de requ&ecirc;tes</h2></div></div><div></div></div><p>
            Les r&eacute;sultats d'une requ&ecirc;te peuvent aussi &ecirc;tre plac&eacute;s en cache. Ceci n'est utile
	    que pour les requ&ecirc;tes qui sont ex&eacute;cut&eacute;es avec les m&ecirc;mes param&egrave;tres. Pour utiliser
	    le cache de requ&ecirc;tes, vous devez d'abord l'activer en mettant 
	    <tt class="literal">hibernate.cache.use_query_cache=true</tt>. Ceci active la cr&eacute;ation de
	    deux r&eacute;gions de cache, une contenant les r&eacute;sultats des requ&ecirc;tes en cache 
	    (<tt class="literal">net.sf.hibernate.cache.QueryCache</tt>), l'autre contenant les modifications les
	    plus r&eacute;centes des tables interrog&eacute;es (<tt class="literal">net.sf.hibernate.cache.UpdateTimestampsCache</tt>). 
	    Notez que le cache de requ&ecirc;te ne met pas en cache l'&eacute;tat de chaque entit&eacute; du r&eacute;sultat,
	    il met seuleument en cache les valeurs des identifiants et les r&eacute;sultats de type valeur.
	    Le cache requ&ecirc;te est donc g&eacute;n&eacute;ralement utilis&eacute; en association avec le cache de second
	    niveau.
        </p><p>
            La plupart des requ&ecirc;tes ne retirent pas de b&eacute;n&eacute;fice pas du cache, 
        donc par d&eacute;faut les requ&ecirc;tes ne sont pas mises en cache. Pour activer le cache, 
        appelez <tt class="literal">Query.setCacheable(true)</tt>. 
	    Cet appel permet de v&eacute;rifier si les r&eacute;sultats sont en cache ou non, voire
        d'ajouter ces r&eacute;sultats si la requ&ecirc;te est ex&eacute;cut&eacute;e.
        </p><p>
            Si vous avez besoin de contr&ocirc;ler finement les d&eacute;lais d'expiration du cache, vous
	    pouvez sp&eacute;cifier une r&eacute;gion de cache nomm&eacute;e pour une requ&ecirc;te particuli&egrave;re en
	    appelant <tt class="literal">Query.setCacheRegion()</tt>.
        </p><pre class="programlisting">List blogs = sess.createQuery("from Blog blog where blog.blogger = :blogger")
    .setEntity("blogger", blogger)
    .setMaxResults(15)
    .setCacheable(true)
    .setCacheRegion("frontpages")
    .list();</pre><p>
            Si une requ&ecirc;te doit forcer le rafra&icirc;chissement de sa r&eacute;gion de cache, vous pouvez
            forcer <tt class="literal">Query.setForceCacheRefresh()</tt> &agrave; <tt class="literal">true</tt>.
            C'est particuli&egrave;rement utile dans les cas ou la base de donn&eacute;es peut &ecirc;tre mise &agrave; jour
            par un autre processus (autre qu'Hibernate) et permet &agrave; l'application de rafraichir
            de mani&egrave;re s&eacute;lective les r&eacute;gions de cache de requ&ecirc;te en fonction de sa connaissance
            des &eacute;v&egrave;nements. C'est une alternative &agrave; l'&eacute;viction d'une r&eacute;gion de cache de
            requ&ecirc;te. Si vous avez besoin d'un contr&ocirc;le fin du rafra&icirc;chissement pour plusieurs
            requ&ecirc;tes, utlisez cette fonction plut&ocirc;t qu'une nouvelle r&eacute;gion pour chaque 
            requ&ecirc;te.
        </p></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="toolsetguide"></a>Chapitre&nbsp;15.&nbsp;Guide des outils</h2></div></div><div></div></div><p>
        Des outils en ligne de commande permettre de g&eacute;rer de cycles de d&eacute;veloppement complet
    de projets utilisant Hibernate. Ces outils font partie du projet Hibernate lui-m&ecirc;me. Ils
    peuvent &ecirc;tre utilis&eacute;s conjointement avec d'autres outils qui supportent nativement
	Hibernate : XDoclet, Middlegen and AndroMDA.
    </p><p>
        La distribution principale d'Hibernate est livr&eacute;e avec l'outil le plus important
    (il peut m&ecirc;me &ecirc;tre utilis&eacute; "&agrave; l'int&eacute;rieur" d'Hibernate, &agrave; la vol&eacute;e) :
    </p><div class="itemizedlist"><ul type="disc"><li><p>
            G&eacute;n&eacute;ration du sch&eacute;ma DDL depuis un fichier de mapping
            (aussi appel&eacute;  <tt class="literal">SchemaExport</tt>, <tt class="literal">hbm2ddl</tt>)
        </p></li></ul></div><p>
        D'autres outils directement fournis par le projet Hibernate sont distribu&eacute;s dans un package
	s&eacute;par&eacute;, <span class="emphasis"><em>Hibernate Extensions</em></span>. Ce package inclus des outils pour les
	t&acirc;ches suivantes :
    </p><div class="itemizedlist"><ul type="disc"><li><p>
            G&eacute;n&eacute;ration de source Java &agrave; partir d'un fichier de mapping (<tt class="literal">CodeGenerator</tt>,
            <tt class="literal">hbm2java</tt>)
        </p></li><li><p>
            G&eacute;n&eacute;ration de fichiers de mapping &agrave; partir des classes java compil&eacute;es
	    ou &agrave; partir des sources Java marqu&eacute;es avec XDoclet (<tt class="literal">MapGenerator</tt>,
            <tt class="literal">class2hbm</tt>)
        </p></li></ul></div><p>
        Il existe un autre outil distribu&eacute; avec les extensions Hibernate : <tt class="literal">ddl2hbm</tt>.
        Il est consid&eacute;r&eacute; comme obsol&egrave;te et ne sera plus maintenu, Middlegen faisant un meilleur
        travail pour cette t&acirc;che.
    </p><p>
        D'autres outils tiers fournissent un support Hibernate :
    </p><div class="itemizedlist"><ul type="disc"><li><p>
            Middlegen (g&eacute;n&eacute;ration du fichier de mapping &agrave; partir d'un sch&eacute;ma de base 
            de donn&eacute;es existant)
        </p></li><li><p>
            AndroMDA (g&eacute;n&eacute;ration du code des
	    classes persistantes &agrave; partir de diagrammes UML et de leur 
	    repr&eacute;sentation XML/XMI en utilisant une strat&eacute;gie MDA 
        - Model-Driven Architecture)
        </p></li></ul></div><p>
        Ces outils tiers ne sont pas document&eacute;s dans ce guide. R&eacute;f&eacute;rez-vous au site 
	Hibernate pour des informations &agrave; jour (une photo du site est inclus dans la
    distribution principale d'Hibernate).
    </p><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="toolsetguide-s1"></a>15.1.&nbsp;G&eacute;n&eacute;ration de Sch&eacute;ma</h2></div></div><div></div></div><p>
            Le DDL peut &ecirc;tre g&eacute;n&eacute;r&eacute; &agrave; partir de vos fichiers de mapping par une ligne de commande.
	    Un fichier .bat est localis&eacute; dans le r&eacute;pertoire <tt class="literal">hibernate-x.x.x/bin</tt> 
	    de la distribution principale.
        </p><p>
            Le sch&eacute;ma g&eacute;n&eacute;r&eacute; inclut les contraintes d'int&eacute;grit&eacute; du r&eacute;f&eacute;rentiel (cl&eacute;s primaires et &eacute;trang&egrave;res)
	    pour les tables d'entit&eacute;s et de collections. Les tables et les s&eacute;quences sont aussi cr&eacute;&eacute;es
	    pour les g&eacute;n&eacute;rateurs d'identifiants mapp&eacute;s.
        </p><p>
            Vous <span class="emphasis"><em>devez</em></span> sp&eacute;cifier un <tt class="literal">Dialecte</tt> SQL via la 
            propri&eacute;t&eacute; <tt class="literal">hibernate.dialect</tt> lorsque vous utilisez cet outil.
        </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-2"></a>15.1.1.&nbsp;Personnaliser le sch&eacute;ma</h3></div></div><div></div></div><p>
                Plusieurs &eacute;l&eacute;ments du mapping hibernate d&eacute;finissent un attribut optionnel 
         nomm&eacute; <tt class="literal">length</tt>. 
		Vous pouvez param&eacute;trer la longueur d'une colonne avec cet attribut (ou, pour les
		types de donn&eacute;es numeric/decimal, la pr&eacute;cision).
            </p><p>
                Certains &eacute;l&eacute;ments acceptent aussi un attribut <tt class="literal">not-null</tt> 
        (utilis&eacute; pour g&eacute;n&eacute;rer les contraintes de colonnes <tt class="literal">NOT NULL</tt>) et 
        un attribut <tt class="literal">unique</tt> (pour g&eacute;n&eacute;rer une	contrainte de colonne
        <tt class="literal">UNIQUE</tt>).
            </p><p>
                Quelques &eacute;l&eacute;ments acceptent un attribut <tt class="literal">index</tt> pour sp&eacute;cifier le nom
        d'un index pour cette colonne. Un attribut <tt class="literal">unique-key</tt> peut &ecirc;tre
		utilis&eacute; pour grouper des colonnes dans une seule contrainte de cl&eacute;. Actuellement,
		la valeur sp&eacute;cifi&eacute;e pour l'attribut <tt class="literal">unique-key</tt> n'est
        <span class="emphasis"><em>pas</em></span> utilis&eacute;e pour nommer la contrainte, mais uniquement pour
		grouper les colonnes dans le fichier de mapping.
            </p><p>
                Exemples :
            </p><pre class="programlisting">&lt;property name="foo" type="string" length="64" not-null="true"/&gt;

&lt;many-to-one name="bar" foreign-key="fk_foo_bar" not-null="true"/&gt;

&lt;element column="serial_number" type="long" not-null="true" unique="true"/&gt;</pre><p>
                Sinon, ces &eacute;l&eacute;ments acceptent aussi un &eacute;l&eacute;ments fils <tt class="literal">&lt;column&gt;</tt>. Ceci est
                particuli&egrave;rement utile pour des types multi-colonnes :
            </p><pre class="programlisting">&lt;property name="foo" type="string"&gt;
    &lt;column name="foo" length="64" not-null="true" sql-type="text"/&gt;
&lt;/property&gt;

&lt;property name="bar" type="my.customtypes.MultiColumnType"/&gt;
    &lt;column name="fee" not-null="true" index="bar_idx"/&gt;
    &lt;column name="fi" not-null="true" index="bar_idx"/&gt;
    &lt;column name="fo" not-null="true" index="bar_idx"/&gt;
&lt;/property&gt;</pre><p>
                L'attribut <tt class="literal">sql-type</tt> permet &agrave; l'utilisateur de surcharger 
        le mapping par d&eacute;faut d'un type Hibernate vers un type de donn&eacute;es SQL.
            </p><p>
                L'attribut <tt class="literal">check</tt> permet de sp&eacute;cifier une contrainte de v&eacute;rification.
            </p><pre class="programlisting">&lt;property name="foo" type="integer"&gt;
    &lt;column name="foo" check="foo &gt; 10"/&gt;
&lt;/property&gt;

&lt;class name="Foo" table="foos" check="bar &lt; 100.0"&gt;
    ...
    &lt;property name="bar" type="float"/&gt;
&lt;/class&gt;</pre><div class="table"><a name="schemattributes-summary"></a><p class="title"><b>Tableau&nbsp;15.1.&nbsp;R&eacute;sum&eacute;</b></p><table summary="R&eacute;sum&eacute;" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Attribut</th><th>Valeur</th><th>Interpr&eacute;tation</th></tr></thead><tbody><tr><td><tt class="literal">length</tt></td><td>num&eacute;rique</td><td>pr&eacute;cision d'une colonne (longueur ou d&eacute;cimal)</td></tr><tr><td><tt class="literal">not-null</tt></td><td><tt class="literal">true|false</tt></td><td>sp&eacute;cifie que la colonne doit &ecirc;tre non-nulle</td></tr><tr><td><tt class="literal">unique</tt></td><td><tt class="literal">true|false</tt></td><td>sp&eacute;cifie que la colonne doit avoir une contrainte d'unicit&eacute;</td></tr><tr><td><tt class="literal">index</tt></td><td><tt class="literal">index_name</tt></td><td>sp&eacute;cifie le nom d'un index (multi-colonnes)</td></tr><tr><td><tt class="literal">unique-key</tt></td><td><tt class="literal">unique_key_name</tt></td><td>sp&eacute;cifie le nom d'une contrainte d'unicit&eacute; multi-colonnes</td></tr><tr><td><tt class="literal">foreign-key</tt></td><td><tt class="literal">foreign_key_name</tt></td><td>
                                sp&eacute;cifie le nom d'une contrainte de cl&eacute; &eacute;trang&egrave;re g&eacute;n&eacute;r&eacute;e pour
				une association, utilisez-la avec les &eacute;l&eacute;ments de mapping 
				&lt;one-to-one&gt;, &lt;many-to-one&gt;, &lt;key&gt;, et &lt;many-to-many&gt; 
				Notez que les extr&ecirc;mit&eacute;s <tt class="literal">inverse="true"</tt> 
				se seront pas prises en compte par <tt class="literal">SchemaExport</tt>.
                            </td></tr><tr><td><tt class="literal">sql-type</tt></td><td><tt class="literal">column_type</tt></td><td>
                                surcharge le type par d&eacute;faut (attribut de 
                                l'&eacute;l&eacute;ment <tt class="literal">&lt;column&gt;</tt> uniquement)
                            </td></tr><tr><td><tt class="literal">check</tt></td><td>SQL expression</td><td>
                                cr&eacute;&eacute; une contrainte de v&eacute;rification sur la table ou la colonne
                            </td></tr></tbody></table></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-3"></a>15.1.2.&nbsp;Ex&eacute;cuter l'outil</h3></div></div><div></div></div><p>
                L'outil <tt class="literal">SchemaExport</tt> g&eacute;n&egrave;re un script DDL vers 
        la sortie standard et/ou ex&eacute;cute les ordres DDL.
            </p><p>
                <tt class="literal">java -cp </tt><span class="emphasis"><em>classpath_hibernate</em></span>
                <tt class="literal">net.sf.hibernate.tool.hbm2ddl.SchemaExport</tt> <span class="emphasis"><em>options fichiers_de_mapping</em></span>
            </p><div class="table"><a name="d0e9537"></a><p class="title"><b>Tableau&nbsp;15.2.&nbsp;<tt class="literal">SchemaExport</tt> Options de la ligne de commande</b></p><table summary="SchemaExport Options de la ligne de commande" border="1"><colgroup><col><col></colgroup><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">--quiet</tt></td><td>ne pas &eacute;crire le script vers la sortie standard</td></tr><tr><td><tt class="literal">--drop</tt></td><td>supprime seuleument les tables</td></tr><tr><td><tt class="literal">--text</tt></td><td>ne pas ex&eacute;cuter sur la base de donn&eacute;es</td></tr><tr><td><tt class="literal">--output=my_schema.ddl</tt></td><td>&eacute;crit le script ddl vers un fichier</td></tr><tr><td><tt class="literal">--config=hibernate.cfg.xml</tt></td><td>lit la configuration Hibernate &agrave; partir d'un fichier XML</td></tr><tr><td><tt class="literal">--properties=hibernate.properties</tt></td><td>lit les propri&eacute;t&eacute;s de la base de donn&eacute;es &agrave; partir d'un fichier</td></tr><tr><td><tt class="literal">--format</tt></td><td>formatte proprement le SQL g&eacute;n&eacute;r&eacute; dans le script</td></tr><tr><td><tt class="literal">--delimiter=x</tt></td><td>param&egrave;tre un d&eacute;limiteur de fin de ligne pour le script</td></tr></tbody></table></div><p>
                Vous pouvez m&ecirc;me int&eacute;grer <tt class="literal">SchemaExport</tt> dans votre application :
            </p><pre class="programlisting">Configuration cfg = ....;
new SchemaExport(cfg).create(false, true);</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-4"></a>15.1.3.&nbsp;Propri&eacute;t&eacute;s</h3></div></div><div></div></div><p>
                Les propri&eacute;t&eacute;s de la base de donn&eacute;es peuvent &ecirc;tre sp&eacute;cifi&eacute;es
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>comme propri&eacute;t&eacute;s syst&egrave;me avec <tt class="literal">-D</tt><span class="emphasis"><em>&lt;property&gt;</em></span></p></li><li><p>dans <tt class="literal">hibernate.properties</tt></p></li><li><p>dans un fichier de propri&eacute;t&eacute;s d&eacute;clar&eacute; avec <tt class="literal">--properties</tt></p></li></ul></div><p>
                Les propri&eacute;t&eacute;s n&eacute;cessaires sont :
            </p><div class="table"><a name="d0e9632"></a><p class="title"><b>Tableau&nbsp;15.3.&nbsp;Propri&eacute;t&eacute;s de connexion n&eacute;cessaires &agrave; SchemaExport</b></p><table summary="Propri&eacute;t&eacute;s de connexion n&eacute;cessaires &agrave; SchemaExport" border="1"><colgroup><col><col></colgroup><thead><tr><th>Nom de la propri&eacute;t&eacute;</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.connection.driver_class</tt></td><td>classe du driver JDBC</td></tr><tr><td><tt class="literal">hibernate.connection.url</tt></td><td>URL JDBC</td></tr><tr><td><tt class="literal">hibernate.connection.username</tt></td><td>utilisateur de la base de donn&eacute;es</td></tr><tr><td><tt class="literal">hibernate.connection.password</tt></td><td>mot de passe de l'utilisateur</td></tr><tr><td><tt class="literal">hibernate.dialect</tt></td><td>dialecte</td></tr></tbody></table></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-5"></a>15.1.4.&nbsp;Utiliser Ant</h3></div></div><div></div></div><p>
                Vous pouvez appeler <tt class="literal">SchemaExport</tt> depuis votre script 
                de construction Ant :
            </p><pre class="programlisting">&lt;target name="schemaexport"&gt;
    &lt;taskdef name="schemaexport"
        classname="net.sf.hibernate.tool.hbm2ddl.SchemaExportTask"
        classpathref="class.path"/&gt;
    
    &lt;schemaexport
        properties="hibernate.properties"
        quiet="no"
        text="no"
        drop="no"
        delimiter=";"
        output="schema-export.sql"&gt;
        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.hbm.xml"/&gt;
        &lt;/fileset&gt;
    &lt;/schemaexport&gt;
&lt;/target&gt;</pre><p>
                Si vous ne sp&eacute;cifiez ni <tt class="literal">properties</tt>, ni fichier dans 
                <tt class="literal">config</tt>, la t&acirc;che <tt class="literal">SchemaExportTask</tt>
                tentera d'utiliser les propri&eacute;t&eacute;s du projet Ant. Autrement dit,
                if vous ne voulez pas ou n'avez pas besoin d'un fichier externe de propri&eacute;t&eacute;s
                ou de configuration, vous pouvez mettre les propri&eacute;t&eacute;s de configuration
                <tt class="literal">hibernate.*</tt> dans votre build.xml ou votre build.properties.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-6"></a>15.1.5.&nbsp;Mises &agrave; jour incr&eacute;mentales du sch&eacute;ma</h3></div></div><div></div></div><p>
                L'outil <tt class="literal">SchemaUpdate</tt> mettra &agrave; jour un sch&eacute;ma existant 
            en effectuant les changement par "incr&eacute;ment".
                Notez que <tt class="literal">SchemaUpdate</tt> d&eacute;pends beaucoup de l'API JDBC 
                metadata, il ne fonctionnera donc pas avec tous les drivers JDBC.
            </p><p>
                <tt class="literal">java -cp </tt><span class="emphasis"><em>classpath_hibernate</em></span>
                <tt class="literal">net.sf.hibernate.tool.hbm2ddl.SchemaUpdate</tt> <span class="emphasis"><em>options fichiers_de_mapping</em></span>
            </p><div class="table"><a name="d0e9723"></a><p class="title"><b>Tableau&nbsp;15.4.&nbsp;<tt class="literal">SchemaUpdate</tt> Options de ligne de commande</b></p><table summary="SchemaUpdate Options de ligne de commande" border="1"><colgroup><col><col></colgroup><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">--quiet</tt></td><td>ne pas &eacute;crire vers la sortie standard</td></tr><tr><td><tt class="literal">--properties=hibernate.properties</tt></td><td>lire les propri&eacute;t&eacute;s de la base de donn&eacute;es &agrave; partir d'un fichier</td></tr></tbody></table></div><p>
                Vous pouvez int&eacute;grer <tt class="literal">SchemaUpdate</tt> dans votre application :
            </p><pre class="programlisting">Configuration cfg = ....;
new SchemaUpdate(cfg).execute(false);</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-7"></a>15.1.6.&nbsp;Utiliser Ant pour des mises &agrave; jour de sch&eacute;ma par incr&eacute;ment</h3></div></div><div></div></div><p>
                Vous pouvez appeler <tt class="literal">SchemaUpdate</tt> depuis le script Ant :
            </p><pre class="programlisting">&lt;target name="schemaupdate"&gt;
    &lt;taskdef name="schemaupdate"
        classname="net.sf.hibernate.tool.hbm2ddl.SchemaUpdateTask"
        classpathref="class.path"/&gt;
    
    &lt;schemaupdate
        properties="hibernate.properties"
        quiet="no"&gt;
        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.hbm.xml"/&gt;
        &lt;/fileset&gt;
    &lt;/schemaupdate&gt;
&lt;/target&gt;</pre></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="toolsetguide-s2"></a>15.2.&nbsp;G&eacute;n&eacute;ration de code</h2></div></div><div></div></div><p>
            Le g&eacute;n&eacute;rateur de code Hibernate peut &ecirc;tre utilis&eacute; pour g&eacute;n&eacute;rer les squelettes d'impl&eacute;mentation
	    des classes depuis un fichier de mapping. Cet outil est inclus dans la distribution des
        extensions Hibernate (t&eacute;l&eacute;chargement s&eacute;par&eacute;).
        </p><p>
            <tt class="literal">hbm2java</tt> analyse les fichiers de mapping et g&eacute;n&egrave;re les sources Java compl&egrave;tes.
	    Ainsi, en fournissant les fichiers <tt class="literal">.hbm</tt>, on n'a plus &agrave; &eacute;cire &agrave; la main
	    les fichiers Java.
        </p><p>
            <tt class="literal">java -cp</tt> <span class="emphasis"><em>classpath_hibernate</em></span>
            <tt class="literal">net.sf.hibernate.tool.hbm2java.CodeGenerator</tt> <span class="emphasis"><em> options
            fichiers_de_mapping</em></span>
        </p><div class="table"><a name="d0e9794"></a><p class="title"><b>Tableau&nbsp;15.5.&nbsp;Options de ligne de commande pour le g&eacute;n&eacute;rateur de code</b></p><table summary="Options de ligne de commande pour le g&eacute;n&eacute;rateur de code" border="1"><colgroup><col><col></colgroup><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">--output=</tt><span class="emphasis"><em>repertoire_de_sortie</em></span></td><td>r&eacute;pertoire racine pour le code g&eacute;n&eacute;r&eacute;</td></tr><tr><td><tt class="literal">--config=</tt><span class="emphasis"><em>fichier_de_configuration</em></span></td><td>fichier optionnel de configuration</td></tr></tbody></table></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s2-1"></a>15.2.1.&nbsp;Le fichier de configuration (optionnel)</h3></div></div><div></div></div><p>
                Le fichier de configuration fournit un moyen de sp&eacute;cifier de multiples "renderers" de code
		source et de d&eacute;clarer des <tt class="literal">&lt;meta&gt;</tt> attributs qui seront globaux. 
		Voir la section sur l'attribut <tt class="literal">&lt;meta&gt;</tt>.
            </p><pre class="programlisting">&lt;codegen&gt;
    &lt;meta attribute="implements"&gt;codegen.test.IAuditable&lt;/meta&gt;
    &lt;generate renderer="net.sf.hibernate.tool.hbm2java.BasicRenderer"/&gt;
    &lt;generate
        package="autofinders.only"
        suffix="Finder"
        renderer="net.sf.hibernate.tool.hbm2java.FinderRenderer"/&gt;
&lt;/codegen&gt;</pre><p>
                Ce fichier de configuration d&eacute;clare un m&eacute;ta attribut global "implements" et sp&eacute;cifie deux "renderers",
		celui par d&eacute;faut (BasicRenderer) et un renderer qui g&eacute;n&egrave;re des "finder" (requ&ecirc;teurs) (voir
		"G&eacute;n&eacute;ration basique de finder" ci-dessous).
            </p><p>
                Le second renderer est param&eacute;tr&eacute; avec un attribut package et suffixe.
            </p><p>
                L'attribut package sp&eacute;cifie que les fichiers sources g&eacute;n&eacute;r&eacute;s depuis ce renderer doivent &ecirc;tre
		plac&eacute;s dans ce package au lieu de celui sp&eacute;cifi&eacute; dans les fichiers <tt class="literal">.hbm</tt>.
            </p><p>
                L'attribut suffixe sp&eacute;cifie le suffixe pour les fichiers g&eacute;n&eacute;r&eacute;s. Ex: ici un fichier
		nomm&eacute; <tt class="literal">Foo.java</tt> g&eacute;n&egrave;rera un fichier <tt class="literal">FooFinder.java</tt>.
            </p><p>
              Il est aussi possible d'envoyer des param&egrave;tres arbitraires vers les renderers en ajoutant les
	      attributs <tt class="literal">&lt;param&gt;</tt> dans les &eacute;l&eacute;ments <tt class="literal">&lt;generate&gt;</tt>.
            </p><p>
              hbm2java supporte actuellement un tel param&egrave;tre appell&eacute;,
              <tt class="literal">generate-concrete-empty-classes</tt> qui
	      informe le BasicRenderer de ne g&eacute;n&eacute;rer que les classes
	      concr&ecirc;tes qui &eacute;tendent une classe de base pour toutes
	      vos classes. Le fichier config.xml suivant illustre cette
	      fonctionnalit&eacute;.
            </p><pre class="programlisting">
            &lt;codegen&gt;
              &lt;generate prefix="Base" renderer="net.sf.hibernate.tool.hbm2java.BasicRenderer"/&gt; 
              &lt;generate renderer="net.sf.hibernate.tool.hbm2java.BasicRenderer"&gt;
                &lt;param name="generate-concrete-empty-classes"&gt;true&lt;/param&gt;
                &lt;param name="baseclass-prefix"&gt;Base&lt;/param&gt;
              &lt;/generate&gt;
            &lt;/codegen&gt;</pre><p>
              Notez que ce config.xml configure deux renderers. 
	      Un qui g&eacute;n&egrave;re les classes Base, et un second qui
	      g&eacute;n&egrave;re les classes concr&ecirc;tes creuses.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s2-2"></a>15.2.2.&nbsp;L'attribut <tt class="literal">meta</tt></h3></div></div><div></div></div><p>
                L'attribut <tt class="literal">&lt;meta&gt;</tt> est un moyen simple d'annoter 
        les fichiers <tt class="literal">hbm.xml</tt> avec des informations utiles aux outils.
        Ces informations, bien que non n&eacute;cessaires au noyau d'Hibernate, se trouvent dont 
        &agrave; un endroit naturel.
            </p><p>
                Vous pouvez utiliser l'&eacute;l&eacute;ment <tt class="literal">&lt;meta&gt;</tt> 
        pour dire &agrave; <tt class="literal">hbm2java</tt> de 
		g&eacute;n&eacute;rer des setters "protected", d'impl&eacute;menter toujours un certain nombre 
		d'interfaces ou m&ecirc;me d'&eacute;tendre une classe de base particuli&egrave;re...
            </p><p>
                L'exemple suivant :
            </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;meta attribute="class-description"&gt;
        Javadoc de la classe Person
        @author Frodon
    &lt;/meta&gt;
    &lt;meta attribute="implements"&gt;IAuditable&lt;/meta&gt;
    &lt;id name="id" type="long"&gt;
        &lt;meta attribute="scope-set"&gt;protected&lt;/meta&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" type="string"&gt;
        &lt;meta attribute="field-description"&gt;Le nom de la personne&lt;/meta&gt;
    &lt;/property&gt;
&lt;/class&gt;</pre><p>
                produira le code suivant (le code a &eacute;t&eacute; raccourci pour une meilleure
         compr&eacute;hension). Notez la javadoc et les setters protected :
            </p><pre class="programlisting">// package par d&eacute;faut

import java.io.Serializable;
import org.apache.commons.lang.builder.EqualsBuilder;
import org.apache.commons.lang.builder.HashCodeBuilder;
import org.apache.commons.lang.builder.ToStringBuilder;

/** 
 *         Javadoc de la classe Person
 *         @author Frodon
 *     
 */
public class Person implements Serializable, IAuditable {

    /** identifier field */
    public Long id;

    /** nullable persistent field */
    public String name;

    /** full constructor */
    public Person(java.lang.String name) {
        this.name = name;
    }

    /** default constructor */
    public Person() {
    }

    public java.lang.Long getId() {
        return this.id;
    }

    protected void setId(java.lang.Long id) {
        this.id = id;
    }

    /** 
     * Le nom de la personne
     */
    public java.lang.String getName() {
        return this.name;
    }

    public void setName(java.lang.String name) {
        this.name = name;
    }

}</pre><div class="table"><a name="d0e9899"></a><p class="title"><b>Tableau&nbsp;15.6.&nbsp;Attributs meta support&eacute;s</b></p><table summary="Attributs meta support&eacute;s" border="1"><colgroup><col><col></colgroup><thead><tr><th>Attribut</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">class-description</tt></td><td>ins&eacute;r&eacute; dans les javadoc des classes</td></tr><tr><td><tt class="literal">field-description</tt></td><td>ins&eacute;r&eacute; dans les javadoc des champs/propri&eacute;t&eacute;s</td></tr><tr><td><tt class="literal">interface</tt></td><td>Si true une interface est g&eacute;n&eacute;r&eacute;e au lieu d'une classe</td></tr><tr><td><tt class="literal">implements</tt></td><td>interface que la classe doit impl&eacute;menter</td></tr><tr><td><tt class="literal">extends</tt></td><td>classe que la classe doit &eacute;tendre (ignor&eacute; pour les classes filles)</td></tr><tr><td><tt class="literal">generated-class</tt></td><td>surcharge le nom de la classe g&eacute;n&eacute;r&eacute;e</td></tr><tr><td><tt class="literal">scope-class</tt></td><td>visibilit&eacute; de la classe </td></tr><tr><td><tt class="literal">scope-set</tt></td><td>visibilit&eacute; des m&eacute;thodes setter</td></tr><tr><td><tt class="literal">scope-get</tt></td><td>visibilit&eacute; des m&eacute;thodes getter</td></tr><tr><td><tt class="literal">scope-field</tt></td><td>visibilit&eacute; du champs</td></tr><tr><td><tt class="literal">use-in-tostring</tt></td><td>inclus cette propri&eacute;t&eacute; dans <tt class="literal">toString()</tt></td></tr><tr><td><tt class="literal">implement-equals</tt></td><td>inclus <tt class="literal">equals()</tt> et <tt class="literal">hashCode()</tt> dans cette classe.</td></tr><tr><td><tt class="literal">use-in-equals</tt></td><td>inclus cette propri&eacute;t&eacute; dans <tt class="literal">equals()</tt> et <tt class="literal">hashCode()</tt>.</td></tr><tr><td><tt class="literal">bound</tt></td><td>ajoute le support de propertyChangeListener pour une propri&eacute;t&eacute;</td></tr><tr><td><tt class="literal">constrained</tt></td><td>support de bound + vetoChangeListener pour une propri&eacute;t&eacute;</td></tr><tr><td><tt class="literal">gen-property</tt></td><td>la propri&eacute;t&eacute; ne sera pas g&eacute;n&eacute;r&eacute;e si false (&agrave; utiliser avec pr&eacute;caution)</td></tr><tr><td><tt class="literal">property-type</tt></td><td>Surcharge le type par d&eacute;faut de la propri&eacute;t&eacute;. Utilisez le pour sp&eacute;cifier un type concret
			au lieu de Object</td></tr><tr><td><tt class="literal">class-code</tt></td><td>Code suppl&eacute;mentaire qui sera ins&eacute;r&eacute; en fin de classe</td></tr><tr><td><tt class="literal">extra-import</tt></td><td>Import suppl&eacute;mentaire qui sera ins&eacute;r&eacute; &agrave; la fin de tous les imports</td></tr><tr><td><tt class="literal">finder-method</tt></td><td>voir "G&eacute;n&eacute;rateur de requ&ecirc;teurs basiques"</td></tr><tr><td><tt class="literal">session-method</tt></td><td>voir "G&eacute;n&eacute;rateur de requ&ecirc;teurs basiques"</td></tr></tbody></table></div><p>
                Les attributs d&eacute;clar&eacute;s via l'&eacute;l&eacute;ment <tt class="literal">&lt;meta&gt;</tt> sont par d&eacute;faut
                "h&eacute;rit&eacute;s" dans les fichiers <tt class="literal">hbm.xml</tt>.
            </p><p>
                Ce qui veut dire ? Ceci veut dire que si, par exemple, vous voulez que toutes
		vos classes impl&eacute;mentent <tt class="literal">IAuditable</tt>, vous n'avez
		qu'&agrave; ajouter <tt class="literal">&lt;meta attribute="implements"&gt;IAuditable&lt;/meta&gt;</tt> au d&eacute;but
		du fichier <tt class="literal">hbm.xml</tt>, apr&egrave;s <tt class="literal">&lt;hibernate-mapping&gt;</tt>. 
		Toutes les classes d&eacute;finies dans les fichiers <tt class="literal">hbm.xml</tt> 
		impl&eacute;menteront <tt class="literal">IAuditable</tt> !
                (A l'exception des classes qui ont meta attribut "implements", car les m&eacute;ta tags sp&eacute;cifi&eacute;s
		localement surchargent/remplacent toujours les meta tags h&eacute;rit&eacute;s).
            </p><p>
                Note : Ceci s'applique &agrave; tous les <tt class="literal">&lt;meta&gt;</tt> attributs.
                Ceci peut aussi &ecirc;tre utilis&eacute;, par exemple, pour sp&eacute;cifier que tous les champs
		doivent &ecirc;tre d&eacute;clar&eacute;s protected, au lieu de private par d&eacute;faut. Pour cela,
		on ajoute <tt class="literal">&lt;meta attribute="scope-field"&gt;protected&lt;/meta&gt;</tt> 
		juste apr&egrave;s l'attribut <tt class="literal">&lt;class&gt;</tt> et tous les champs de cette classe
		seront protected.
            </p><p>
                Pour &eacute;viter d'h&eacute;riter un <tt class="literal">&lt;meta&gt;</tt> attribut, vous pouvez sp&eacute;cifier
                <tt class="literal">inherit="false"</tt> pour l'attribut, par exemple
                <tt class="literal">&lt;meta attribute="scope-class" inherit="false"&gt;public abstract&lt;/meta&gt;</tt>
                restreindra la visibilit&eacute; de classe &agrave; la classe courante, pas les classes filles.
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s2-3"></a>15.2.3.&nbsp;G&eacute;n&eacute;rateur de Requ&ecirc;teur Basique (Basic Finder)</h3></div></div><div></div></div><p>
                Il est d&eacute;sormais possible de laisser <tt class="literal">hbm2java</tt> g&eacute;n&egrave;rer
        des requ&ecirc;teur (finders) basiques pour les propri&eacute;t&eacute;s mapp&eacute;es par Hibernate. 
        Ceci n&eacute;cessite deux choses dans les fichiers <tt class="literal">hbm.xml</tt>.                
            </p><p>
                La premi&egrave;re est une indication des champs pour lesquels les finders 
        doivent &ecirc;tre g&eacute;n&eacute;r&eacute;s. Vous indiquez cela &agrave; l'aide d'un &eacute;l&eacute;ment meta au sein
        de l'&eacute;l&eacute;ment property :
            </p><pre class="programlisting">&lt;property name="name" column="name" type="string"&gt;
     &lt;meta attribute="finder-method"&gt;findByName&lt;/meta&gt;
&lt;/property&gt;</pre><p>
                Le texte inclus dans l'&eacute;l&eacute;ment donnera le nom de la m&eacute;thode finder.
            </p><p>
                La seconde est de cr&eacute;er un fichier de configuration pour hbm2java en y 
                ajoutant le renderer ad&eacute;quat :
            </p><pre class="programlisting">&lt;codegen&gt;
    &lt;generate renderer="net.sf.hibernate.tool.hbm2java.BasicRenderer"/&gt;
    &lt;generate suffix="Finder" renderer="net.sf.hibernate.tool.hbm2java.FinderRenderer"/&gt;
&lt;/codegen&gt;</pre><p>
                 Et utiliser ensuite le param&egrave;tre <tt class="literal">hbm2java --config=xxx.xml</tt> o&ugrave;
                 <tt class="literal">xxx.xml</tt> est le fichier de configuration que vous venez de cr&eacute;er.
            </p><p>
                 Un param&egrave;tre optionnel est un meta attribut au niveau de la classe de la forme :
            </p><pre class="programlisting">&lt;meta attribute="session-method"&gt;
    com.whatever.SessionTable.getSessionTable().getSession();
&lt;/meta&gt;</pre><p>
                 Qui repr&eacute;sente le moyen d'obtenir des sessions si vous utilisez le pattern
                 <span class="emphasis"><em>Thread Local Session</em></span> (document&eacute; dans la zone Design Patterns
                 du site web Hibernate).
            </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s2-4"></a>15.2.4.&nbsp;Renderer/G&eacute;n&eacute;rateur bas&eacute;s sur Velocity</h3></div></div><div></div></div><p> Il est d&eacute;sormais possible d'utiliser velocity comme m&eacute;canisme de
      rendering alternatif. Le fichier config.xml suivant montre comment configurer
      hbm2java pour utiliser ce renderer velocity.
      </p><pre class="programlisting">
    &lt;codegen&gt;
     &lt;generate renderer="net.sf.hibernate.tool.hbm2java.VelocityRenderer"&gt;
      &lt;param name="template"&gt;pojo.vm&lt;/param&gt;
     &lt;/generate&gt;
    &lt;/codegen&gt;</pre><p>
        Le param&egrave;tre nomm&eacute; <tt class="literal">template</tt> est un chemin de ressource vers le fichier de macro velocity que
	vous souhaitez utiliser. Ce fichier doit &ecirc;tre disponible dans le classpath utilis&eacute; par hbm2java. N'oubliez donc pas
	d'ajouter le r&eacute;pertoire o&ugrave; se trouve pojo.vm &agrave; votre t&acirc;che ant ou script shell (le r&eacute;pertoire par d&eacute;faut est
	<tt class="literal">./tools/src/velocity</tt>).
      </p><p>
        Soyez conscients que le <tt class="literal">pojo.vm</tt> actuel ne g&eacute;n&egrave;re que les parties basiques des java beans.
	Il n'est pas aussi complet et riche que le renderer par d&eacute;faut - il lui manque notamment le support
	de beaucoup de <tt class="literal">meta</tt> tags.
      </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="toolsetguide-s3"></a>15.3.&nbsp;G&eacute;n&eacute;ration des fichier de mapping</h2></div></div><div></div></div><p>
            Un squelette de fichier de mapping peut &ecirc;tre g&eacute;n&eacute;r&eacute; depuis les classes persistantes
	    compil&eacute;es en utilisant l'outil en ligne de commande appel&eacute; <tt class="literal">MapGenerator</tt>. 
	    Cet outil fait partie de la distribution des extensions Hibernate.
        </p><p>
            Le g&eacute;n&eacute;rateur de fichier de mapping fournit un m&eacute;canisme qui produit les 
	    mappings &agrave; partir des classes compil&eacute;es. Il utilise la r&eacute;flexion java pour trouver
	    les <span class="emphasis"><em>propri&eacute;t&eacute;s</em></span> et l'heuristique pour trouver un mapping
	    appropri&eacute; pour le type de la propri&eacute;t&eacute;. Le fichier g&eacute;n&eacute;r&eacute; n'est qu'un point de d&eacute;part. 
	    Il n'y a aucun moyen de produire un mapping Hibernate complet sans informations
	    suppl&eacute;mentaires de l'utlisateur. Cependant, l'outil g&eacute;n&egrave;re plusieurs des parties
	    r&eacute;p&eacute;titives &agrave; &eacute;crire dans les fichiers de mapping.
        </p><p>
            Les classes sont ajout&eacute;es une par une. L'outil n'acceptera que les classes
	    qu'il consid&egrave;re comme <span class="emphasis"><em>persistable par Hibernate</em></span>.
        </p><p>
            Pour &ecirc;tre <span class="emphasis"><em>persistable par Hibernate</em></span> une classe
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>ne doit pas &ecirc;tre de type primitif</p></li><li><p>ne doit pas &ecirc;tre un tableau</p></li><li><p>ne doit pas &ecirc;tre une interface</p></li><li><p>ne doit pas &ecirc;tre une classe imbriqu&eacute;e</p></li><li><p>doit avoir un constructeur par d&eacute;faut (sans argument)</p></li></ul></div><p>
            Notez que les interfaces et classes imbriqu&eacute;es sont persistables par Hibernate, mais
	    l'utilisateur ne le d&eacute;sirera g&eacute;n&eacute;ralement pas.
        </p><p>
            <tt class="literal">MapGenerator</tt> remontera la hi&eacute;rarchie de classe pour essayer d'ajouter
	    autant de superclasses (persistables par Hibernate) que possible &agrave; la m&ecirc;me table dans la base 
        de donn&eacute;es.
	    La "recherche" stoppe d&egrave;s qu'une propri&eacute;t&eacute;, ayant son nom figurant dans la liste des
            <span class="emphasis"><em>noms d'UID candidats</em></span> est trouv&eacute;e.
        </p><p>
            La liste par d&eacute;faut des noms de propri&eacute;t&eacute; candidats pour UID est: <tt class="literal">uid</tt>, <tt class="literal">UID</tt>,
            <tt class="literal">id</tt>, <tt class="literal">ID</tt>, <tt class="literal">key</tt>, <tt class="literal">KEY</tt>,
            <tt class="literal">pk</tt>, <tt class="literal">PK</tt>.
        </p><p>
            Les propri&eacute;t&eacute;s sont trouv&eacute;es quand la classe poss&egrave;de un getter et un setter
        associ&eacute;, quand le type du setter ayant un argument unique est le m&ecirc;me que le type 
        retourn&eacute; par le getter sans argument, et que le setter retourne <tt class="literal">void</tt>. 
        De plus le nom du setter doit commencer par <tt class="literal">set</tt>, le nom du getter par 
        <tt class="literal">get</tt> (ou <tt class="literal">is</tt> si le type de la propri&eacute;t&eacute; est boolean). 
        Le reste du nommage doit alors correspondre au nom de la propri&eacute;t&eacute; (&agrave; l'exception de l'initiale
        qui passe de minuscule &agrave; majuscule).
        </p><p>
            Les r&egrave;gles de d&eacute;termination du type de base de donn&eacute;es de chaque propri&eacute;t&eacute; sont :
        </p><div class="orderedlist"><ol type="1" compact><li><p>
                    Si le type java est <tt class="literal">Hibernate.basic()</tt>, alors la propri&eacute;t&eacute; est une
		    simple colonne de ce type.
                </p></li><li><p>
                    Pour les types utilisateurs <tt class="literal">hibernate.type.Type</tt> et <tt class="literal">PersistentEnum</tt>
                    une simple colonne est aussi utilis&eacute;e.
                </p></li><li><p>
                    Si le type est un tableau, alors un tableau Hibernate est utilis&eacute;, et <tt class="literal">MapGenerator</tt>
                    essaie d'utiliser la r&eacute;flexion sur un &eacute;l&eacute;ment du tableau.
                </p></li><li><p>
                    Si le type est <tt class="literal">java.util.List</tt>, <tt class="literal">java.util.Map</tt>, ou
                    <tt class="literal">java.util.Set</tt>, alors les types Hibernate correspondant sont
		    utilis&eacute;s, <tt class="literal">MapGenerator</tt> ne peut aller plus loin dans la d&eacute;couverte de 
            ces types.
                </p></li><li><p>
                    Si le type est une autre classe, <tt class="literal">MapGenerator</tt> repousse la d&eacute;cision
		    de sa repr&eacute;sentation en base de donn&eacute;es quand toutes les classes auront &eacute;t&eacute; trait&eacute;es. A ce moment,
		    si la classe a &eacute;t&eacute; trouv&eacute;e via la recherche des superclasses d&eacute;crites plus haut, 
		    la propri&eacute;t&eacute; est une association <tt class="literal">plusieurs-vers-un</tt>. Si la classe a des
		    propri&eacute;t&eacute;s, alors c'est un <tt class="literal">composant</tt>. Dans les autres cas elle est
		    s&eacute;rialisable, ou non persistable.
                </p></li></ol></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s3-1"></a>15.3.1.&nbsp;Ex&eacute;cuter l'outil</h3></div></div><div></div></div><p>
                L'outil &eacute;crit des mappings XML vers la sortie standard et/ou un fichier.
            </p><p>
                Quand vous invoquez l'outil, vos classes compil&eacute;es doivent &ecirc;tre dans le classpath.
            </p><p>
                <tt class="literal">java -cp </tt><span class="emphasis"><em>classpath_contenant_hibernate_et_vos_classes</em></span>
                <tt class="literal">net.sf.hibernate.tool.class2hbm.MapGenerator</tt> <span class="emphasis"><em>options et
                noms_des_classes</em></span>
            </p><p>
                Il y a deux modes op&eacute;ratoires : par ligne de commande ou interactif.
            </p><p>
                Le mode int&eacute;ractif est lanc&eacute; en pla&ccedil;ant l'argument <tt class="literal">--interact</tt>
        dans la ligne de commande. Ce mode fournit un prompt de r&eacute;ponse. En l'utilisant
		vous pouvez param&eacute;trer le nom de la propri&eacute;t&eacute; UID pour chacune des classes via la commande
		<tt class="literal">uid=XXX</tt> o&ugrave; <tt class="literal">XXX</tt> est le nom de la propri&eacute;t&eacute; UID.
        Les autres commande sont simplement le nom de la classe enti&egrave;rement 
        qualifi&eacute;e, ou la commande done qui &eacute;met l'XML et termine.
            </p><p>
                Dans le mode ligne de commande les arguments sont les options ci-dessous espac&eacute;es du
		nom qualifi&eacute; de la classe &agrave; traiter. La plupart des options sont faites pour &ecirc;tre utilis&eacute;es
		plusieurs fois, chacune affectant les classes ajout&eacute;es.
            </p><div class="table"><a name="d0e10338"></a><p class="title"><b>Tableau&nbsp;15.7.&nbsp;Options de la ligne de commande MapGenerator</b></p><table summary="Options de la ligne de commande MapGenerator" border="1"><colgroup><col><col></colgroup><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">--quiet</tt></td><td>ne pas afficher le mapping O-R vers la sortie standard</td></tr><tr><td><tt class="literal">--setUID=uid</tt></td><td>param&egrave;tre la liste des UIDs candidats sur le singleton uid</td></tr><tr><td><tt class="literal">--addUID=uid</tt></td><td>ajouter uid au d&eacute;but de la liste des UIDs candidats</td></tr><tr><td><tt class="literal">--select=</tt><span class="emphasis"><em>mode</em></span></td><td>s&eacute;lectionne le mode utilis&eacute;. <span class="emphasis"><em>mode</em></span>(e.g.,
                            <span class="emphasis"><em>distinct</em></span> or <span class="emphasis"><em>all</em></span>) 
                            pour les classes ajout&eacute;es par la suite</td></tr><tr><td><tt class="literal">--depth=&lt;small-int&gt;</tt></td><td>limite le nombre de r&eacute;cursions utilis&eacute;es pour les trouver les 
                            composants pour les classes ajout&eacute;es par la suite</td></tr><tr><td><tt class="literal">--output=mon_mapping.xml</tt></td><td>envoie le mapping O-R vers un fichier</td></tr><tr><td><span class="emphasis"><em>nom.de.classe.Qualifie</em></span></td><td>ajoute la classe au mapping</td></tr><tr><td><tt class="literal">--abstract=</tt><span class="emphasis"><em>nom.de.classe.Qualifie</em></span></td><td>voir ci dessous</td></tr></tbody></table></div><p>
                Le param&egrave;tre abstract configure l'outil map generator afin qu'il ignore
        les super classes sp&eacute;cifiques et donc
		pour que les classes h&eacute;rit&eacute;s ne soient pas mapp&eacute;es dans une grande table
		Par exemple, regardons ces hi&eacute;rarchies de classe :
            </p><p>
                <tt class="literal">Animal--&gt;Mamiph&egrave;re--&gt;Humain</tt>
            </p><p>
                <tt class="literal">Animal--&gt;Mamiph&egrave;re--&gt;Marsupial--&gt;Kangourou</tt>
            </p><p>
                Si le param&egrave;tre <tt class="literal">--abstract</tt> n'est <span class="emphasis"><em>pas</em></span> utilis&eacute;, toutes les classes
		seront mapp&eacute;es comme classes filles de <tt class="literal">Animal</tt>, ce qui donnera une grande table contenant
		toutes les propri&eacute;t&eacute;s de toutes les classes plus une colonne discriminante indiquant
        laquelle de classes fille est r&eacute;ellement stock&eacute;e dans cet enregistrement. 
        Si <tt class="literal">mamiph&egrave;re</tt> est marqu&eacute;e comme
		<tt class="literal">abstract</tt>, <tt class="literal">Humain</tt> et <tt class="literal">Marsupial</tt> seront mapp&eacute;s
		&agrave; des d&eacute;clarations de <tt class="literal">&lt;class&gt;</tt> s&eacute;par&eacute;es et stock&eacute;es dans des
		tables diff&eacute;rentes. <tt class="literal">Kangaroo</tt> sera une classe fille de <tt class="literal">Marsupial</tt>
                &agrave; moins que <tt class="literal">Marsupial</tt> soit aussi marqu&eacute;e comme <tt class="literal">abstract</tt>.
            </p></div></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="example-parentchild"></a>Chapitre&nbsp;16.&nbsp;Exemple : P&egrave;re/Fils</h2></div></div><div></div></div><p>
        L'une des premi&egrave;res choses que les nouveaux utilisateurs essaient de faire avec Hibernate est de mod&eacute;liser
	une relation p&egrave;re/fils. Il y a deux approches diff&eacute;rentes pour cela. Pour un certain nombre de raisons, la m&eacute;thode la
	plus courante, en particulier pour les nouveaux utilisateurs, est de mod&eacute;liser les deux relations <tt class="literal">P&egrave;re</tt>
	et <tt class="literal">Fils</tt> comme des classes entit&eacute;s li&eacute;es par une association <tt class="literal">&lt;one-to-many&gt;</tt> du
	<tt class="literal">P&egrave;re</tt> vers le <tt class="literal">Fils</tt> (l'autre approche est de d&eacute;clarer le <tt class="literal">Fils</tt>
	comme un <tt class="literal">&lt;composite-element&gt;</tt>). Il est &eacute;vident que le sens de l'association un vers plusieurs 
    (dans Hibernate) est bien moins proche du sens habituel d'une relation p&egrave;re/fils que ne l'est celui d'un 
	&eacute;l&eacute;ment cmposite. Nous allons vous expliquer comment utiliser une association <span class="emphasis"><em>un vers plusieurs bidirectionnelle
	avec cascade</em></span> afin de mod&eacute;liser efficacement et &eacute;l&eacute;gamment une relation p&egrave;re/fils, ce n'est vraiment 
	pas difficile !
    </p><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-collections"></a>16.1.&nbsp;Une note &agrave; propos des collections</h2></div></div><div></div></div><p>
            Les collections Hibernate sont consid&eacute;r&eacute;es comme &eacute;tant une partie logique 
            de l'entit&eacute; dans laquelle elle sont contenues ; jamais des entit&eacute;s qu'elle 
            contiennent. C'est une distinction crutiale ! Les cons&eacute;quences sont les suivantes :
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                Quand nous ajoutons / retirons un objet d'une collection, le num&eacute;ro de version du 
                propri&eacute;taire de la collection est incr&eacute;ment&eacute;.
            </p></li><li><p>
                Si un objet qui a &eacute;t&eacute; enlev&eacute; d'une collection est une instance de type valeur (ex :
		&eacute;l&eacute;ment composite), cet objet cessera d'&ecirc;tre persistant et son &eacute;tat sera compl&egrave;tement effac&eacute; 
        de la base de donn&eacute;es. Par ailleurs, ajouter une instance de type valeur dans une collection 
        aura pour cons&eacute;quence que son &eacute;tat persistera imm&eacute;diatement.
            </p></li><li><p>
                Si une entit&eacute; est enlev&eacute;e d'une collection (association un-vers-plusieurs
        ou plusieurs-vers-plusieurs), par d&eacute;faut, elle ne sera pas effac&eacute;e. Ce comportement 
        est compl&egrave;tement logique - une modification de l'un des &eacute;tats internes d'une entit&eacute; 
        ne doit pas causer la disparition de l'entit&eacute; associ&eacute;e !
		De m&ecirc;me, l'ajout d'une entit&eacute; dans une collection n'engendre pas, 
        par d&eacute;faut, la persistence de cette entit&eacute;.
            </p></li></ul></div><p>
            Le comportement par d&eacute;faut est donc que l'ajout d'une entit&eacute; dans une collection cr&eacute;&eacute; 
	    simplement le lien entre les deux entit&eacute;s, et qu'effacer une entit&eacute; supprime ce lien.
        C'est le comportement le plus appropri&eacute; dans la plupart des cas. Ce comportement n'est 
        cependant pas appropri&eacute; lorsque la vie du fils est li&eacute;e au cycle de vie du p&egrave;re.
        </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-bidir"></a>16.2.&nbsp;un-vers-plusieurs bidirectionnel</h2></div></div><div></div></div><p>
            Supposons que nous ayons une simple association <tt class="literal">&lt;one-to-many&gt;</tt>
            de <tt class="literal">Parent</tt> vers <tt class="literal">Child</tt>.
        </p><pre class="programlisting">&lt;set name="children"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
            Si nous executions le code suivant
        </p><pre class="programlisting">Parent p = .....;
Child c = new Child();
p.getChildren().add(c);
session.save(c);
session.flush();</pre><p>
            Hibernate ex&eacute;cuterait deux ordres SQL:
        </p><div class="itemizedlist"><ul type="disc"><li><p>un <tt class="literal">INSERT</tt> pour cr&eacute;er l'enregistrement pour <tt class="literal">c</tt></p></li><li><p>
                un <tt class="literal">UPDATE</tt> pour cr&eacute;er le lien de <tt class="literal">p</tt> vers
                <tt class="literal">c</tt>
            </p></li></ul></div><p>
            Ceci est non seuleument inefficace, mais viole aussi toute contrainte <tt class="literal">NOT NULL</tt> sur
            la colonne <tt class="literal">parent_id</tt>.
        </p><p>
            La cause sous jacente est que le lien (la cl&eacute; &eacute;trang&egrave;re <tt class="literal">parent_id</tt>) de
            <tt class="literal">p</tt> vers <tt class="literal">c</tt> n'est pas consid&eacute;r&eacute;e comme faisant partie de l'&eacute;tat
	    de l'objet <tt class="literal">Child</tt> et n'est donc pas cr&eacute;&eacute; par l'<tt class="literal">INSERT</tt>. 
	    La solution est donc que ce lien fasse partie du mapping de <tt class="literal">Child</tt>.
        </p><pre class="programlisting">&lt;many-to-one name="parent" column="parent_id" not-null="true"/&gt;</pre><p>
            (Nous avons aussi besoin d'ajouter la propri&eacute;t&eacute; <tt class="literal">parent</tt> dans la classe <tt class="literal">Child</tt>).
        </p><p>
            Maintenant que l'&eacute;tat du lien est g&eacute;r&eacute; par l'entit&eacute; <tt class="literal">Child</tt>, nous sp&eacute;cifions &agrave; la
	    collection de ne pas mettre &agrave; jour le lien. Nous utilisons l'attribut <tt class="literal">inverse</tt>.
        </p><pre class="programlisting">&lt;set name="children" inverse="true"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
            Le code suivant serait utilis&eacute; pour ajouter un nouveau <tt class="literal">Child</tt>
        </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
c.setParent(p);
p.getChildren().add(c);
session.save(c);
session.flush();</pre><p>
            Maintenant, seul un <tt class="literal">INSERT</tt> SQL est n&eacute;cessaire !
        </p><p>
            Pour all&eacute;ger encore un peu les choses, nous devrions cr&eacute;er une m&eacute;thode <tt class="literal">addChild()</tt> 
	    dans <tt class="literal">Parent</tt>.
        </p><pre class="programlisting">public void addChild(Child c) {
    c.setParent(this);
    children.add(c);
}</pre><p>
            Le code d'ajout d'un <tt class="literal">Child</tt> serait alors
        </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
p.addChild(c);
session.save(c);
session.flush();</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-cascades"></a>16.3.&nbsp;Cycle de vie en cascade</h2></div></div><div></div></div><p>
             L'appel explicite de <tt class="literal">save()</tt> est un peu fastidieux. Nous pouvons
	     simplifier cela en utilisant les cascades.
         </p><pre class="programlisting">&lt;set name="children" inverse="true" cascade="all"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
             Simplifie le code pr&eacute;c&eacute;dent en
         </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
p.addChild(c);
session.flush();</pre><p>
             De la m&ecirc;me mani&egrave;re, nous n'avons pas &agrave; it&eacute;rer sur les fils lorsque nous sauvons 
         ou effacons un <tt class="literal">Parent</tt>. Le code suivant efface <tt class="literal">p</tt> 
         et tous ces fils de la base de donn&eacute;es.
         </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
session.delete(p);
session.flush();</pre><p>
             Par contre, ce code
         </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = (Child) p.getChildren().iterator().next();
p.getChildren().remove(c);
c.setParent(null);
session.flush();</pre><p>
             n'effacera pas <tt class="literal">c</tt> de la base de donn&eacute;es, il enl&egrave;vera seulement 
         le lien vers  <tt class="literal">p</tt> (et causera une violation de contrainte 
         <tt class="literal">NOT NULL</tt>, dans ce cas). 
	     Vous devez explicitement utiliser <tt class="literal">delete()</tt> sur <tt class="literal">Child</tt>.
         </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = (Child) p.getChildren().iterator().next();
p.getChildren().remove(c);
session.delete(c);
session.flush();</pre><p>
             Dans notre cas, un <tt class="literal">Child</tt> ne peut pas vraiment exister sans son p&egrave;re. Si nous
	     effacons un <tt class="literal">Child</tt> de la collection, nous voulons vraiment qu'il soit effac&eacute;.
	     Pour cela, nous devons utiliser <tt class="literal">cascade="all-delete-orphan"</tt>.
         </p><pre class="programlisting">&lt;set name="children" inverse="true" cascade="all-delete-orphan"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
             A noter : m&ecirc;me si le mapping de la collection sp&eacute;cifie <tt class="literal">inverse="true"</tt>, les cascades
	     sont toujours assur&eacute;es par l'it&eacute;ration sur les &eacute;l&eacute;ments de la collection. Donc, si vous avez besoin
	     qu'un objet soit enregistr&eacute;, effac&eacute; ou mis &agrave; jour par cascade, vous devez l'ajouter dans la colleciton.
	     Il ne suffit pas d'appeler explicitement <tt class="literal">setParent()</tt>.
         </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-update"></a>16.4.&nbsp;Utiliser <tt class="literal">update()</tt> en cascade</h2></div></div><div></div></div><p>
             Supposons que nous ayons charg&eacute; un <tt class="literal">Parent</tt> dans une <tt class="literal">Session</tt>, 
         et que nous l'ayons ensuite modifi&eacute; et que voulions persiter ces modifications dans une nouvelle session 
         (en appelant <tt class="literal">update()</tt>). 
	     Le <tt class="literal">Parent</tt> contiendra une collection de fils et, puisque la cascade est activ&eacute;e, 
         Hibernate a besoin de savoir quels fils viennent d'&ecirc;tre instanci&eacute;s et quels fils proviennent de la base 
         de donn&eacute;es. Supposons aussi que <tt class="literal">Parent</tt> et <tt class="literal">Child</tt> ont tous deux 
         des identifiants (terchniques) du type <tt class="literal">java.lang.Long</tt>. 
         Hibernate utilisera la propri&eacute;t&eacute; de l'identifiant pour d&eacute;terminer quels fils sont nouveaux 
         (vous pouvez aussi utiliser la propri&eacute;t&eacute; version ou timestamp, voir 
	     <a href="#manipulatingdata-updating-detached" title="9.4.2.&nbsp;Mise &agrave; jour d'objets d&eacute;tach&eacute;s">Section&nbsp;9.4.2, &laquo;&nbsp;Mise &agrave; jour d'objets d&eacute;tach&eacute;s&nbsp;&raquo;</a>).
         </p><p>
             L'attribut <tt class="literal">unsaved-value</tt> est utilis&eacute; pour sp&eacute;cifier la valeur d&eacute;terminant
         qu'une instance est nouvellement instanci&eacute;e. La valeur par d&eacute;faut de 
         <tt class="literal">unsaved-value</tt> est "null", ce qui est parfait pour les 
	     identifiants de type <tt class="literal">Long</tt>. 
         Si nous avions une propri&eacute;t&eacute; identifiant d'un type primitif, nous devrions sp&eacute;cifier
         </p><pre class="programlisting">&lt;id name="id" type="long" unsaved-value="0"&gt;</pre><p>
             pour le mapping de <tt class="literal">Child</tt>
             (Il existe aussi un attribut <tt class="literal">unsaved-value</tt> 
             pour le mapping des propri&eacute;t&eacute;s version et timestamp).
         </p><p>
             Le code suivant, mettra &agrave; jour <tt class="literal">parent</tt> et <tt class="literal">child</tt> 
             et ins&egrave;rera <tt class="literal">newChild</tt>.
         </p><pre class="programlisting">//parent et child ont &eacute;t&eacute; charg&eacute;s dans une session pr&eacute;c&eacute;dente
parent.addChild(child);
Child newChild = new Child();
parent.addChild(newChild);
session.update(parent);
session.flush();</pre><p>
             Ceci est tr&egrave;s bien pour des identifiants g&eacute;n&eacute;r&eacute;s, mais qu'en est il des identifiants assign&eacute;s et des
	     identifiants compos&eacute;s ? C'est plus difficile, puisque <tt class="literal">unsaved-value</tt> ne permet pas
	     de distinguer un objet nouvellement instanci&eacute; d'un
	     objet charg&eacute; dans une session pr&eacute;c&eacute;dente (puisque celui-ci est assign&eacute; par l'utilisateur). 
         Dans ce cas, vous devrez aider Hibernte, soit
         </p><div class="itemizedlist"><ul type="disc"><li><p>
                 d&eacute;finir <tt class="literal">unsaved-value="null"</tt> ou <tt class="literal">unsaved-value="negative"</tt>
                 dans le mapping de <tt class="literal">&lt;version&gt;</tt> ou 
		 <tt class="literal">&lt;timestamp&gt;</tt>.
             </p></li><li><p>
                 d&eacute;finir <tt class="literal">unsaved-value="none"</tt> et appeler explicitement <tt class="literal">save()</tt>
                 sur les fils nouvellement instanci&eacute;s avant d'appeler <tt class="literal">update(parent)</tt>
             </p></li><li><p>
                 d&eacute;finir <tt class="literal">unsaved-value="any"</tt> et appeler explicitement <tt class="literal">update()</tt>
                 sur les fils pr&eacute;c&eacute;dement persistant avant d'appeler <tt class="literal">update(parent)</tt>
             </p></li></ul></div><p>
             <tt class="literal">none</tt> est la valeur par d&eacute;faut de <tt class="literal">unsaved-value</tt> pour les identifiant
	     assign&eacute;s ou compos&eacute;s.
         </p><p>
             Il existe une derni&egrave;re possibilit&eacute;. <tt class="literal">Interceptor</tt> poss&egrave;de une nouvelle m&eacute;thode
         nomm&eacute;e <tt class="literal">isUnsaved()</tt> qui vous permet d'impl&eacute;menter votre propre strat&eacute;gie pour distinguer
	     les objets nouvellement instanci&eacute;s. Par exemple, vous pouvez d&eacute;finir une classe de base pour vos
	     classes persistantes.
         </p><pre class="programlisting">public class Persistent {
    private boolean _saved = false;
    public void onSave() {
        _saved=true;
    }
    public void onLoad() {
        _saved=true;
    }
    ......
    public boolean isSaved() {
        return _saved;
    }
}</pre><p>
             (La propri&eacute;t&eacute; <tt class="literal">saved</tt> est non-persistante).
             Il faut maintenant impl&eacute;menter<tt class="literal">isUnsaved()</tt>, <tt class="literal">onLoad()</tt>
             et <tt class="literal">onSave()</tt> comme suit :
         </p><pre class="programlisting">public Boolean isUnsaved(Object entity) {
    if (entity instanceof Persistent) {
        return new Boolean( !( (Persistent) entity ).isSaved() );
    }
    else {
        return null;
    }
}

public boolean onLoad(Object entity, 
    Serializable id,
    Object[] state,
    String[] propertyNames,
    Type[] types) {

    if (entity instanceof Persistent) ( (Persistent) entity ).onLoad();
    return false;
}

public boolean onSave(Object entity,
    Serializable id,
    Object[] state,
    String[] propertyNames,
    Type[] types) {
        
    if (entity instanceof Persistent) ( (Persistent) entity ).onSave();
    return false;
}</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-conclusion"></a>16.5.&nbsp;Conclusion</h2></div></div><div></div></div><p>
             Il y a quelques principes &agrave; ma&icirc;triser dans ce chapitre et tout cela peut para&icirc;tre d&eacute;routant la premi&egrave;re fois.
	     Cependant, dans la pratique, tout fonctionne parfaitement. La plupart des applications Hibernate utilisent
	     le pattern p&egrave;re / fils.
         </p><p>
             Nous avons &eacute;voqu&eacute; une alternative dans le premier paragraphe. Aucun des points trait&eacute;s pr&eacute;c&eacute;demment n'existe
	     dans le cas d'un mapping <tt class="literal">&lt;composite-element&gt;</tt> qui poss&egrave;de exactement la s&eacute;mantique
	     d'une relation p&egrave;re / fils. Malheureusement, il y a deux grandes limitations pour les classes &eacute;l&eacute;ments
	     composites : les &eacute;l&eacute;ments composites ne peuvent contenir de collections, et ils ne peuvent &ecirc;tre les fils 
	     d'entit&eacute;s autres (cependant, ils <span class="emphasis"><em>peuvent</em></span> avoir une cl&eacute; primaire
	     technique, en utilisant un mapping <tt class="literal">&lt;idbag&gt;</tt>).
         </p></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="example-weblog"></a>Chapitre&nbsp;17.&nbsp;Exemple : Application de Weblog</h2></div></div><div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-weblog-classes"></a>17.1.&nbsp;Classes persistantes</h2></div></div><div></div></div><p>
            Les classes persistantes representent un weblog, et un article post&eacute;
	    dans un weblog. Il seront mod&eacute;lis&eacute;s comme une relation p&egrave;re/fils
	    standard, mais nous allons utiliser un "bag" tri&eacute; au lieu d'un set.

        </p><pre class="programlisting">package eg;
import java.util.List;

public class Blog {
    private Long _id;
    private String _name;
    private List _items;

    public Long getId() {
        return _id;
    }
    public List getItems() {
        return _items;
    }
    public String getName() {
        return _name;
    }
    public void setId(Long long1) {
        _id = long1;
    }
    public void setItems(List list) {
        _items = list;
    }
    public void setName(String string) {        _name = string;
    }
}</pre><pre class="programlisting">package eg;

import java.text.DateFormat;
import java.util.Calendar;

public class BlogItem {
    private Long _id;
    private Calendar _datetime;
    private String _text;
    private String _title;
    private Blog _blog;

    public Blog getBlog() {
        return _blog;
    }
    public Calendar getDatetime() {
        return _datetime;
    }
    public Long getId() {
        return _id;
    }
    public String getText() {
        return _text;
    }
    public String getTitle() {
        return _title;
    }
    public void setBlog(Blog blog) {
        _blog = blog;
    }
    public void setDatetime(Calendar calendar) {
        _datetime = calendar;
    }
    public void setId(Long long1) {
        _id = long1;
    }
    public void setText(String string) {
        _text = string;
    }
    public void setTitle(String string) {
        _title = string;
    }
}</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-weblog-mappings"></a>17.2.&nbsp;Mappings Hibernate</h2></div></div><div></div></div><p>
            Le mapping XML doit maintenant &ecirc;tre relativement simple &agrave; vos yeux.
       </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC 
        "-//Hibernate/Hibernate Mapping DTD 2.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

    &lt;class 
        name="Blog" 
        table="BLOGS" 
        lazy="true"&gt;
        
        &lt;id 
            name="id" 
            column="BLOG_ID"&gt;
            
            &lt;generator class="native"/&gt;
            
        &lt;/id&gt;
        
        &lt;property 
            name="name" 
            column="NAME" 
            not-null="true" 
            unique="true"/&gt;
            
        &lt;bag 
            name="items" 
            inverse="true" 
            lazy="true"
            order-by="DATE_TIME" 
            cascade="all"&gt;
            
            &lt;key column="BLOG_ID"/&gt;
            &lt;one-to-many class="BlogItem"/&gt;
            
        &lt;/bag&gt;
        
    &lt;/class&gt;
    
&lt;/hibernate-mapping&gt;</pre><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC 
        "-//Hibernate/Hibernate Mapping DTD 2.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;
    
    &lt;class 
        name="BlogItem" 
        table="BLOG_ITEMS" 
        dynamic-update="true"&gt;
        
        &lt;id 
            name="id" 
            column="BLOG_ITEM_ID"&gt;
            
            &lt;generator class="native"/&gt;
            
        &lt;/id&gt;
        
        &lt;property 
            name="title" 
            column="TITLE" 
            not-null="true"/&gt;
            
        &lt;property 
            name="text" 
            column="TEXT" 
            not-null="true"/&gt;
            
        &lt;property 
            name="datetime" 
            column="DATE_TIME" 
            not-null="true"/&gt;
            
        &lt;many-to-one 
            name="blog" 
            column="BLOG_ID" 
            not-null="true"/&gt;
            
    &lt;/class&gt;
    
&lt;/hibernate-mapping&gt;</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-weblog-code"></a>17.3.&nbsp;Code Hibernate</h2></div></div><div></div></div><p>
            La classe suivante montre quelques utilisations que nous pouvons faire
            de ces classes.
        </p><pre class="programlisting">package eg;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Iterator;
import java.util.List;

import net.sf.hibernate.HibernateException;
import net.sf.hibernate.Query;
import net.sf.hibernate.Session;
import net.sf.hibernate.SessionFactory;
import net.sf.hibernate.Transaction;
import net.sf.hibernate.cfg.Configuration;
import net.sf.hibernate.tool.hbm2ddl.SchemaExport;

public class BlogMain {
    
    private SessionFactory _sessions;
    
    public void configure() throws HibernateException {
        _sessions = new Configuration()
            .addClass(Blog.class)
            .addClass(BlogItem.class)
            .buildSessionFactory();
    }
    
    public void exportTables() throws HibernateException {
        Configuration cfg = new Configuration()
            .addClass(Blog.class)
            .addClass(BlogItem.class);
        new SchemaExport(cfg).create(true, true);
    }
    
    public Blog createBlog(String name) throws HibernateException {
        
        Blog blog = new Blog();
        blog.setName(name);
        blog.setItems( new ArrayList() );
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.save(blog);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return blog;
    }
    
    public BlogItem createBlogItem(Blog blog, String title, String text)
                        throws HibernateException {
        
        BlogItem item = new BlogItem();
        item.setTitle(title);
        item.setText(text);
        item.setBlog(blog);
        item.setDatetime( Calendar.getInstance() );
        blog.getItems().add(item);
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.update(blog);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return item;
    }
    
    public BlogItem createBlogItem(Long blogid, String title, String text)
                        throws HibernateException {
        
        BlogItem item = new BlogItem();
        item.setTitle(title);
        item.setText(text);
        item.setDatetime( Calendar.getInstance() );
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            Blog blog = (Blog) session.load(Blog.class, blogid);
            item.setBlog(blog);
            blog.getItems().add(item);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return item;
    }
    
    public void updateBlogItem(BlogItem item, String text)
                    throws HibernateException {
        
        item.setText(text);
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.update(item);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
    }
    
    public void updateBlogItem(Long itemid, String text)
                    throws HibernateException {
    
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            BlogItem item = (BlogItem) session.load(BlogItem.class, itemid);
            item.setText(text);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
    }
    
    public List listAllBlogNamesAndItemCounts(int max)
                    throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        List result = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "select blog.id, blog.name, count(blogItem) " +
                "from Blog as blog " +
                "left outer join blog.items as blogItem " +
                "group by blog.name, blog.id " +
                "order by max(blogItem.datetime)"
            );
            q.setMaxResults(max);
            result = q.list();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return result;
    }
    
    public Blog getBlogAndAllItems(Long blogid)
                    throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        Blog blog = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "from Blog as blog " +
                "left outer join fetch blog.items " +
                "where blog.id = :blogid"
            );
            q.setParameter("blogid", blogid);
            blog  = (Blog) q.list().get(0);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return blog;
    }
    
    public List listBlogsAndRecentItems() throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        List result = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "from Blog as blog " +
                "inner join blog.items as blogItem " +
                "where blogItem.datetime &gt; :minDate"
            );

            Calendar cal = Calendar.getInstance();
            cal.roll(Calendar.MONTH, false);
            q.setCalendar("minDate", cal);
            
            result = q.list();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return result;
    }
}</pre></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="example-mappings"></a>Chapitre&nbsp;18.&nbsp;Exemple : Quelques mappings</h2></div></div><div></div></div><p>
        Ce chapitre montre quelques mappings plus complexes.
    </p><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-mappings-emp"></a>18.1.&nbsp;Employeur/Employ&eacute; (Employer/Employee)</h2></div></div><div></div></div><p>
            Le mod&egrave;le suivant de relation entre <tt class="literal">Employer</tt> et 
            <tt class="literal">Employee</tt> utilise une vraie classe entit&eacute; (<tt class="literal">Employment</tt>) 
            pour repr&eacute;senter l'association. On a fait cela parce qu'il peut y avoir plus d'une p&eacute;riode
	    d'emploi pour les deux m&ecirc;mes parties. Des composants sont utilis&eacute;s pour mod&eacute;liser les
	    valeurs mon&eacute;taires et les noms des employ&eacute;s.
        </p><div class="mediaobject" align="center"><img src="../shared/images/EmployerEmployee.gif" align="middle"></div><p>
            Voici un document de mapping possible :
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;
        
    &lt;class name="Employer" table="employers"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employer_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

    &lt;class name="Employment" table="employment_periods"&gt;

        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employment_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="startDate" column="start_date"/&gt;
        &lt;property name="endDate" column="end_date"/&gt;

        &lt;component name="hourlyRate" class="MonetoryAmount"&gt;
            &lt;property name="amount"&gt;
                &lt;column name="hourly_rate" sql-type="NUMERIC(12, 2)"/&gt;
            &lt;/property&gt;
            &lt;property name="currency" length="12"/&gt;
        &lt;/component&gt;

        &lt;many-to-one name="employer" column="employer_id" not-null="true"/&gt;
        &lt;many-to-one name="employee" column="employee_id" not-null="true"/&gt;

    &lt;/class&gt;

    &lt;class name="Employee" table="employees"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employee_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="taxfileNumber"/&gt;
        &lt;component name="name" class="Name"&gt;
            &lt;property name="firstName"/&gt;
            &lt;property name="initial"/&gt;
            &lt;property name="lastName"/&gt;
        &lt;/component&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
        Et voici le sch&eacute;ma des tables g&eacute;n&eacute;r&eacute;es par <tt class="literal">SchemaExport</tt>.
    </p><pre class="programlisting">create table employers (
    id BIGINT not null, 
    name VARCHAR(255), 
    primary key (id)
)

create table employment_periods (
    id BIGINT not null,
    hourly_rate NUMERIC(12, 2),
    currency VARCHAR(12), 
    employee_id BIGINT not null, 
    employer_id BIGINT not null, 
    end_date TIMESTAMP, 
    start_date TIMESTAMP, 
    primary key (id)
)

create table employees (
    id BIGINT not null, 
    firstName VARCHAR(255), 
    initial CHAR(1), 
    lastName VARCHAR(255), 
    taxfileNumber VARCHAR(255), 
    primary key (id)
)

alter table employment_periods 
    add constraint employment_periodsFK0 foreign key (employer_id) references employers
alter table employment_periods 
    add constraint employment_periodsFK1 foreign key (employee_id) references employees
create sequence employee_id_seq
create sequence employment_id_seq
create sequence employer_id_seq</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-mappings-authorwork"></a>18.2.&nbsp;Auteur/Travail (Author/Work)</h2></div></div><div></div></div><p>
            Soit le mod&egrave;le de la relation entre <tt class="literal">Work</tt>, <tt class="literal">Author</tt> 
	    et <tt class="literal">Person</tt>. Nous repr&eacute;sentons la relation entre <tt class="literal">Work</tt> 
	    et <tt class="literal">Author</tt> comme une association plusieurs-vers-plusieurs. Nous avons choisi de
	    repr&eacute;senter la relation entre <tt class="literal">Author</tt> et <tt class="literal">Person</tt> 
	    comme une association un-vers-un. Une autre possibilit&eacute; aurait &eacute;t&eacute; que 
	    <tt class="literal">Author</tt> h&eacute;rite de <tt class="literal">Person</tt>.  
        </p><div class="mediaobject" align="center"><img src="../shared/images/AuthorWork.gif" align="middle"></div><p>
            Le mapping suivant repr&eacute;sente exactement ces relations :
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Work" table="works" discriminator-value="W"&gt;

        &lt;id name="id" column="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;discriminator column="type" type="character"/&gt;

        &lt;property name="title"/&gt;
        &lt;set name="authors" table="author_work" lazy="true"&gt;
            &lt;key&gt;
                &lt;column name="work_id" not-null="true"/&gt;
            &lt;/key&gt;
            &lt;many-to-many class="Author"&gt;
                &lt;column name="author_id" not-null="true"/&gt;
            &lt;/many-to-many&gt;
        &lt;/set&gt;

        &lt;subclass name="Book" discriminator-value="B"&gt;
            &lt;property name="text"/&gt;
        &lt;/subclass&gt;

        &lt;subclass name="Song" discriminator-value="S"&gt;
            &lt;property name="tempo"/&gt;
            &lt;property name="genre"/&gt;
        &lt;/subclass&gt;

    &lt;/class&gt;

    &lt;class name="Author" table="authors"&gt;

        &lt;id name="id" column="id"&gt;
            &lt;!-- L'Author doit avoir le m&ecirc;me identifiant que Person --&gt;
            &lt;generator class="assigned"/&gt; 
        &lt;/id&gt;

        &lt;property name="alias"/&gt;
        &lt;one-to-one name="person" constrained="true"/&gt;

        &lt;set name="works" table="author_work" inverse="true" lazy="true"&gt;
            &lt;key column="author_id"/&gt;
            &lt;many-to-many class="Work" column="work_id"/&gt;
        &lt;/set&gt;

    &lt;/class&gt;

    &lt;class name="Person" table="persons"&gt;
        &lt;id name="id" column="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
        Il y a quatre tables dans ce mapping. <tt class="literal">works</tt>, 
        <tt class="literal">authors</tt> et <tt class="literal">persons</tt> qui contiennent
	respectivement les donn&eacute;es de work, author et person. 
	<tt class="literal">author_work</tt> est une table d'association qui lie authors 
	&agrave; works. Voici le sch&eacute;ma de tables, g&eacute;n&eacute;r&eacute; par <tt class="literal">SchemaExport</tt>.
    </p><pre class="programlisting">create table works (
    id BIGINT not null generated by default as identity, 
    tempo FLOAT, 
    genre VARCHAR(255), 
    text INTEGER, 
    title VARCHAR(255), 
    type CHAR(1) not null, 
    primary key (id)
)

create table author_work (
    author_id BIGINT not null, 
    work_id BIGINT not null, 
    primary key (work_id, author_id)
)

create table authors (
    id BIGINT not null generated by default as identity, 
    alias VARCHAR(255), 
    primary key (id)
)

create table persons (
    id BIGINT not null generated by default as identity, 
    name VARCHAR(255), 
    primary key (id)
)

alter table authors 
    add constraint authorsFK0 foreign key (id) references persons
alter table author_work 
    add constraint author_workFK0 foreign key (author_id) references authors
alter table author_work
    add constraint author_workFK1 foreign key (work_id) references works</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-mappings-customerorderproduct"></a>18.3.&nbsp;Client/Commande/Produit (Customer/Order/Product)</h2></div></div><div></div></div><p>
            Imaginons maintenant le mod&egrave;le de relation entre <tt class="literal">Customer</tt>,
            <tt class="literal">Order</tt>, <tt class="literal">LineItem</tt> et <tt class="literal">Product</tt>.
            Il y a une association un-vers-plusieurs entre <tt class="literal">Customer</tt> et
            <tt class="literal">Order</tt>, mais comment devrions nous repr&eacute;senter <tt class="literal">Order</tt> / 
            <tt class="literal">LineItem</tt> / <tt class="literal">Product</tt>? J'ai choisi de mapper
            <tt class="literal">LineItem</tt> comme une classe d'association repr&eacute;sentant l'association 
	        plusieurs-vers-plusieurs entre <tt class="literal">Order</tt> et <tt class="literal">Product</tt>. Dans
            Hibernate, on appelle cela un &eacute;l&eacute;ment composite.
        </p><div class="mediaobject" align="center"><img src="../shared/images/CustomerOrderProduct.gif" align="middle"></div><p>
            Le document de mapping :
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Customer" table="customers"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
        &lt;set name="orders" inverse="true" lazy="true"&gt;
            &lt;key column="customer_id"/&gt;
            &lt;one-to-many class="Order"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Order" table="orders"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="date"/&gt;
        &lt;many-to-one name="customer" column="customer_id"/&gt;
        &lt;list name="lineItems" table="line_items" lazy="true"&gt;
            &lt;key column="order_id"/&gt;
            &lt;index column="line_number"/&gt;
            &lt;composite-element class="LineItem"&gt;
                &lt;property name="quantity"/&gt;
                &lt;many-to-one name="product" column="product_id"/&gt;
            &lt;/composite-element&gt;
        &lt;/list&gt;
    &lt;/class&gt;

    &lt;class name="Product" table="products"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="serialNumber"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
        <tt class="literal">customers</tt>, <tt class="literal">orders</tt>, <tt class="literal">line_items</tt> et 
        <tt class="literal">products</tt> contiennent les donn&eacute;es de customer, order, order line item et product. 
	<tt class="literal">line_items</tt> est aussi la table d'association liant orders &agrave; products.
    </p><pre class="programlisting">create table customers (
    id BIGINT not null generated by default as identity, 
    name VARCHAR(255), 
    primary key (id)
)

create table orders (
    id BIGINT not null generated by default as identity, 
    customer_id BIGINT, 
    date TIMESTAMP, 
    primary key (id)
)

create table line_items (
    line_number INTEGER not null, 
    order_id BIGINT not null, 
    product_id BIGINT, 
    quantity INTEGER, 
    primary key (order_id, line_number)
)

create table products (
    id BIGINT not null generated by default as identity, 
    serialNumber VARCHAR(255), 
    primary key (id)
)

alter table orders 
    add constraint ordersFK0 foreign key (customer_id) references customers
alter table line_items
    add constraint line_itemsFK0 foreign key (product_id) references products
alter table line_items
    add constraint line_itemsFK1 foreign key (order_id) references orders</pre></div></div><div class="chapter" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a name="best-practices"></a>Chapitre&nbsp;19.&nbsp;Meilleures pratiques</h2></div></div><div></div></div><div class="variablelist"><dl><dt><span class="term">D&eacute;coupez finement vos classes et mappez les en utilisant <tt class="literal">&lt;component&gt;</tt>.</span></dt><dd><p>
                    Utilisez une classe <tt class="literal">Addresse</tt> pour encapsuler <tt class="literal">Rue</tt>,
                    <tt class="literal">Region</tt>, <tt class="literal">CodePostal</tt>.
                    Ceci permet la r&eacute;utilisation du code et simplifie la maintenance.
                </p></dd><dt><span class="term">D&eacute;clarez des propri&eacute;t&eacute;s d'identifiants dans les classes persistantes.</span></dt><dd><p>
                    Hibernate rend les propri&eacute;t&eacute;s d'identifiants optionnelles. Il existe beaucoup de raisons
		    pour lesquelles vous devriez les utiliser. Nous recommandons que vous utilisiez des identifiants
		    techniques (g&eacute;n&eacute;r&eacute;s, et sans connotation m&eacute;tier) et de type non primitif. Pour un 
		    maximum de flexibilit&eacute;, utilisez <tt class="literal">java.lang.Long</tt> ou <tt class="literal">java.lang.String</tt>.
                </p></dd><dt><span class="term">Placez chaque mapping de classe dans son propre fichier.</span></dt><dd><p>
                     N'utilisez pas un unique document de mapping. Mappez <tt class="literal">com.eg.Foo</tt> dans 
                     le fichier <tt class="literal">com/eg/Foo.hbm.xml</tt>. Cela prend tout son sens lors
                     d'un travail en &eacute;quipe.
                </p></dd><dt><span class="term">Chargez les mappings comme des ressources.</span></dt><dd><p>
                    D&eacute;ployez les mappings en m&ecirc;me temps que les classes qu'ils mappent.
                </p></dd><dt><span class="term">Pensez &agrave; externaliser les cha&icirc;nes de caract&egrave;res.</span></dt><dd><p>
                    Ceci est une bonne habitude si vos requ&ecirc;tes appellent des fonctions SQL qui ne sont
		    pas au standard ANSI. Cette externalisation dans les fichiers de mapping rendra votre
		    application plus portable.
                </p></dd><dt><span class="term">Utilisez les variables "bind&eacute;es".</span></dt><dd><p>
                     Comme en JDBC, remplacez toujours les valeurs non constantes par "?". N'utilisez jamais
		     la manipulation des cha&icirc;nes de caract&egrave;res pour remplacer des valeurs non constantes dans
		     une requ&ecirc;te ! Encore mieux, utilisez les param&egrave;tres nomm&eacute;s dans les requ&ecirc;tes.
                </p></dd><dt><span class="term">Ne g&eacute;rez pas vous m&ecirc;mes les connexions JDBC.</span></dt><dd><p>
                    Hibernate laisse l'application g&eacute;rer les connexions JDBC. Vous ne devriez g&eacute;rer vos connexions 
		    qu'en dernier recours. Si vous ne pouvez pas utiliser les syst&egrave;mes de connexions livr&eacute;s, 
		    r&eacute;fl&eacute;chissez &agrave; l'id&eacute;e de fournir votre propre impl&eacute;mentation de
            <tt class="literal">net.sf.hibernate.connection.ConnectionProvider</tt>.
                </p></dd><dt><span class="term">Pensez &agrave; utiliser les types utilisateurs.</span></dt><dd><p>
                    Supposez que vous ayez une type Java, de telle biblioth&egrave;que, qui a besoin d'&ecirc;tre persist&eacute; mais
		    qui ne fournit pas les accesseurs n&eacute;cessaires pour le mapper comme composant. Vous devriez
		    impl&eacute;menter <tt class="literal">net.sf.hibernate.UserType</tt>. Cette approche lib&egrave;re le code de l'application
            de l'impl&eacute;mentation des transformations vers / depuis les types Hibernate.
                </p></dd><dt><span class="term">Utiliser du JDBC pur dans les goulets d'&eacute;tranglement.</span></dt><dd><p>
                    Dans certaines parties critiques de votre syst&egrave;me d'un point de vue performance, quelques op&eacute;rations
		    (exemple : update et delete massifs) peuvent tirer partie d'un appel JDBC natif. 
            Mais attendez de <span class="emphasis"><em>savoir</em></span>
		    que c'est un goulet d'&eacute;tranglement. Ne supposez jamais qu'un appel JDBC sera forc&eacute;ment plus 
		    rapide. Si vous avez besoin d'utiliser JDBC directement, ouvrez une <tt class="literal">Session</tt> 
            Hibernate et utilisez la connexion SQL sous-jacente. Ainsi vous pourrez utiliser la m&ecirc;me strat&eacute;gie 
            de transation et la m&ecirc;me gestion des connexions.
                </p></dd><dt><span class="term">Comprendre le flush de <tt class="literal">Session</tt>.</span></dt><dd><p>
                    De temps en temps la Session synchronise ses &eacute;tats persistants avec la base de donn&eacute;es. 
            Les performances seront affect&eacute;es si ce processus arrive trop souvent. Vous pouvez parfois 
            minimiser les flush non n&eacute;cessaires en d&eacute;sactivant le flush automatique ou m&ecirc;me en changeant 
            l'ordre des op&eacute;rations men&eacute;es dans une transaction particuli&egrave;re.
                </p></dd><dt><span class="term">Dans une architecture &agrave; trois couches, pensez &agrave; utiliser <tt class="literal">saveOrUpdate()</tt>.</span></dt><dd><p>
                    Quand vous utilisez une architecture &agrave; base de servlet / session bean, vous pourriez passer
		    des objets charg&eacute;s dans le bean session vers et depuis la couche servlet / jsp. Utilisez
		    une nouvelle session pour traiter chaque requ&ecirc;te. Utilisez <tt class="literal">Session.update()</tt> 
		    ou <tt class="literal">Session.saveOrUpdate()</tt> pour mettre &agrave; jour l'&eacute;tat persistant de votre
		    objet.
                </p></dd><dt><span class="term">Dans une architecture &agrave; deux couches, pensez &agrave; utiliser la d&eacute;connexion de session.</span></dt><dd><p>
                    Les transactions de bases de donn&eacute;es doivent &ecirc;tre aussi courtes que possible 
            pour une meilleure scalabilit&eacute;. Cependant, il est souvent n&eacute;cessaire d'impl&eacute;menter 
            de longues transactions applicatives, une simple unit&eacute; de travail du point de vue de 
            l'utilisateur. La transaction applicative
		    peut s'&eacute;taler sur plusieurs cycles de requ&ecirc;tes/r&eacute;ponses du client. Utilisez soit les
		    objets d&eacute;tach&eacute;s ou, dans une architecture deux tiers, d&eacute;connectez simplement la session
		    Hibernate de la connexion JDBC et reconnectez la &agrave; chaque requ&ecirc;te suivante.
		    N'utilisez jamais une seule session pour plus d'un cas d'utilisation de type 
            transaction applicative, sinon vous vous retrouverez avec des donn&eacute;es obsol&egrave;tes.
                </p></dd><dt><span class="term">Connsid&eacute;rer que les exceptions ne sont pas rattrapables.</span></dt><dd><p>
                    Il s'agit plus d'une pratique obligatoire que d'une "meilleure pratique". Quand une exception
		    intervient, il faut faire un rollback de la <tt class="literal">Transaction</tt> et 
            fermer la <tt class="literal">Session</tt>. 
		    Sinon, Hibernate ne peut garantir l'int&eacute;grit&eacute; des &eacute;tats persistants en m&eacute;moire. En particulier,
		    n'utilisez pas <tt class="literal">Session.load()</tt> pour d&eacute;terminer si une instance avec un identifiant
		    donn&eacute; existe en base de donn&eacute;es, utilisez <tt class="literal">find()</tt> (ou <tt class="literal">get()</tt>)
            &agrave; la place. Quelques exceptions sont r&eacute;cup&eacute;rables, par exemple <tt class="literal">StaleObjectStateException</tt> 
            et <tt class="literal">ObjectNotFoundException</tt>.
                </p></dd><dt><span class="term">Pr&eacute;f&eacute;rez le chargement tardif des associations.</span></dt><dd><p><a name="best-practices-p14"></a>
                    Utilisez le chargement complet (simple ou par jointure ouverte) avec
            mod&eacute;ration. Utilisez les proxies et/ou les collections charg&eacute;es tardivement
            pour la plupart des associations vers des classes qui ne sont 
		    pas en cache de niveau JVM. Pour les assocations de classes en cache, o&ugrave; il y a une
		    forte probabilit&eacute; que l'&eacute;l&eacute;ment soit en cache, d&eacute;sactivez explicitement le chargement 
            par jointures ouvertes en utilisant <tt class="literal">outer-join="false"</tt>. 
            Lorsqu'un chargement par jointure ouverte est appropri&eacute; pour un cas d'utilisation 
            particulier, utilisez une requ&ecirc;te avec un <tt class="literal">left join fetch</tt>.
                </p></dd><dt><span class="term">Pensez &agrave; abstraite votre logique m&eacute;tier d'Hibernate.</span></dt><dd><p>
                    Cachez le m&eacute;canisme d'acc&egrave;s aux donn&eacute;es (Hibernate) derri&egrave;re une interface. Combinez les patterns
		    <span class="emphasis"><em>DAO</em></span> et <span class="emphasis"><em>Thread Local Session</em></span>. Vous pouvez m&ecirc;me avoir quelques
		    classes persist&eacute;es par du JDBC pur, associ&eacute;es &agrave; Hibernate via un <tt class="literal">UserType</tt> (ce conseil est
		    valable pour des applications de taille respectables ; il n'est pas valable pour une application 
		    avec 10 tables).
                </p></dd><dt><span class="term">Impl&eacute;mentez <tt class="literal">equals()</tt> et <tt class="literal">hashCode()</tt> en utilisant une cl&eacute; m&eacute;tier.</span></dt><dd><p>
                    Si vous comparez des objets en dehors de la session, vous devez impl&eacute;menter <tt class="literal">equals()</tt>
                    et <tt class="literal">hashCode()</tt>. A l'int&eacute;rieur de la session, l'identit&eacute; des objets java est 
		    assur&eacute;e. Si vous impl&eacute;mentez ces m&eacute;thodes, n'utilisez jamais les identifiants de la base de donn&eacute;es ! Une instance
		    transiante n'a pas de valeur d'identifiant et Hibernate en assignera une quand l'objet sera sauv&eacute;.
		    Si l'objet est dans un Set quand il est en cours de sauvegarde, le hashcode changera donc, ce qui rompt
		    le contrat. Pour impl&eacute;menter <tt class="literal">equals()</tt> et <tt class="literal">hashCode()</tt>, utilisez une
		    cl&eacute; m&eacute;tier unique ce qui revient &agrave; comparer une combinaison de propri&eacute;t&eacute;s de classe. Souvenez vous
		    que cette cl&eacute; doit &ecirc;tre stable et unique pendant la dur&eacute;e durant laquelle l'objet est dans un Set, 
            et non pour tout son cycle de vie (pas aussi stable que la cl&eacute; primaire de la base de donn&eacute;es). 
            ne comparez jamais des collections avec <tt class="literal">equals()</tt> (chargement tardif) 
            et soyez prudents avec les autres classes dont vous pourriez n'avoir qu'un proxy.
                </p></dd><dt><span class="term">N'utilisez pas d'associations de mapping exotiques.</span></dt><dd><p>
                    De bons cas d'utilisation pour de vraies associations plusieurs-vers-plusieurs
            sont rares. La plupart du temps vous avez besoin d'informations additionnelles 
            stock&eacute;es dans la table d'association.
		    Dans ce cas, il est pr&eacute;f&eacute;rable d'utiliser deux associations un-vers-plusieurs vers une classe
		    de liaisons interm&eacute;diaire. En fait, nous pensons que la plupart des associations sont
		    de type un-vers-plusieurs ou plusieurs-vers-un, vous devez &ecirc;tre tr&egrave;s attentifs lorsque 
            vous utilisez autre chose et vous demander si c'est vraiment n&eacute;cessaire.
                </p></dd></dl></div></div></div></body></html>