<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>&#1043;&#1083;&#1072;&#1074;&#1072; 6. Collection Mapping</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"><link rel="home" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"><link rel="up" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"><link rel="previous" href="mapping.html" title="&#1043;&#1083;&#1072;&#1074;&#1072; 5. &#1054;&#1089;&#1085;&#1086;&#1074;&#1099; &#1086;&#1073;&#1098;&#1077;&#1082;&#1090;&#1085;&#1086;-&#1088;&#1077;&#1083;&#1103;&#1094;&#1080;&#1086;&#1085;&#1085;&#1086;&#1075;&#1086; &#1084;&#1072;&#1087;&#1087;&#1080;&#1085;&#1075;&#1072;"><link rel="next" href="components.html" title="&#1043;&#1083;&#1072;&#1074;&#1072; 7. &#1052;&#1072;&#1087;&#1087;&#1080;&#1085;&#1075; &#1082;&#1086;&#1084;&#1087;&#1086;&#1085;&#1077;&#1085;&#1090;&#1086;&#1074;"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">&#1043;&#1083;&#1072;&#1074;&#1072; 6. Collection Mapping</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="mapping.html">&#1055;&#1088;&#1077;&#1076;.</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="components.html">&#1057;&#1083;&#1077;&#1076;.</a></td></tr></table><hr></div><div class="chapter" lang="ru"><div class="titlepage"><div><div><h2 class="title"><a name="collections"></a>&#1043;&#1083;&#1072;&#1074;&#1072; 6. Collection Mapping</h2></div></div><div></div></div><div class="sect1" lang="ru"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-persistent"></a>6.1. Persistent Collections</h2></div></div><div></div></div><p>
            This section does not contain much example Java code. We assume you already know
            how to use Java's collections framework. If so, there's not really anything more
            to know - with a single caveat, you may use Java collections the same way you
            always have.
        </p><p>
            Hibernate can persist instances of
            <tt class="literal">java.util.Map</tt>,
            <tt class="literal">java.util.Set</tt>,
            <tt class="literal">java.util.SortedMap</tt>,
            <tt class="literal">java.util.SortedSet</tt>,
            <tt class="literal">java.util.List</tt>,
            and any array of persistent entities or values. Properties of type
            <tt class="literal">java.util.Collection</tt> or
            <tt class="literal">java.util.List</tt>
            may also be persisted with "bag" semantics.
        </p><p>
            Now the caveat: persistent collections do not retain any extra semantics added by the class
            implementing the collection interface (eg. iteration order of a <tt class="literal">LinkedHashSet</tt>).
            The persistent collections actually behave like
            <tt class="literal">HashMap</tt>,
            <tt class="literal">HashSet</tt>,
            <tt class="literal">TreeMap</tt>,
            <tt class="literal">TreeSet</tt> and
            <tt class="literal">ArrayList</tt>
            respectively. Furthermore, the Java type of a property holding a collection must be
            the interface type (ie. <tt class="literal">Map</tt>, <tt class="literal">Set</tt> or
            <tt class="literal">List</tt>; never <tt class="literal">HashMap</tt>, <tt class="literal">TreeSet</tt> or
            <tt class="literal">ArrayList</tt>). This restriction exists because, when you're not looking,
            Hibernate sneakily replaces your instances of <tt class="literal">Map</tt>, <tt class="literal">Set</tt>
            and <tt class="literal">List</tt> with instances of its own persistent implementations of
            <tt class="literal">Map</tt>, <tt class="literal">Set</tt> or <tt class="literal">List</tt>. (So also be careful
            when using <tt class="literal">==</tt> on your collections.)
        </p><pre class="programlisting">Cat cat = new DomesticCat();
Cat kitten = new DomesticCat();
....
Set kittens = new HashSet();
kittens.add(kitten);
cat.setKittens(kittens);
session.save(cat);
kittens = cat.getKittens(); //Okay, kittens collection is a Set
(HashSet) cat.getKittens(); //Error!</pre><p>
            Collections obey the usual rules for value types: no shared
            references, created and deleted along with containing entity. Due to the underlying
            relational model, they do not support null value semantics; Hibernate does not
            distinguish between a null collection reference and an empty collection.
        </p><p>
            Collections are automatically persisted when referenced by a persistent object
            and automatically deleted when unreferenced. If a collection is passed from one
            persistent object to another, its elements might be moved from one table to
            another. You shouldn't have to worry much about any of this. Just use
            Hibernate's collections the same way you use ordinary Java collections, but
            make sure you understand the semantics of bidirectional associations (discussed
            later) before using them.
        </p><p>
            Collection instances are distinguished in the database by a foreign key to
            the owning entity. This foreign key is referred to as the
            <span class="emphasis"><em>collection key </em></span>. The collection key is mapped by
            the <tt class="literal">&lt;key&gt;</tt> element.
        </p><p>
            Collections may contain almost any other Hibernate type, including all basic types,
            custom types, entity types and components. This is an important definition: An object
            in a collection can either be handled with "pass by value" semantics (it therefore
            fully depends on the collection owner) or it can be a reference to another entity
            with an own lifecycle. Collections may not contain other collections. The contained type
            is referred to as the <span class="emphasis"><em>collection element type</em></span>. Collection elements
            are mapped by <tt class="literal">&lt;element&gt;</tt>, <tt class="literal">&lt;composite-element&gt;</tt>,
            <tt class="literal">&lt;one-to-many&gt;</tt>, <tt class="literal">&lt;many-to-many&gt;</tt> or
            <tt class="literal">&lt;many-to-any&gt;</tt>. The first two map elements with value semantics,
            the other three are used to map entity associations.
        </p><p>
            All collection types except <tt class="literal">Set</tt> and bag have an <span class="emphasis"><em>index
            </em></span> column - a column that maps to an array or <tt class="literal">List</tt> index or
            <tt class="literal">Map</tt> key. The index of a <tt class="literal">Map</tt> may be of any
            basic type, an entity type or even a composite type (it may not be a collection). The
            index of an array or list is always of type <tt class="literal">integer</tt>. Indexes are
            mapped using <tt class="literal">&lt;index&gt;</tt>, <tt class="literal">&lt;index-many-to-many&gt;</tt>,
            <tt class="literal">&lt;composite-index&gt;</tt> or <tt class="literal">&lt;index-many-to-any&gt;</tt>.
        </p><p>
            There are quite a range of mappings that can be generated for collections,
            covering many common relational models. We suggest you experiment with the
            schema generation tool to get a feeling for how various mapping declarations
            translate to database tables.
        </p></div><div class="sect1" lang="ru"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-mapping"></a>6.2. Mapping a Collection</h2></div></div><div></div></div><p>
            Collections are declared by the
            <tt class="literal">&lt;set&gt;</tt>,
            <tt class="literal">&lt;list&gt;</tt>,
            <tt class="literal">&lt;map&gt;</tt>,
            <tt class="literal">&lt;bag&gt;</tt>,
            <tt class="literal">&lt;array&gt;</tt> and
            <tt class="literal">&lt;primitive-array&gt;</tt> elements.
            <tt class="literal">&lt;map&gt;</tt> is representative:
        </p><div class="programlistingco"><pre class="programlisting">&lt;map
    name="propertyName"                                         <span class="co">(1)</span>
    table="table_name"                                          <span class="co">(2)</span>
    schema="schema_name"                                        <span class="co">(3)</span>
    lazy="true|false"                                           <span class="co">(4)</span>
    inverse="true|false"                                        <span class="co">(5)</span>
    cascade="all|none|save-update|delete|all-delete-orphan"     <span class="co">(6)</span>
    sort="unsorted|natural|comparatorClass"                     <span class="co">(7)</span>
    order-by="column_name asc|desc"                             <span class="co">(8)</span>
    where="arbitrary sql where condition"                       <span class="co">(9)</span>
    outer-join="true|false|auto"                                <span class="co">(10)</span>
    batch-size="N"                                              <span class="co">(11)</span>
    access="field|property|ClassName"                           <span class="co">(12)</span>
&gt;

    &lt;key .... /&gt;
    &lt;index .... /&gt;
    &lt;element .... /&gt;
&lt;/map&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">name</tt> the collection property name
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">table</tt> (optional - defaults to property name) the
                        name of the collection table (not used for one-to-many associations)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">schema</tt> (optional) the name of a table schema to
                        override the schema declared on the root element
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                        <tt class="literal">lazy</tt> (optional - defaults to <tt class="literal">false</tt>)
                        enable lazy initialization (not used for arrays)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                        <tt class="literal">inverse</tt> (optional - defaults to <tt class="literal">false</tt>)
                        mark this collection as the "inverse" end of a bidirectional association
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                        <tt class="literal">cascade</tt> (optional - defaults to <tt class="literal">none</tt>)
                        enable operations to cascade to child entities
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                        <tt class="literal">sort</tt> (optional) specify a sorted collection with
                        <tt class="literal">natural</tt> sort order, or a given comparator class
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                        <tt class="literal">order-by</tt> (optional, JDK1.4 only) specify a table column (or columns)
                        that define the iteration order of the <tt class="literal">Map</tt>, <tt class="literal">Set</tt>
                        or bag, together with an optional <tt class="literal">asc</tt> or <tt class="literal">desc</tt>
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                        <tt class="literal">where</tt> (optional) specify an arbitrary SQL <tt class="literal">WHERE</tt>
                        condition to be used when retrieving or removing the collection (useful if the
                        collection should contain only a subset of the available data)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                        <tt class="literal">outer-join</tt> (optional) specify that the collection should be fetched
                        by outer join, whenever possible. Only one collection may be fetched by outer join per
                        SQL <tt class="literal">SELECT</tt>.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(11)</td><td valign="top" align="left"><p>
                        <tt class="literal">batch-size</tt> (optional, defaults to <tt class="literal">1</tt>) specify a
                        "batch size" for lazily fetching instances of this collection.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(12)</td><td valign="top" align="left"><p>
                        <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                        strategy Hibernate should use for accessing the property value.
                    </p></td></tr></table></div></div><p>
            The mapping of a <tt class="literal">List</tt> or array requires a seperate table column holding the array
            or list index (the <tt class="literal">i</tt> in <tt class="literal">foo[i]</tt>). If your relational model doesn't
            have an index column, e.g. if you're working with legacy data, use an unordered <tt class="literal">Set</tt>
            instead. This seems to put people off who assume that <tt class="literal">List</tt> should just be a more
            convenient way of accessing an unordered collection. Hibernate collections strictly obey the actual
            semantics attached to the <tt class="literal">Set</tt>, <tt class="literal">List</tt> and <tt class="literal">Map</tt>
            interfaces. <tt class="literal">List</tt> elements don't just spontaneously rearrange themselves!
        </p><p>
            On the other hand, people who planned to use the <tt class="literal">List</tt> to emulate
            <span class="emphasis"><em>bag</em></span> semantics have a legitimate grievance here.
            A bag is an unordered, unindexed collection which may contain the same element multiple times.
            The Java collections framework lacks a <tt class="literal">Bag</tt> interface, hence you have to emulate
            it with a <tt class="literal">List</tt>. Hibernate lets you map properties of type <tt class="literal">List</tt>
            or <tt class="literal">Collection</tt> with the <tt class="literal">&lt;bag&gt;</tt> element. Note that bag
            semantics are not really part of the <tt class="literal">Collection</tt> contract and they actually
            conflict with the semantics of the <tt class="literal">List</tt> contract (however, you can sort
            the bag arbitrarily, discussed later in this chapter).
        </p><p>
            Note: Large Hibernate bags mapped with <tt class="literal">inverse="false"</tt> are inefficient and
            should be  avoided; Hibernate can't create, delete or update rows individually, because there is
            no key that may be used to identify an individual row.
        </p></div><div class="sect1" lang="ru"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-ofvalues"></a>6.3. Collections of Values and Many-To-Many Associations</h2></div></div><div></div></div><p>
            A collection table is required for any collection of values and any collection of
            references to other entities mapped as a many-to-many association (the natural semantics
            for a Java collection). The table requires (foreign) key column(s), element column(s) and
            possibly index column(s).
        </p><p>
            The foreign key from the collection table to the table of the owning class is
            declared using a <tt class="literal">&lt;key&gt;</tt> element.
        </p><div class="programlistingco"><pre class="programlisting">&lt;key column="column_name"/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (required): The name of the foreign key column.
                    </p></td></tr></table></div></div><p>
            For indexed collections like maps and lists, we require an <tt class="literal">&lt;index&gt;</tt>
            element. For lists, this column contains sequential integers numbered from zero. Make sure
            that your index really starts from zero if you have to deal with legacy data. For maps,
            the column may contain any values of any Hibernate type.
        </p><div class="programlistingco"><pre class="programlisting">&lt;index
        column="column_name"                <span class="co">(1)</span>
        type="typename"                     <span class="co">(2)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (required): The name of the column holding the
                        collection index values.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">type</tt> (optional, defaults to <tt class="literal">integer</tt>):
                        The type of the collection index.
                    </p></td></tr></table></div></div><p>
            Alternatively, a map may be indexed by objects of entity type. We use the
            <tt class="literal">&lt;index-many-to-many&gt;</tt> element.
        </p><div class="programlistingco"><pre class="programlisting">&lt;index-many-to-many
        column="column_name"                <span class="co">(1)</span>
        class="ClassName"                   <span class="co">(2)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (required): The name of the foreign key
                        column for the collection index values.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">class</tt> (required): The entity class used as the
                        collection index.
                    </p></td></tr></table></div></div><p>
            For a collection of values, we use the <tt class="literal">&lt;element&gt;</tt> tag.
        </p><div class="programlistingco"><pre class="programlisting">&lt;element
        column="column_name"                <span class="co">(1)</span>
        type="typename"                     <span class="co">(2)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (required): The name of the column holding the
                        collection element values.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">type</tt> (required): The type of the collection element.
                    </p></td></tr></table></div></div><p>
            A collection of entities with its own table corresponds to the relational notion
            of <span class="emphasis"><em>many-to-many association</em></span>. A many to many association is the
            most natural mapping of a Java collection but is not usually the best relational model.
        </p><div class="programlistingco"><pre class="programlisting">&lt;many-to-many
        column="column_name"                               <span class="co">(1)</span>
        class="ClassName"                                  <span class="co">(2)</span>
        outer-join="true|false|auto"                       <span class="co">(3)</span>
    /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (required): The name of the element foreign key column.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">class</tt> (required): The name of the associated class.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">outer-join</tt> (optional - defaults to <tt class="literal">auto</tt>):
                        enables outer-join fetching for this association when
                        <tt class="literal">hibernate.use_outer_join</tt> is set.
                    </p></td></tr></table></div></div><p>
            Some examples, first, a set of strings:
        </p><pre class="programlisting">&lt;set name="names" table="NAMES"&gt;
    &lt;key column="GROUPID"/&gt;
    &lt;element column="NAME" type="string"/&gt;
&lt;/set&gt;</pre><p>
            A bag containing integers (with an iteration order determined by the
            <tt class="literal">order-by</tt> attribute):
        </p><pre class="programlisting">&lt;bag name="sizes" table="SIZES" order-by="SIZE ASC"&gt;
    &lt;key column="OWNER"/&gt;
    &lt;element column="SIZE" type="integer"/&gt;
&lt;/bag&gt;</pre><p>
            An array of entities - in this case, a many to many association (note that
            the entities are lifecycle objects, <tt class="literal">cascade="all"</tt>):
        </p><pre class="programlisting">&lt;array name="foos" table="BAR_FOOS" cascade="all"&gt;
    &lt;key column="BAR_ID"/&gt;
    &lt;index column="I"/&gt;
    &lt;many-to-many column="FOO_ID" class="org.hibernate.Foo"/&gt;
&lt;/array&gt;</pre><p>
            A map from string indices to dates:
        </p><pre class="programlisting">&lt;map name="holidays" table="holidays" schema="dbo" order-by="hol_name asc"&gt;
    &lt;key column="id"/&gt;
    &lt;index column="hol_name" type="string"/&gt;
    &lt;element column="hol_date" type="date"/&gt;
&lt;/map&gt;</pre><p>
            A list of components (discussed in the next chapter):
        </p><pre class="programlisting">&lt;list name="carComponents" table="car_components"&gt;
    &lt;key column="car_id"/&gt;
    &lt;index column="posn"/&gt;
    &lt;composite-element class="org.hibernate.car.CarComponent"&gt;
            &lt;property name="price" type="float"/&gt;
            &lt;property name="type" type="org.hibernate.car.ComponentType"/&gt;
            &lt;property name="serialNumber" column="serial_no" type="string"/&gt;
    &lt;/composite-element&gt;
&lt;/list&gt;</pre></div><div class="sect1" lang="ru"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-onetomany"></a>6.4. One-To-Many Associations</h2></div></div><div></div></div><p>
            A <span class="emphasis"><em>one to many association</em></span> links the tables of two classes
            <span class="emphasis"><em>directly</em></span>, with no intervening collection table.
            (This implements a <span class="emphasis"><em>one-to-many</em></span> relational model.) This
            relational model loses some of the semantics of Java collections:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    No null values may be contained in a map, set or list
                </p></li><li><p>
                    An instance of the contained entity class may not belong to more than
                    one instance of the collection
                </p></li><li><p>
                    An instance of the contained entity class may not appear at more than
                    one value of the collection index
                </p></li></ul></div><p>
            An association from <tt class="literal">Foo</tt> to <tt class="literal">Bar</tt> requires the
            addition of a key column and possibly an index column to the table of the contained
            entity class, <tt class="literal">Bar</tt>. These columns are mapped using the
            <tt class="literal">&lt;key&gt;</tt> and <tt class="literal">&lt;index&gt;</tt> elements
            described above.
        </p><p>
            The <tt class="literal">&lt;one-to-many&gt;</tt> tag indicates a one to many association.
        </p><div class="programlistingco"><pre class="programlisting">&lt;one-to-many class="ClassName"/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">class</tt> (required): The name of the associated class.
                    </p></td></tr></table></div></div><p>
            Example:
        </p><pre class="programlisting">&lt;set name="bars"&gt;
    &lt;key column="foo_id"/&gt;
    &lt;one-to-many class="org.hibernate.Bar"/&gt;
&lt;/set&gt;</pre><p>
            Notice that the <tt class="literal">&lt;one-to-many&gt;</tt> element does not need to
            declare any columns. Nor is it necessary to specify the <tt class="literal">table</tt>
            name anywhere.
        </p><p>
            <span class="emphasis"><em>Very Important Note:</em></span> If the <tt class="literal">&lt;key&gt;</tt>
            column of a <tt class="literal">&lt;one-to-many&gt;</tt> association is declared
            <tt class="literal">NOT NULL</tt>, Hibernate may cause constraint violations
            when it creates or updates the association. To prevent this problem,
            <span class="emphasis"><em>you must use a bidirectional association</em></span> with the many valued
            end (the set or bag) marked as <tt class="literal">inverse="true"</tt>.
            See the discussion of bidirectional associations later in this chapter.
        </p></div><div class="sect1" lang="ru"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-lazy"></a>6.5. Lazy Initialization</h2></div></div><div></div></div><p>
            Collections (other than arrays) may be lazily initialized, meaning they load
            their state from the database only when the application needs to access it.
            Initialization happens transparently to the user so the application would not
            normally need to worry about this (in fact, transparent lazy initialization is
            the main reason why Hibernate needs its own collection implementations).
            However, if the application tries something like this:
        </p><pre class="programlisting">s = sessions.openSession();
User u = (User) s.find("from User u where u.name=?", userName, Hibernate.STRING).get(0);
Map permissions = u.getPermissions();
s.connection().commit();
s.close();

Integer accessLevel = (Integer) permissions.get("accounts");  // Error!</pre><p>
            It could be in for a nasty surprise. Since the permissions collection was not
            initialized when the <tt class="literal">Session</tt> was committed,
            the collection will never be able to load its state. The fix is to move the
            line that reads from the collection to just before the commit. (There are
            other more advanced ways to solve this problem, however.)
        </p><p>
            Alternatively, use a non-lazy collection. Since lazy initialization can lead to
            bugs like that above, non-laziness is the default. However, it is intended that
            lazy initialization be used for almost all collections, especially for
            collections of entities (for reasons of efficiency).
        </p><p>
            Exceptions that occur while lazily initializing a collection are wrapped in a
            <tt class="literal">LazyInitializationException</tt>.
        </p><p>
            Declare a lazy collection using the optional <tt class="literal">lazy</tt> attribute:
        </p><pre class="programlisting">&lt;set name="names" table="NAMES" lazy="true"&gt;
    &lt;key column="group_id"/&gt;
    &lt;element column="NAME" type="string"/&gt;
&lt;/set&gt;</pre><p>
            In some application architectures, particularly where the code that accesses data
            using Hibernate, and the code that uses it are in different application layers, it
            can be a problem to ensure that the <tt class="literal">Session</tt> is open when a
            collection is initialized. They are two basic ways to deal with this issue:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    In a web-based application, a servlet filter can be used to close the
                    <tt class="literal">Session</tt> only at the very end of a user request, once
                    the rendering of the view is complete. Of course, this places heavy
                    demands upon the correctness of the exception handling of your application
                    infrastructure. It is vitally important that the <tt class="literal">Session</tt>
                    is closed and the transaction ended before returning to the user, even
                    when an exception occurs during rendering of the view. The servlet filter
                    has to be able to access the <tt class="literal">Session</tt> for this approach.
                    We recommend that a <tt class="literal">ThreadLocal</tt> variable be used to
                    hold the current <tt class="literal">Session</tt> (see chapter 1,
                    <a href="quickstart.html#quickstart-playingwithcats" title="1.4. &#1055;&#1086;&#1080;&#1075;&#1088;&#1072;&#1077;&#1084; &#1089; &#1082;&#1086;&#1090;&#1072;&#1084;&#1080;">&#1056;&#1072;&#1079;&#1076;&#1077;&#1083;&nbsp;1.4, &laquo;&#1055;&#1086;&#1080;&#1075;&#1088;&#1072;&#1077;&#1084; &#1089; &#1082;&#1086;&#1090;&#1072;&#1084;&#1080;&raquo;</a>, for an example implementation).
                </p></li><li><p>
                    In an application with a seperate business tier, the business logic must
                    "prepare" all collections that will be needed by the web tier before
                    returning. This means that the business tier should load all the data and
                    return all the data already initialized to the presentation/web tier that
                    is required for a particular use case. Usually, the application calls
                    <tt class="literal">Hibernate.initialize()</tt> for each collection that will
                    be needed in the web tier (this call must occur before the session is closed)
                    or retrieves the collection eagerly using a Hibernate query with a
                    <tt class="literal">FETCH</tt> clause.
                </p></li><li><p>
                    You may also attach a previously loaded object to a new <tt class="literal">Session</tt>
                    with <tt class="literal">update()</tt> or <tt class="literal">lock()</tt> before
                    accessing unitialized collections (or other proxies). Hibernate can not
                    do this automatically, as it would introduce ad hoc transaction semantics!
                </p></li></ul></div><p>
            You can use the <tt class="literal">filter()</tt> method of the Hibernate Session API to
            get the size of a collection without initializing it:
        </p><pre class="programlisting">( (Integer) s.filter( collection, "select count(*)" ).get(0) ).intValue()</pre><p>
            <tt class="literal">filter()</tt> or <tt class="literal">createFilter()</tt> are also used to
            efficiently retrieve subsets of a collection without needing to initialize the whole
            collection.
        </p></div><div class="sect1" lang="ru"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-sorted"></a>6.6. Sorted Collections</h2></div></div><div></div></div><p>
            Hibernate supports collections implementing <tt class="literal">java.util.SortedMap</tt> and
            <tt class="literal">java.util.SortedSet</tt>. You must specify a comparator in the mapping file:
        </p><pre class="programlisting">&lt;set name="aliases" table="person_aliases" sort="natural"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="string"/&gt;
&lt;/set&gt;

&lt;map name="holidays" sort="my.custom.HolidayComparator" lazy="true"&gt;
    &lt;key column="year_id"/&gt;
    &lt;index column="hol_name" type="string"/&gt;
    &lt;element column="hol_date" type="date"/&gt;
&lt;/map&gt;</pre><p>
            Allowed values of the <tt class="literal">sort</tt> attribute are <tt class="literal">unsorted</tt>,
            <tt class="literal">natural</tt> and the name of a class implementing
            <tt class="literal">java.util.Comparator</tt>.
        </p><p>
            Sorted collections actually behave like <tt class="literal">java.util.TreeSet</tt> or
            <tt class="literal">java.util.TreeMap</tt>.
        </p><p>
            If you want the database itself to order the collection elements use the
            <tt class="literal">order-by</tt> attribute of <tt class="literal">set</tt>, <tt class="literal">bag</tt>
            or <tt class="literal">map</tt> mappings. This solution is only available under
            JDK 1.4 or higher (it is implemented using <tt class="literal">LinkedHashSet</tt> or
            <tt class="literal">LinkedHashMap</tt>). This performs the ordering in the SQL query, not in
            memory.
        </p><pre class="programlisting">&lt;set name="aliases" table="person_aliases" order-by="name asc"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="string"/&gt;
&lt;/set&gt;

&lt;map name="holidays" order-by="hol_date, hol_name" lazy="true"&gt;
    &lt;key column="year_id"/&gt;
    &lt;index column="hol_name" type="string"/&gt;
    &lt;element column="hol_date type="date"/&gt;
&lt;/map&gt;</pre><p>
            Note that the value of the <tt class="literal">order-by</tt> attribute is an SQL ordering, not
            a HQL ordering!
        </p><p>
            Associations may even be sorted by some arbitrary criteria at runtime using a
            <tt class="literal">filter()</tt>.
        </p><pre class="programlisting">sortedUsers = s.filter( group.getUsers(), "order by this.name" );</pre></div><div class="sect1" lang="ru"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-idbag"></a>6.7. <tt class="literal">Using an &lt;idbag&gt;</tt></h2></div></div><div></div></div><p>
            If you've fully embraced our view that composite keys are a bad thing and that
            entities should have synthetic identifiers (surrogate keys), then you might
            find it a bit odd that the many to many associations and collections of values
            that we've shown so far all map to tables with composite keys! Now, this point
            is quite arguable; a pure association table doesn't seem to benefit much from
            a surrogate key (though a collection of composite values <span class="emphasis"><em>might</em></span>).
            Nevertheless, Hibernate provides a (slightly experimental) feature that allows
            you to map many to many associations and collections of values to a table with
            a surrogate key.
        </p><p>
            The <tt class="literal">&lt;idbag&gt;</tt> element lets you map a <tt class="literal">List</tt>
            (or <tt class="literal">Collection</tt>) with bag semantics.
        </p><pre class="programlisting">&lt;idbag name="lovers" table="LOVERS" lazy="true"&gt;
    &lt;collection-id column="ID" type="long"&gt;
        &lt;generator class="hilo"/&gt;
    &lt;/collection-id&gt;
    &lt;key column="PERSON1"/&gt;
    &lt;many-to-many column="PERSON2" class="eg.Person" outer-join="true"/&gt;
&lt;/idbag&gt;</pre><p>
            As you can see, an <tt class="literal">&lt;idbag&gt;</tt> has a synthetic id generator,
            just like an entity class! A different surrogate key is assigned to each collection
            row. Hibernate does not provide any mechanism to discover the surrogate key value
            of a particular row, however.
        </p><p>
            Note that the update performance of an <tt class="literal">&lt;idbag&gt;</tt> is
            <span class="emphasis"><em>much</em></span> better than a regular <tt class="literal">&lt;bag&gt;</tt>!
            Hibernate can locate individual rows efficiently and update or delete them
            individually, just like a list, map or set.
        </p><p>
            In the current implementation, the <tt class="literal">identity</tt> identifier generation
            strategy is not supported for <tt class="literal">&lt;idbag&gt;</tt> collection identifiers.
        </p></div><div class="sect1" lang="ru"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-bidirectional"></a>6.8. Bidirectional Associations</h2></div></div><div></div></div><p>
            A <span class="emphasis"><em>bidirectional association</em></span> allows navigation from both
            "ends" of the association. Two kinds of bidirectional association are
            supported:

            </p><div class="variablelist"><dl><dt><span class="term">one-to-many</span></dt><dd><p>
                            set or bag valued at one end, single-valued at the other
                        </p></dd><dt><span class="term">many-to-many</span></dt><dd><p>
                            set or bag valued at both ends
                        </p></dd></dl></div><p>

        </p><p>
            Please note that Hibernate does not support bidirectional one-to-many associations
            with an indexed collection (list, map or array) as the "many" end, you have to
            use a set or bag mapping.
        </p><p>
            You may specify a bidirectional many-to-many association simply by mapping two
            many-to-many associations to the same database table and declaring one end as
            <span class="emphasis"><em>inverse</em></span> (which one is your choice). Here's an example of
            a bidirectional many-to-many association from a class back to <span class="emphasis"><em>itself</em></span>
            (each category can have many items and each item can be in many categories):
        </p><pre class="programlisting">&lt;class name="org.hibernate.auction.Category"&gt;
    &lt;id name="id" column="ID"/&gt;
    ...
    &lt;bag name="items" table="CATEGORY_ITEM" lazy="true"&gt;
        &lt;key column="CATEGORY_ID"/&gt;
        &lt;many-to-many class="org.hibernate.auction.Item" column="ITEM_ID"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;

&lt;class name="org.hibernate.auction.Item"&gt;
    &lt;id name="id" column="ID"/&gt;
    ...

    &lt;!-- inverse end --&gt;
    &lt;bag name="categories" table="CATEGORY_ITEM" inverse="true" lazy="true"&gt;
        &lt;key column="ITEM_ID"/&gt;
        &lt;many-to-many class="org.hibernate.auction.Category" column="CATEGORY_ID"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;</pre><p>
            Changes made only to the inverse end of the association are <span class="emphasis"><em>not</em></span>
            persisted. This means that Hibernate has two representations in memory for every
            bidirectional association, one link from A to B and another link from B to A. This
            is easier to understand if you think about the Java object model and how we create
            a many-to-many relationship in Java:
        </p><pre class="programlisting">
category.getItems().add(item);          // The category now "knows" about the relationship
item.getCategories().add(category);     // The item now "knows" about the relationship

session.update(item);                     // No effect, nothing will be saved!
session.update(category);                 // The relationship will be saved</pre><p>
            The non-inverse side is used to save the in-memory representation to the database.
            We would get an unneccessary INSERT/UPDATE and probably even a foreign key violation
            if both would trigger changes! The same is of course also true for bidirectional
            one-to-many associations.
        </p><p>
            You may map a bidirectional one-to-many association by mapping a one-to-many association
            to the same table column(s) as a many-to-one association and declaring the many-valued
            end <tt class="literal">inverse="true"</tt>.
        </p><pre class="programlisting">&lt;class name="eg.Parent"&gt;
    &lt;id name="id" column="id"/&gt;
    ....
    &lt;set name="children" inverse="true" lazy="true"&gt;
        &lt;key column="parent_id"/&gt;
        &lt;one-to-many class="eg.Child"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="eg.Child"&gt;
    &lt;id name="id" column="id"/&gt;
    ....
    &lt;many-to-one name="parent" class="eg.Parent" column="parent_id"/&gt;
&lt;/class&gt;</pre><p>
            Mapping one end of an association with <tt class="literal">inverse="true"</tt> doesn't
            affect the operation of cascades, both are different concepts!
        </p></div><div class="sect1" lang="ru"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-ternary"></a>6.9. Ternary Associations</h2></div></div><div></div></div><p>
            There are two possible approaches to mapping a ternary association. One approach is to use
            composite elements (discussed below). Another is to use a <tt class="literal">Map</tt> with an
            association as its index:
        </p><pre class="programlisting">&lt;map name="contracts" lazy="true"&gt;
    &lt;key column="employer_id"/&gt;
    &lt;index-many-to-many column="employee_id" class="Employee"/&gt;
    &lt;one-to-many class="Contract"/&gt;
&lt;/map&gt;</pre><pre class="programlisting">&lt;map name="connections" lazy="true"&gt;
    &lt;key column="node1_id"/&gt;
    &lt;index-many-to-many column="node2_id" class="Node"/&gt;
    &lt;many-to-many column="connection_id" class="Connection"/&gt;
&lt;/map&gt;</pre></div><div class="sect1" lang="ru"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-heterogeneous"></a>6.10. Heterogeneous Associations</h2></div></div><div></div></div><p>
	        The <tt class="literal">&lt;many-to-any&gt;</tt> and <tt class="literal">&lt;index-many-to-any&gt;</tt>
	        elements provide for true heterogeneous associations. These mapping elements work in the
	        same way as the <tt class="literal">&lt;any&gt;</tt> element - and should also be used
	        rarely, if ever.
	    </p></div><div class="sect1" lang="ru"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-example"></a>6.11. Collection examples</h2></div></div><div></div></div><p>
            The previous sections are pretty confusing. So lets look at an example. This
            class:
        </p><pre class="programlisting">package eg;
import java.util.Set;

public class Parent {
    private long id;
    private Set children;

    public long getId() { return id; }
    private void setId(long id) { this.id=id; }

    private Set getChildren() { return children; }
    private void setChildren(Set children) { this.children=children; }

    ....
    ....
}</pre><p>
            has a collection of <tt class="literal">eg.Child</tt> instances. If each
            child has at most one parent, the most natural mapping is a one-to-many
            association:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="eg.Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" lazy="true"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="eg.Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="eg.Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            This maps to the following table definitions:
        </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null primary key, name varchar(255), parent_id bigint )
alter table child add constraint childfk0 (parent_id) references parent</pre><p>
            If the parent is <span class="emphasis"><em>required</em></span>, use a bidirectional one-to-many
            association:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="eg.Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" inverse="true" lazy="true"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="eg.Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="eg.Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
        &lt;many-to-one name="parent" class="eg.Parent" column="parent_id" not-null="true"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            Notice the <tt class="literal">NOT NULL</tt> constraint:
        </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null
                     primary key,
                     name varchar(255),
                     parent_id bigint not null )
alter table child add constraint childfk0 (parent_id) references parent</pre><p>
            On the other hand, if a child might have multiple parents, a many-to-many
            association is appropriate:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="eg.Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" lazy="true" table="childset"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;many-to-many class="eg.Child" column="child_id"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="eg.Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            Table definitions:
        </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null primary key, name varchar(255) )
create table childset ( parent_id bigint not null,
                        child_id bigint not null,
                        primary key ( parent_id, child_id ) )
alter table childset add constraint childsetfk0 (parent_id) references parent
alter table childset add constraint childsetfk1 (child_id) references child</pre></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="mapping.html">&#1055;&#1088;&#1077;&#1076;.</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="index.html">&#1059;&#1088;&#1086;&#1074;&#1077;&#1085;&#1100; &#1074;&#1099;&#1096;&#1077;</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="components.html">&#1057;&#1083;&#1077;&#1076;.</a></td></tr><tr><td width="40%" align="left" valign="top">&#1043;&#1083;&#1072;&#1074;&#1072; 5. &#1054;&#1089;&#1085;&#1086;&#1074;&#1099; &#1086;&#1073;&#1098;&#1077;&#1082;&#1090;&#1085;&#1086;-&#1088;&#1077;&#1083;&#1103;&#1094;&#1080;&#1086;&#1085;&#1085;&#1086;&#1075;&#1086; &#1084;&#1072;&#1087;&#1087;&#1080;&#1085;&#1075;&#1072;&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">&#1053;&#1072;&#1095;&#1072;&#1083;&#1086;</a></td><td width="40%" align="right" valign="top">&nbsp;&#1043;&#1083;&#1072;&#1074;&#1072; 7. &#1052;&#1072;&#1087;&#1087;&#1080;&#1085;&#1075; &#1082;&#1086;&#1084;&#1087;&#1086;&#1085;&#1077;&#1085;&#1090;&#1086;&#1074;</td></tr></table></div></body></html>